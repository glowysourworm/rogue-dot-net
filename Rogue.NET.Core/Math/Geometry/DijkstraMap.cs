using Rogue.NET.Common.Collection;
using Rogue.NET.Common.Utility;
using Rogue.NET.Core.Model.Scenario.Content.Layout;
using Rogue.NET.Core.Model.Scenario.Content.Layout.Interface;
using Rogue.NET.Core.Processing.Model.Extension;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace Rogue.NET.Core.Math.Geometry
{

    /*
    /// <summary>
    /// Provides shortest-distance methods based on Dijkstra's Algorithm.
    /// </summary>
    // *** TODO:TERRAIN  INTEGRATE THIS WITH THE LEVEL GRID TO PREVENT ALLOCATING MEMORY FOR THE GRID LOCATIONS
    public class DijkstraMap
    {
        /// <summary>
        /// Constant that indictaes a region of the grid - typically used for a mask to prevent iterating
        /// back onto the regions.
        /// </summary>
        public readonly static double RegionFeatureConstant = 10000;

        readonly IGridLocator _sourceLocation;
        readonly IGridLocator _targetLocation;

        const double CELL_MOVEMENT_COST = 1.0;

        // Map used to generate a cost weighting for the algorithm
        double[,] _inputMap;

        // Map generated by the algorithm
        DijkstraMapNode[,] _outputMap;

        // Flag to show that algorithm has run
        bool _hasRun;

        // Flag to denote cardinal movements only
        bool _obeyCardinalMovement;

        #region (protected) Nested Node Class
        protected class DijkstraMapNode : IComparer<DijkstraMapNode>, IComparable<DijkstraMapNode>
        {
            public int Column { get; private set; }
            public int Row { get; private set; }
            public double Weight { get; set; }

            public DijkstraMapNode(int column, int row, double weight)
            {
                this.Column = column;
                this.Row = row;
                this.Weight = weight;
            }

            public int Compare(DijkstraMapNode x, DijkstraMapNode y)
            {
                var comparison = x.Weight.CompareTo(y.Weight);

                // Default comparison to hash code
                if (comparison == 0)
                    return x.GetHashCode().CompareTo(y.GetHashCode());

                else
                    return comparison;
            }

            public int CompareTo(DijkstraMapNode other)
            {
                return Compare(this, other);
            }

            public override bool Equals(object obj)
            {
                if (obj is DijkstraMapNode)
                {
                    var node = (DijkstraMapNode)obj;

                    return node.Column == this.Column &&
                           node.Row == this.Row &&
                           node.Weight == this.Weight;
                }
                else
                    return false;
            }

            public override int GetHashCode()
            {
                return base.GetHashCode();
            }

            public override string ToString()
            {
                return string.Format("[ Column = {0}, Row = {1}, Weight = {2} ]", this.Column, this.Row, this.Weight); 
            }
        }
        #endregion

        /// <summary>
        /// Creates a Dijkstra map with an input cost map of zero
        /// </summary>
        public DijkstraMap(int width, int height, IGridLocator source, IGridLocator target, bool obeyCardinalMovement)
        {
            _inputMap = new double[width, height];
            _outputMap = new DijkstraMapNode[width, height];
            _sourceLocation = source;
            _targetLocation = target;
            _hasRun = false;
            _obeyCardinalMovement = obeyCardinalMovement;
        }

        /// <summary>
        /// Creates a Dijkstra map with an input gradient defined by the 2D array
        /// </summary>
        public DijkstraMap(double[,] inputMap, IGridLocator source, IGridLocator target, bool obeyCardinalMovement)
        {
            _inputMap = inputMap;
            _outputMap = new DijkstraMapNode[inputMap.GetLength(0), inputMap.GetLength(1)];
            _sourceLocation = source;
            _targetLocation = target;
            _hasRun = false;
            _obeyCardinalMovement = obeyCardinalMovement;
        }

        public bool Run()
        {
            // Initialize the output map
            for (int i = 0; i < _outputMap.GetLength(0); i++)
            {
                // Set to "infinity" except for the start location
                for (int j = 0; j < _outputMap.GetLength(1); j++)
                {
                    _outputMap[i, j] = new DijkstraMapNode(i, j, ((i == _sourceLocation.Column) && (j == _sourceLocation.Row)) ? 0 : double.MaxValue);
                }
            }

            // Track visited elements AND queued elements (prevents a LOT of extra looking up on the queue)
            var visitedMap = new bool[_inputMap.GetLength(0), _inputMap.GetLength(1)];

            // TODO:TERRAIN - USE GRID TO PREVENT ALLOCATING MORE GRID LOCATIONS
            // Track the frontier cells to check lowest cost next step
            var frontier = new SortedList<DijkstraMapNode, DijkstraMapNode>();

            // Process the first element
            var column = _sourceLocation.Column;
            var row = _sourceLocation.Row;

            // Iterate while target not reached (AND) not visited (AND) next location found
            while (!(column == _targetLocation.Column &&
                     row == _targetLocation.Row) &&
                    !visitedMap[column, row])
            {
                // Set current parameters
                var currentWeight = _outputMap[column, row].Weight;

                // Mark the element as visited
                visitedMap[column, row] = true;

                // Search cardinally adjacent elements (N,S,E,W)
                var north = row - 1 >= 0;
                var south = row + 1 < _inputMap.GetLength(1);
                var east = column + 1 < _inputMap.GetLength(0);
                var west = column - 1 >= 0;

                // Dijkstra Weight = Current Value + ("Change in Location Cost" + "Input Map Cost") 
                //
                // PROBLEM:         Negative gradient "costs" cause problems because they interrupt the
                //                 accumulated weight. Example: Walk-up-and-then-down a mountain. The
                //                 other side of the mountain will subtract off the accumulated cost of
                //                 climbing it.
                //
                // SOLUTION:       Use "Cost Map" instead of "Gradient Map"
                //

                // CARDINAL LOCATIONS
                if (north && !visitedMap[column, row - 1])
                {
                    // Update the output map
                    _outputMap[column, row - 1].Weight = System.Math.Min(_outputMap[column, row - 1].Weight, currentWeight + _inputMap[column, row - 1] + CELL_MOVEMENT_COST);

                    // Update the frontier (Force update of the sorted list)
                    if (frontier.ContainsKey(_outputMap[column, row - 1]))
                        frontier.Remove(_outputMap[column, row - 1]);

                    frontier.Add(_outputMap[column, row - 1], _outputMap[column, row - 1]);
                }

                if (south && !visitedMap[column, row + 1])
                {
                    _outputMap[column, row + 1].Weight = System.Math.Min(_outputMap[column, row + 1].Weight, currentWeight + _inputMap[column, row + 1] + CELL_MOVEMENT_COST);

                    // Update the frontier (Force update of the sorted list)
                    if (frontier.ContainsKey(_outputMap[column, row + 1]))
                        frontier.Remove(_outputMap[column, row + 1]);

                    frontier.Add(_outputMap[column, row + 1], _outputMap[column, row + 1]);
                }

                if (east && !visitedMap[column + 1, row])
                {
                    _outputMap[column + 1, row].Weight = System.Math.Min(_outputMap[column + 1, row].Weight, currentWeight + _inputMap[column + 1, row] + CELL_MOVEMENT_COST);

                    // Update the frontier (Force update of the sorted list)
                    if (frontier.ContainsKey(_outputMap[column + 1, row]))
                        frontier.Remove(_outputMap[column + 1, row]);

                    frontier.Add(_outputMap[column + 1, row], _outputMap[column + 1, row]);
                }

                if (west && !visitedMap[column - 1, row])
                {
                    _outputMap[column - 1, row].Weight = System.Math.Min(_outputMap[column - 1, row].Weight, currentWeight + _inputMap[column - 1, row] + CELL_MOVEMENT_COST);

                    // Update the frontier (Force update of the sorted list)
                    if (frontier.ContainsKey(_outputMap[column - 1, row]))
                        frontier.Remove(_outputMap[column - 1, row]);

                    frontier.Add(_outputMap[column - 1, row], _outputMap[column - 1, row]);
                }

                // NON-CARDINAL LOCATIONS
                if (!_obeyCardinalMovement && north && east && !visitedMap[column + 1, row - 1])
                {
                    _outputMap[column + 1, row - 1].Weight = System.Math.Min(_outputMap[column + 1, row - 1].Weight, currentWeight + _inputMap[column + 1, row - 1] + CELL_MOVEMENT_COST);

                    // Update the frontier (Force update of the sorted list)
                    if (frontier.ContainsKey(_outputMap[column + 1, row - 1]))
                        frontier.Remove(_outputMap[column + 1, row - 1]);

                    frontier.Add(_outputMap[column + 1, row - 1], _outputMap[column + 1, row - 1]);
                }

                if (!_obeyCardinalMovement && north && west && !visitedMap[column - 1, row - 1])
                {
                    _outputMap[column - 1, row - 1].Weight = System.Math.Min(_outputMap[column - 1, row - 1].Weight, currentWeight + _inputMap[column - 1, row - 1] + CELL_MOVEMENT_COST);

                    // Update the frontier (Force update of the sorted list)
                    if (frontier.ContainsKey(_outputMap[column - 1, row - 1]))
                        frontier.Remove(_outputMap[column - 1, row - 1]);

                    frontier.Add(_outputMap[column - 1, row - 1], _outputMap[column - 1, row - 1]);
                }

                if (!_obeyCardinalMovement && south && east && !visitedMap[column + 1, row + 1])
                {
                    _outputMap[column + 1, row + 1].Weight = System.Math.Min(_outputMap[column + 1, row + 1].Weight, currentWeight + _inputMap[column + 1, row + 1] + CELL_MOVEMENT_COST);

                    // Update the frontier (Force update of the sorted list)
                    if (frontier.ContainsKey(_outputMap[column + 1, row + 1]))
                        frontier.Remove(_outputMap[column + 1, row + 1]);

                    frontier.Add(_outputMap[column + 1, row + 1], _outputMap[column + 1, row + 1]);
                }

                if (!_obeyCardinalMovement && south && west && !visitedMap[column - 1, row + 1])
                {
                    _outputMap[column - 1, row + 1].Weight = System.Math.Min(_outputMap[column - 1, row + 1].Weight, currentWeight + _inputMap[column - 1, row + 1] + CELL_MOVEMENT_COST);

                    // Update the frontier (Force update of the sorted list)
                    if (frontier.ContainsKey(_outputMap[column - 1, row + 1]))
                        frontier.Remove(_outputMap[column - 1, row + 1]);

                    frontier.Add(_outputMap[column - 1, row + 1], _outputMap[column - 1, row + 1]);
                }

                // Select next location from frontier queue - using the smallest weight
                if (frontier.Count > 0)
                {
                    var nextNode = frontier.First().Key;

                    column = nextNode.Column;
                    row = nextNode.Row;

                    frontier.RemoveAt(0);
                }
            }

            _hasRun = true;

            // Return true if target location found
            return column == _targetLocation.Column &&
                   row == _targetLocation.Row;
        }

        public IEnumerable<IGridLocator> GeneratePath()
        {
            if (!_hasRun)
                throw new Exception("Must call Run() before generating a path DijkstraMap");

            var result = new List<IGridLocator>();

            var currentLocation = _targetLocation;
            var goalLocation = _sourceLocation;

            // Find the "easiest" route to the goal
            while (!currentLocation.Equals(goalLocation))
            {
                var column = currentLocation.Column;
                var row = currentLocation.Row;

                var north = row - 1 >= 0;
                var south = row + 1 < _outputMap.GetLength(1);
                var east = column + 1 < _outputMap.GetLength(0);
                var west = column - 1 >= 0;

                double lowestWeight = double.MaxValue;
                GridLocation lowestWeightLocation = currentLocation;

                if (north && (_outputMap[column, row - 1].Weight < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column, row - 1);
                    lowestWeight = _outputMap[column, row - 1].Weight;
                }

                if (south && (_outputMap[column, row + 1].Weight < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column, row + 1);
                    lowestWeight = _outputMap[column, row + 1].Weight;
                }

                if (east && (_outputMap[column + 1, row].Weight < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column + 1, row);
                    lowestWeight = _outputMap[column + 1, row].Weight;
                }

                if (west && (_outputMap[column - 1, row].Weight < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column - 1, row);
                    lowestWeight = _outputMap[column - 1, row].Weight;
                }

                if (north && east && !_obeyCardinalMovement && (_outputMap[column + 1, row - 1].Weight < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column + 1, row - 1);
                    lowestWeight = _outputMap[column + 1, row - 1].Weight;
                }

                if (north && west && !_obeyCardinalMovement && (_outputMap[column - 1, row - 1].Weight < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column - 1, row - 1);
                    lowestWeight = _outputMap[column - 1, row - 1].Weight;
                }

                if (south && east && !_obeyCardinalMovement && (_outputMap[column + 1, row + 1].Weight < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column + 1, row + 1);
                    lowestWeight = _outputMap[column + 1, row + 1].Weight;
                }

                if (south && west && !_obeyCardinalMovement && (_outputMap[column - 1, row + 1].Weight < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column - 1, row + 1);
                    lowestWeight = _outputMap[column - 1, row + 1].Weight;
                }

                if (lowestWeight == double.MaxValue)
                    throw new Exception("Mishandled Dijkstra Map DijkstraMap.GeneratePath()");

                currentLocation = lowestWeightLocation;

                // Add this to the path (TODO:TERRAIN REMOVE THIS - USE THE GRID DIRECTLY TO PREVEN ALLOCATION)
                if (!result.Any(location => location.Equals(lowestWeightLocation)) &&
                    !lowestWeightLocation.Equals(_sourceLocation) &&
                    !lowestWeightLocation.Equals(_targetLocation))
                    result.Add(lowestWeightLocation);

                else if (!lowestWeightLocation.Equals(_sourceLocation) &&
                         !lowestWeightLocation.Equals(_targetLocation))
                    throw new Exception("Loop in Dijkstra Map path finding");
            }

            return result;
        }

        // Use to help debug
        public void OutputCSV(string directory, string filePrefix)
        {
            var outputMap = new double[_outputMap.GetLength(0), _outputMap.GetLength(1)];

            for (int i=0;i<outputMap.GetLength(0);i++)
            {
                for (int j = 0; j < outputMap.GetLength(1); j++)
                    outputMap[i, j] = _outputMap[i, j].Weight;
            }

            OutputCSV(_inputMap, Path.Combine(directory, filePrefix + "_input.csv"));
            OutputCSV(outputMap, Path.Combine(directory, filePrefix + "_output.csv"));
        }

        private void OutputCSV(double[,] matrix, string fileName)
        {
            var builder = new StringBuilder();

            // Output by row CSV
            for (int j = 0; j < matrix.GetLength(1); j++)
            {
                for (int i = 0; i < matrix.GetLength(0); i++)
                {
                    if (matrix[i, j] != double.MaxValue)
                        builder.Append(matrix[i, j].ToString("F3") + ", ");

                    else
                        builder.Append("MAX, ");
                }

                // Remove trailing comma
                builder.Remove(builder.Length - 1, 1);

                // Append return carriage
                builder.Append("\r\n");
            }

            File.WriteAllText(fileName, builder.ToString());
        }
    }

    */

    public abstract class DijkstraMapBase
    {
        /// <summary>
        /// Delegate used to fetch a cost for the specified column / row of the grid
        /// </summary>
        public delegate float DijkstraMapCostCallback(int column, int row);

        /// <summary>
        /// Delegate used to fetch a reference to the associated grid locator
        /// </summary>
        public delegate IGridLocator DijkstraMapLocatorCallback(int column, int row);

        /// <summary>
        /// Source location for the Dijkstra scan
        /// </summary>
        protected IGridLocator SourceLocation { get; private set; }

        /// <summary>
        /// Target locations fot the Dijkstra scan
        /// </summary>
        protected IEnumerable<IGridLocator> TargetLocations { get; private set; }

        /// <summary>
        /// Flag for N, S, E, W movement only
        /// </summary>
        protected bool ObeyCardinalMovement { get; private set; }

        /// <summary>
        /// 2D array of output values for Dijkstra's algorithm
        /// </summary>
        protected float[,] OutputMap { get; private set; }

        /// <summary>
        /// Constant that indictaes a region of the grid - typically used for a mask to prevent iterating
        /// back onto the regions.
        /// </summary>
        protected readonly static float RegionFeatureConstant = 10000;

        private readonly int _width;
        private readonly int _height;
        private readonly DijkstraMapCostCallback _costCallback;
        private readonly DijkstraMapLocatorCallback _locatorCallback;

        private bool _hasRun;

        const int CELL_MOVEMENT_COST = 1;
        const float MAP_MAX_VALUE = float.MaxValue;

        protected DijkstraMapBase(int width, 
                                  int height, 
                                  bool obeyCardinalMovement,
                                  IGridLocator sourceLocation, 
                                  IEnumerable<IGridLocator> targetLocations, 
                                  DijkstraMapCostCallback costCallback, 
                                  DijkstraMapLocatorCallback locatorCallback)
        {
            _width = width;
            _height = height;

            _costCallback = costCallback;
            _locatorCallback = locatorCallback;

            this.ObeyCardinalMovement = obeyCardinalMovement;
            this.OutputMap = new float[width, height];
            this.SourceLocation = sourceLocation;
            this.TargetLocations = targetLocations;
        }

        protected void Run()
        {
            // Initialize the output map
            this.OutputMap.Iterate((column, row) =>
            {
                this.OutputMap[column, row] = ((column == this.SourceLocation.Column) && (row == this.SourceLocation.Row)) ? 0 : MAP_MAX_VALUE;
            });

            // Track visited elements AND queued elements (prevents a LOT of extra looking up on the queue)
            var visitedMap = new bool[_width, _height];

            // Track the frontier cells to check lowest cost next step
            var frontier = new BinarySearchTree<float, List<IGridLocator>>();

            // Track goal progress
            var goalDict = this.TargetLocations
                               .ToDictionary(location => location, location => false);

            // Process the first element
            var column = this.SourceLocation.Column;
            var row = this.SourceLocation.Row;

            // Iterate while any target not reached (AND) not visited
            while (!visitedMap[column, row] &&
                    goalDict.Any(element => !element.Value))
            {
                // Set current parameters
                var currentWeight = this.OutputMap[column, row];

                // Mark the element as visited
                visitedMap[column, row] = true;

                // Search cardinally adjacent elements (N,S,E,W)
                var north = row - 1 >= 0;
                var south = row + 1 < _height;
                var east = column + 1 < _width;
                var west = column - 1 >= 0;

                // Dijkstra Weight = Current Value + ("Change in Location Cost" + "Input Map Cost") 
                //
                // PROBLEM:         Negative gradient "costs" cause problems because they interrupt the
                //                 accumulated weight. Example: Walk-up-and-then-down a mountain. The
                //                 other side of the mountain will subtract off the accumulated cost of
                //                 climbing it.
                //
                // SOLUTION:       Use "Cost Map" instead of "Gradient Map"
                //

                // CARDINAL LOCATIONS
                if (north && !visitedMap[column, row - 1])
                {
                    UpdateOutputMap(frontier, currentWeight, column, row - 1);
                }

                if (south && !visitedMap[column, row + 1])
                {
                    UpdateOutputMap(frontier, currentWeight, column, row + 1);
                }

                if (east && !visitedMap[column + 1, row])
                {
                    UpdateOutputMap(frontier, currentWeight, column + 1, row);
                }

                if (west && !visitedMap[column - 1, row])
                {
                    UpdateOutputMap(frontier, currentWeight, column - 1, row);
                }

                // NON-CARDINAL LOCATIONS
                if (!this.ObeyCardinalMovement && north && east && !visitedMap[column + 1, row - 1])
                {
                    UpdateOutputMap(frontier, currentWeight, column + 1, row - 1);
                }

                if (!this.ObeyCardinalMovement && north && west && !visitedMap[column - 1, row - 1])
                {
                    UpdateOutputMap(frontier, currentWeight, column - 1, row - 1);
                }

                if (!this.ObeyCardinalMovement && south && east && !visitedMap[column + 1, row + 1])
                {
                    UpdateOutputMap(frontier, currentWeight, column + 1, row + 1);
                }

                if (!this.ObeyCardinalMovement && south && west && !visitedMap[column - 1, row + 1])
                {
                    UpdateOutputMap(frontier, currentWeight, column - 1, row + 1);
                }

                // Update goal dictionary
                for (int i=0;i<goalDict.Count;i++)
                {
                    var element = goalDict.ElementAt(i);

                    if (element.Key.Column == column &&
                        element.Key.Row == row)
                        goalDict[element.Key] = true;
                }

                // Select next location from frontier queue - using the smallest weight
                if (frontier.Count > 0)
                {
                    // Lists in the frontier must have an entry
                    var nextCostList = frontier.Min();
                    var nextCost = frontier.MinKey();

                    // Get the first from the list
                    var nextNode = nextCostList.First();

                    // Maintain frontier list
                    nextCostList.RemoveAt(0);

                    if (nextCostList.Count == 0)
                        frontier.Remove(nextCost);

                    // Move to next location
                    column = nextNode.Column;
                    row = nextNode.Row;
                }
            }

            _hasRun = true;
        }

        private void UpdateOutputMap(BinarySearchTree<float, List<IGridLocator>> frontier, float currentWeight, int column, int row)
        {
            // Procedure
            //
            // 1) Get the existing (old) weight from the output map
            // 2) Calculate the new weight and update the output map
            // 3) Fetch the old / new weight lists from the frontier BST
            // 4) Update the old / new weight lists and the frontier
            //
            // NOTE*** The weight lists should be very small - so running the update should
            //         not depend heavily on the List<>.Contains(...) performance.
            //
            //         Also, the AVL binary search tree has O(log n) performance for inserts
            //         / removals / and searches.
            //

            // Pre-fetch the cost list for this frontier location
            var oldWeight = this.OutputMap[column, row];

            // Update the output map
            this.OutputMap[column, row] = System.Math.Min(this.OutputMap[column, row], currentWeight + _costCallback(column, row) + CELL_MOVEMENT_COST);

            // Update the frontier
            var newWeight = this.OutputMap[column, row];

            // Fetch locator for this location
            var locator = _locatorCallback(column, row);

            // UPDATE THE FRONTIER
            var oldWeightList = frontier.Search(oldWeight);
            var newWeightList = frontier.Search(newWeight);

            // Both weights are absent from the frontier
            if (oldWeightList == null &&
                newWeightList == null)
                frontier.Insert(newWeight, new List<IGridLocator>() { locator });

            // Old weight list exists; New weight list is absent
            else if (oldWeightList != null &&
                     newWeightList == null)
            {
                // Check for existing locator
                if (oldWeightList.Contains(locator))
                    oldWeightList.Remove(locator);

                // Remove unused node
                if (oldWeightList.Count == 0)
                    frontier.Remove(oldWeight);

                // Insert new node in the frontier
                frontier.Insert(newWeight, new List<IGridLocator>() { locator });
            }

            // Old weight is absent; New weight exists
            else if (oldWeightList == null &&
                     newWeightList != null)
            {
                // Locator doesn't exist in list
                if (!newWeightList.Contains(locator))
                    newWeightList.Add(locator);
            }

            // Both old and new weight lists exist
            else
            {
                // Check that they're different lists
                if (oldWeightList != newWeightList)
                {
                    // Check that old weight list has element removed
                    if (oldWeightList.Contains(locator))
                        oldWeightList.Remove(locator);

                    // Check that new weight list has element added
                    if (!newWeightList.Contains(locator))
                        newWeightList.Add(locator);
                }
            }
        }

        protected IEnumerable<IGridLocator> GeneratePath(IGridLocator targetLocation)
        {
            if (!_hasRun)
                throw new Exception("Must call Run() before generating a path DijkstraMapBase");

            if (!this.TargetLocations.Contains(targetLocation))
                throw new Exception("Requested target location not specified by the constructor DijkstraMapBase");

            var result = new List<IGridLocator>();

            var currentLocation = targetLocation;
            var goalLocation = this.SourceLocation;

            // Find the "easiest" route to the goal
            while (!currentLocation.Equals(goalLocation))
            {
                var column = currentLocation.Column;
                var row = currentLocation.Row;

                var north = row - 1 >= 0;
                var south = row + 1 < _height;
                var east = column + 1 < _width;
                var west = column - 1 >= 0;

                var lowestWeight = MAP_MAX_VALUE;
                var lowestWeightLocation = currentLocation;

                if (north && (this.OutputMap[column, row - 1] < lowestWeight))
                {
                    lowestWeightLocation = _locatorCallback(column, row - 1);
                    lowestWeight = this.OutputMap[column, row - 1];
                }

                if (south && (this.OutputMap[column, row + 1] < lowestWeight))
                {
                    lowestWeightLocation = _locatorCallback(column, row + 1);
                    lowestWeight = this.OutputMap[column, row + 1];
                }

                if (east && (this.OutputMap[column + 1, row] < lowestWeight))
                {
                    lowestWeightLocation = _locatorCallback(column + 1, row);
                    lowestWeight = this.OutputMap[column + 1, row];
                }

                if (west && (this.OutputMap[column - 1, row] < lowestWeight))
                {
                    lowestWeightLocation = _locatorCallback(column - 1, row);
                    lowestWeight = this.OutputMap[column - 1, row];
                }

                if (north && east && !this.ObeyCardinalMovement && (this.OutputMap[column + 1, row - 1] < lowestWeight))
                {
                    lowestWeightLocation = _locatorCallback(column + 1, row - 1);
                    lowestWeight = this.OutputMap[column + 1, row - 1];
                }

                if (north && west && !this.ObeyCardinalMovement && (this.OutputMap[column - 1, row - 1] < lowestWeight))
                {
                    lowestWeightLocation = _locatorCallback(column - 1, row - 1);
                    lowestWeight = this.OutputMap[column - 1, row - 1];
                }

                if (south && east && !this.ObeyCardinalMovement && (this.OutputMap[column + 1, row + 1] < lowestWeight))
                {
                    lowestWeightLocation = _locatorCallback(column + 1, row + 1);
                    lowestWeight = this.OutputMap[column + 1, row + 1];
                }

                if (south && west && !this.ObeyCardinalMovement && (this.OutputMap[column - 1, row + 1] < lowestWeight))
                {
                    lowestWeightLocation = _locatorCallback(column - 1, row + 1);
                    lowestWeight = this.OutputMap[column - 1, row + 1];
                }

                if (lowestWeight == double.MaxValue)
                    throw new Exception("Mishandled Dijkstra Map DijkstraMap.GeneratePath()");

                currentLocation = lowestWeightLocation;

                // Add this to the path
                if (!result.Any(location => location.Equals(lowestWeightLocation)) &&
                    !lowestWeightLocation.Equals(this.SourceLocation) &&
                    !lowestWeightLocation.Equals(targetLocation))
                    result.Add(lowestWeightLocation);

                else if (!lowestWeightLocation.Equals(this.SourceLocation) &&
                         !lowestWeightLocation.Equals(targetLocation))
                    throw new Exception("Loop in Dijkstra Map path finding");
            }

            return result;
        }

        // Use to help debug
        protected void OutputCSV(string directory, string filePrefix)
        {
            var inputMap = new float[_width, _height];

            for (int i = 0; i < _width; i++)
            {
                for (int j = 0; j < _height; j++)
                    inputMap[i, j] = _costCallback(i, j);
            }

            OutputCSV(inputMap, Path.Combine(directory, filePrefix + "_input.csv"));
            OutputCSV(this.OutputMap, Path.Combine(directory, filePrefix + "_output.csv"));
        }

        private void OutputCSV(float[,] matrix, string fileName)
        {
            var builder = new StringBuilder();

            // Output by row CSV
            for (int j = 0; j < matrix.GetLength(1); j++)
            {
                for (int i = 0; i < matrix.GetLength(0); i++)
                {
                    if (matrix[i, j] != MAP_MAX_VALUE)
                        builder.Append(matrix[i, j].ToString("F3") + ", ");

                    else
                        builder.Append("MAX, ");
                }

                // Remove trailing comma
                builder.Remove(builder.Length - 1, 1);

                // Append return carriage
                builder.Append("\r\n");
            }

            File.WriteAllText(fileName, builder.ToString());
        }
    }

    public class DijkstraPathGenerator : DijkstraMapBase
    {
        /// <summary>
        /// Callback that allows setting properties of the embedded path cells
        /// </summary>
        public delegate void DijkstraEmbedPathCallback(GridCellInfo pathCell);

        readonly GridCellInfo[,] _grid;

        public DijkstraPathGenerator(GridCellInfo[,] grid, IEnumerable<Region<GridCellInfo>> avoidRegions, GridCellInfo sourceLocation, IEnumerable<GridCellInfo> targetLocations, bool obeyCardinalMovement) 
             : base(grid.GetLength(0), grid.GetLength(1), obeyCardinalMovement, sourceLocation, targetLocations, new DijkstraMapCostCallback((column, row) =>
             {
                 if (avoidRegions.Any(region => region[column, row] != null))
                     return DijkstraMapBase.RegionFeatureConstant;

                 else
                     return 0;

             }), new DijkstraMapLocatorCallback((column, row) =>
             {
                 // ALLOCATE NEW GRID CELLS FOR CREATING NEW PATHS
                 return grid[column, row] ?? new GridCellInfo(column, row);
             }))
        {
            _grid = grid;
        }

        public void EmbedPaths(DijkstraEmbedPathCallback callback)
        {          
            Run();

            // Create paths for each target
            foreach (var targetLocation in this.TargetLocations)
            {                
                foreach (var cell in GeneratePath(targetLocation))
                {
                    // Allow setting properties on cells from the new path
                    callback(cell as GridCellInfo);

                    // Embed the cell
                    _grid[cell.Column, cell.Row] = cell as GridCellInfo;
                }
            }
        }
    }

    public class DijkstraLevelGrid : DijkstraMapBase
    {
        public DijkstraLevelGrid(LayoutGrid grid, IGridLocator sourceLocation, IEnumerable<IGridLocator> targetLocations, bool obeyCardinalMovement)
             : base(grid.Bounds.Width, grid.Bounds.Height, obeyCardinalMovement, sourceLocation, targetLocations, new DijkstraMapCostCallback((column, row) =>
             {
                 if (grid[column, row] == null)
                     return 0;

                 else if (grid[column, row].IsWall)
                     return 0;

                 else
                     return DijkstraMapBase.RegionFeatureConstant;

             }), new DijkstraMapLocatorCallback((column, row) =>
             {
                 throw new NotImplementedException("DijkstraLevelGrid locator callback. Have to prevent iterating out into null cells");
             }))
        {
            Run();
        }
    }
}
