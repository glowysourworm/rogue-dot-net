using Rogue.NET.Common.Extension;
using Rogue.NET.Core.Model.Scenario.Content.Layout;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Rogue.NET.Core.Math.Geometry
{
    /// <summary>
    /// Provides shortest-distance methods based on Dijkstra's Algorithm.
    /// </summary>
    
    // *** TODO:TERRAIN  INTEGRATE THIS WITH THE LEVEL GRID TO PREVENT ALLOCATING MEMORY FOR THE GRID LOCATIONS
    public class DijkstraMap
    {
        /// <summary>
        /// Constant that indictaes a region of the grid - typically used for a mask to prevent iterating
        /// back onto the regions.
        /// </summary>
        public readonly static double RegionFeatureConstant = 10000;

        // Map used to generate a gradient weighting for the algorithm
        double[,] _inputMap;

        // Map generated by the algorithm
        double[,] _outputMap;

        public GridLocation Source { get; private set; }
        public GridLocation Target { get; private set; }

        // Flag to show that algorithm has run
        bool _hasRun;

        /// <summary>
        /// Creates a Dijkstra map with an input gradient of zero
        /// </summary>
        public DijkstraMap(int width, int height, GridLocation source, GridLocation target)
        {
            _inputMap = new double[width, height];
            _outputMap = new double[width, height];
            this.Source = source;
            this.Target = target;
            _hasRun = false;
        }

        /// <summary>
        /// Creates a Dijkstra map with an input gradient defined by the 2D array
        /// </summary>
        public DijkstraMap(double[,] inputMap, GridLocation source, GridLocation target)
        {
            _inputMap = inputMap;
            _outputMap = new double[inputMap.GetLength(0), inputMap.GetLength(1)];
            this.Source = source;
            this.Target = target;
            _hasRun = false;
        }

        // *** TODO:TERRAIN  INTEGRATE THIS WITH THE LEVEL GRID TO PREVENT ALLOCATING MEMORY FOR THE GRID LOCATIONS
        public void Run()
        {
            // Initialize the output map
            for (int i = 0; i < _outputMap.GetLength(0); i++)
            {
                // Set to "infinity" except for the start location
                for (int j = 0; j < _outputMap.GetLength(1); j++)
                    _outputMap[i, j] = ((i == this.Source.Column) && (j == this.Source.Row)) ? 0 : double.MaxValue;
            }

            // Track visited elements AND queued elements (prevents a LOT of extra looking up on the queue)
            var visitedMap = new bool[_inputMap.GetLength(0), _inputMap.GetLength(1)];
            var queueMap = new bool[_inputMap.GetLength(0), _inputMap.GetLength(1)];

            // Use stack to know what elements have been verified. Starting with test element - continue 
            // until all connected elements have been added to the resulting region.
            var queue = new List<GridLocation>(_inputMap.GetLength(0) * _inputMap.GetLength(1));

            // Process the first element
            queue.Add(this.Source);
            queueMap[this.Source.Column, this.Source.Row] = true;

            // NOTE*** Adding a variable weighting for a change in location (SHOULD BE SET TO 1.0)
            var tileMovementCost = 1.0;

            while (queue.Count > 0)
            {
                // Dequeue next node (These have been queued in order)
                var currentLocation = queue.First();

                queue.RemoveAt(0);

                var column = currentLocation.Column;
                var row = currentLocation.Row;
                var currentWeight = _outputMap[column, row];

                // Mark the element as visited
                visitedMap[column, row] = true;

                // Search cardinally adjacent elements (N,S,E,W)
                var north = row - 1 >= 0;
                var south = row + 1 < _inputMap.GetLength(1);
                var east = column + 1 < _inputMap.GetLength(0);
                var west = column - 1 >= 0;

                // Dijkstra Weight = Current Value + ("Change in Location Cost" + "Gradient Cost") 
                //                 = Current Value + (1 + Input Map Change)
                //
                // UPDATE:         Negative gradient "costs" cause problems because they interrupt the
                //                 accumulated weight. Example: Walk-up-and-then-down a mountain. The
                //                 other side of the mountain will subtract off the accumulated cost of
                //                 climbing it.
                //
                // SOLUTION:       Hard-limit the low end of the gradient to always ADD to the total value.
                //
                if (north && !visitedMap[column, row - 1])
                    _outputMap[column, row - 1] = System.Math.Min(_outputMap[column, row - 1], currentWeight + (_inputMap[column, row - 1] - _inputMap[column, row]).LowLimit(0) + tileMovementCost);

                if (south && !visitedMap[column, row + 1])
                    _outputMap[column, row + 1] = System.Math.Min(_outputMap[column, row + 1], currentWeight + (_inputMap[column, row + 1] - _inputMap[column, row]).LowLimit(0) + tileMovementCost);

                if (east && !visitedMap[column + 1, row])
                    _outputMap[column + 1, row] = System.Math.Min(_outputMap[column + 1, row], currentWeight + (_inputMap[column + 1, row] - _inputMap[column, row]).LowLimit(0) + tileMovementCost);

                if (west && !visitedMap[column - 1, row])
                    _outputMap[column - 1, row] = System.Math.Min(_outputMap[column - 1, row], currentWeight + (_inputMap[column - 1, row] - _inputMap[column, row]).LowLimit(0) + tileMovementCost);

                if (north && east && !visitedMap[column + 1, row - 1])
                    _outputMap[column + 1, row - 1] = System.Math.Min(_outputMap[column + 1, row - 1], currentWeight + (_inputMap[column + 1, row - 1] - _inputMap[column, row]).LowLimit(0) + tileMovementCost);

                if (north && west && !visitedMap[column - 1, row - 1])
                    _outputMap[column - 1, row - 1] = System.Math.Min(_outputMap[column - 1, row - 1], currentWeight + (_inputMap[column - 1, row - 1] - _inputMap[column, row]).LowLimit(0) + tileMovementCost);

                if (south && east && !visitedMap[column + 1, row + 1])
                    _outputMap[column + 1, row + 1] = System.Math.Min(_outputMap[column + 1, row + 1], currentWeight + (_inputMap[column + 1, row + 1] - _inputMap[column, row]).LowLimit(0) + tileMovementCost);

                if (south && west && !visitedMap[column - 1, row + 1])
                    _outputMap[column - 1, row + 1] = System.Math.Min(_outputMap[column - 1, row + 1], currentWeight + (_inputMap[column - 1, row + 1] - _inputMap[column, row]).LowLimit(0) + tileMovementCost);

                var nextLocations = new List<GridLocation>();

                // Gather locations to be queued
                if (north && !visitedMap[column, row - 1] && !queueMap[column, row - 1])
                {
                    nextLocations.Add(new GridLocation(column, row - 1));
                    queueMap[column, row - 1] = true;
                }

                if (south && !visitedMap[column, row + 1] && !queueMap[column, row + 1])
                {
                    nextLocations.Add(new GridLocation(column, row + 1));
                    queueMap[column, row + 1] = true;
                }

                if (east && !visitedMap[column + 1, row] && !queueMap[column + 1, row])
                {
                    nextLocations.Add(new GridLocation(column + 1, row));
                    queueMap[column + 1, row] = true;
                }

                if (west && !visitedMap[column - 1, row] && !queueMap[column - 1, row])
                {
                    nextLocations.Add(new GridLocation(column - 1, row));
                    queueMap[column - 1, row] = true;
                }

                if (north && east && !visitedMap[column + 1, row - 1] && !queueMap[column + 1, row - 1])
                {
                    nextLocations.Add(new GridLocation(column + 1, row - 1));
                    queueMap[column + 1, row - 1] = true;
                }

                if (north && west && !visitedMap[column - 1, row - 1] && !queueMap[column - 1, row - 1])
                {
                    nextLocations.Add(new GridLocation(column - 1, row - 1));
                    queueMap[column - 1, row - 1] = true;
                }

                if (south && east && !visitedMap[column + 1, row + 1] && !queueMap[column + 1, row + 1])
                {
                    nextLocations.Add(new GridLocation(column + 1, row + 1));
                    queueMap[column + 1, row + 1] = true;
                }

                if (south && west && !visitedMap[column - 1, row + 1] && !queueMap[column - 1, row + 1])
                {
                    nextLocations.Add(new GridLocation(column - 1, row + 1));
                    queueMap[column - 1, row + 1] = true;
                }

                if (nextLocations.Count == 0)
                    continue;

                // (REQUIRED) QUEUE THEM IN ORDER OF LOWEST COST
                var orderedLocations = nextLocations.OrderBy(x => _outputMap[x.Column, x.Row]).ToList();

                var queueIndex = 0;
                var nextLocationsIndex = 0;

                // **Both the queue and nextLocations are ordered. So, just insert in order
                //   during iteration.
                while (nextLocationsIndex < orderedLocations.Count)
                {
                    var location = orderedLocations[nextLocationsIndex];
                    var found = false;

                    for (int k = queueIndex; k < queue.Count && !found; k++)
                    {
                        if (_outputMap[queue[k].Column, queue[k].Row] > _outputMap[location.Column, location.Row])
                        {
                            found = true;
                            queue.Insert(k, location);

                            // Increment the queue index to save time on iteration
                            queueIndex = k;
                        }
                    }

                    // If no insert point found - then just add it to the end
                    if (!found)
                        queue.Add(location);

                    nextLocationsIndex++;
                }

                // NOTE*** TERMINATE LOOP IF DESTINATION IS REACHED
                //
                //         This will leave the path well formed - with infinities outside
                //         of the visited nodes
                //
                // UPDATE: TERMINTING THIS EARLY MAY CAUSE MIS-CALCULATION BECAUSE
                //         MULTIPLE PATHS WILL HAVE DIFFERENT COSTS - SO THE FIRST
                //         PATH MAY NOT BE THE CHEAPEST.
                //
                //if (currentLocation.Equals(endLocation))
                //    return dijkstraMap;
            }

            _hasRun = true;
        }

        // *** TODO:TERRAIN  INTEGRATE THIS WITH THE LEVEL GRID TO PREVENT ALLOCATING MEMORY FOR THE GRID LOCATIONS
        public IEnumerable<GridLocation> GeneratePath(bool obeyCardinalMovement)
        {
            if (!_hasRun)
                throw new Exception("Must call Run() before generating a path DijkstraMap");

            var result = new List<GridLocation>();

            var currentLocation = this.Target;
            var goalLocation = this.Source;

            // Find the "easiest" route to the goal
            while (!currentLocation.Equals(goalLocation))
            {
                var column = currentLocation.Column;
                var row = currentLocation.Row;

                var north = row - 1 >= 0;
                var south = row + 1 < _outputMap.GetLength(1);
                var east = column + 1 < _outputMap.GetLength(0);
                var west = column - 1 >= 0;

                double lowestWeight = double.MaxValue;
                GridLocation lowestWeightLocation = currentLocation;

                if (north && (_outputMap[column, row - 1] < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column, row - 1);
                    lowestWeight = _outputMap[column, row - 1];
                }

                if (south && (_outputMap[column, row + 1] < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column, row + 1);
                    lowestWeight = _outputMap[column, row + 1];
                }

                if (east && (_outputMap[column + 1, row] < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column + 1, row);
                    lowestWeight = _outputMap[column + 1, row];
                }

                if (west && (_outputMap[column - 1, row] < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column - 1, row);
                    lowestWeight = _outputMap[column - 1, row];
                }

                if (north && east && !obeyCardinalMovement && (_outputMap[column + 1, row - 1] < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column + 1, row - 1);
                    lowestWeight = _outputMap[column + 1, row - 1];
                }

                if (north && west && !obeyCardinalMovement && (_outputMap[column - 1, row - 1] < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column - 1, row - 1);
                    lowestWeight = _outputMap[column - 1, row - 1];
                }

                if (south && east && !obeyCardinalMovement && (_outputMap[column + 1, row + 1] < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column + 1, row + 1);
                    lowestWeight = _outputMap[column + 1, row + 1];
                }

                if (south && west && !obeyCardinalMovement && (_outputMap[column - 1, row + 1] < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column - 1, row + 1);
                    lowestWeight = _outputMap[column - 1, row + 1];
                }

                if (lowestWeight == double.MaxValue)
                    throw new Exception("Mishandled Dijkstra Map LayoutGenerator.CreateOrganic");

                currentLocation = lowestWeightLocation;

                // Remove Wall from this cell (TODO:TERRAIN REMOVE THIS)
                if (!result.Any(location => location.Equals(lowestWeightLocation)))
                    result.Add(lowestWeightLocation);

                else
                    throw new Exception("Loop in Dijkstra Map path finding");
                // return result;

                // For diagonal movements - must also set one of the corresponding cardinal cells to be part of the corridor
                if (obeyCardinalMovement)
                    continue;

                // NE
                if ((lowestWeightLocation.Column == column + 1) && (lowestWeightLocation.Row == row - 1))
                {
                    // Select the N or E cell to also add to the path
                    if (_outputMap[column, row - 1] < _outputMap[column + 1, row])
                        result.Add(new GridLocation(column, row - 1));

                    else
                        result.Add(new GridLocation(column + 1, row));
                }
                // NW
                else if ((lowestWeightLocation.Column == column - 1) && (lowestWeightLocation.Row == row - 1))
                {
                    // Select the N or W cell to also add to the path
                    if (_outputMap[column, row - 1] < _outputMap[column - 1, row])
                        result.Add(new GridLocation(column, row - 1));

                    else
                        result.Add(new GridLocation(column - 1, row));
                }
                // SE
                else if ((lowestWeightLocation.Column == column + 1) && (lowestWeightLocation.Row == row + 1))
                {
                    // Select the S or E cell to also add to the path
                    if (_outputMap[column, row + 1] < _outputMap[column + 1, row])
                        result.Add(new GridLocation(column, row + 1));

                    else
                        result.Add(new GridLocation(column + 1, row));
                }
                // SW
                else if ((lowestWeightLocation.Column == column - 1) && (lowestWeightLocation.Row == row + 1))
                {
                    // Select the S or W cell to also add to the path
                    if (_outputMap[column, row + 1] < _outputMap[column - 1, row])
                        result.Add(new GridLocation(column, row + 1));

                    else
                        result.Add(new GridLocation(column - 1, row));
                }
            }

            return result;
        }

        // Use to help debug
        private void OutputCSV(double[,] matrix, string fileName)
        {
            var builder = new StringBuilder();

            // Output by row CSV
            for (int j = 0; j < matrix.GetLength(1); j++)
            {
                for (int i = 0; i < matrix.GetLength(0); i++)
                    builder.Append(matrix[i, j] + ", ");

                // Remove trailing comma
                builder.Remove(builder.Length - 1, 1);

                // Append return carriage
                builder.Append("\r\n");
            }

            File.WriteAllText(fileName, builder.ToString());
        }
    }
}
