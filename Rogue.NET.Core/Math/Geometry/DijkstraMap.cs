using Rogue.NET.Core.Model.Scenario.Content.Layout;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace Rogue.NET.Core.Math.Geometry
{
    /// <summary>
    /// Provides shortest-distance methods based on Dijkstra's Algorithm.
    /// </summary>

    // *** TODO:TERRAIN  INTEGRATE THIS WITH THE LEVEL GRID TO PREVENT ALLOCATING MEMORY FOR THE GRID LOCATIONS
    public class DijkstraMap
    {
        /// <summary>
        /// Constant that indictaes a region of the grid - typically used for a mask to prevent iterating
        /// back onto the regions.
        /// </summary>
        public readonly static double RegionFeatureConstant = 10000;

        readonly GridLocation _sourceLocation;
        readonly GridLocation _targetLocation;

        const double CELL_MOVEMENT_COST = 1.0;

        // Map used to generate a cost weighting for the algorithm
        double[,] _inputMap;

        // Map generated by the algorithm
        DijkstraMapNode[,] _outputMap;

        // Flag to show that algorithm has run
        bool _hasRun;

        // Flag to denote cardinal movements only
        bool _obeyCardinalMovement;

        #region (protected) Nested Node Class
        protected class DijkstraMapNode : IComparer<DijkstraMapNode>, IComparable<DijkstraMapNode>
        {
            public int Column { get; private set; }
            public int Row { get; private set; }
            public double Weight { get; set; }

            public DijkstraMapNode(int column, int row, double weight)
            {
                this.Column = column;
                this.Row = row;
                this.Weight = weight;
            }

            public int Compare(DijkstraMapNode x, DijkstraMapNode y)
            {
                var comparison = x.Weight.CompareTo(y.Weight);

                // Default comparison to hash code
                if (comparison == 0)
                    return x.GetHashCode().CompareTo(y.GetHashCode());

                else
                    return comparison;
            }

            public int CompareTo(DijkstraMapNode other)
            {
                return Compare(this, other);
            }

            public override bool Equals(object obj)
            {
                if (obj is DijkstraMapNode)
                {
                    var node = (DijkstraMapNode)obj;

                    return node.Column == this.Column &&
                           node.Row == this.Row &&
                           node.Weight == this.Weight;
                }
                else
                    return false;
            }

            public override int GetHashCode()
            {
                return base.GetHashCode();
            }

            public override string ToString()
            {
                return string.Format("[ Column = {0}, Row = {1}, Weight = {2} ]", this.Column, this.Row, this.Weight); 
            }
        }
        #endregion

        /// <summary>
        /// Creates a Dijkstra map with an input cost map of zero
        /// </summary>
        public DijkstraMap(int width, int height, GridLocation source, GridLocation target, bool obeyCardinalMovement)
        {
            _inputMap = new double[width, height];
            _outputMap = new DijkstraMapNode[width, height];
            _sourceLocation = source;
            _targetLocation = target;
            _hasRun = false;
            _obeyCardinalMovement = obeyCardinalMovement;
        }

        /// <summary>
        /// Creates a Dijkstra map with an input gradient defined by the 2D array
        /// </summary>
        public DijkstraMap(double[,] inputMap, GridLocation source, GridLocation target, bool obeyCardinalMovement)
        {
            _inputMap = inputMap;
            _outputMap = new DijkstraMapNode[inputMap.GetLength(0), inputMap.GetLength(1)];
            _sourceLocation = source;
            _targetLocation = target;
            _hasRun = false;
            _obeyCardinalMovement = obeyCardinalMovement;
        }

        public bool Run()
        {
            // Initialize the output map
            for (int i = 0; i < _outputMap.GetLength(0); i++)
            {
                // Set to "infinity" except for the start location
                for (int j = 0; j < _outputMap.GetLength(1); j++)
                {
                    _outputMap[i, j] = new DijkstraMapNode(i, j, ((i == _sourceLocation.Column) && (j == _sourceLocation.Row)) ? 0 : double.MaxValue);
                }
            }

            // Track visited elements AND queued elements (prevents a LOT of extra looking up on the queue)
            var visitedMap = new bool[_inputMap.GetLength(0), _inputMap.GetLength(1)];

            // TODO:TERRAIN - USE GRID TO PREVENT ALLOCATING MORE GRID LOCATIONS
            // Track the frontier cells to check lowest cost next step
            var frontier = new SortedList<DijkstraMapNode, DijkstraMapNode>();
            var frontierMap = new bool[_inputMap.GetLength(0), _inputMap.GetLength(1)];

            // Process the first element
            var column = _sourceLocation.Column;
            var row = _sourceLocation.Row;

            // Iterate while target not reached (AND) not visited (AND) next location found
            while (!(column == _targetLocation.Column &&
                     row == _targetLocation.Row) &&
                    !visitedMap[column, row])
            {
                // Set current parameters
                var currentWeight = _outputMap[column, row].Weight;

                // Mark the element as visited
                visitedMap[column, row] = true;

                // Search cardinally adjacent elements (N,S,E,W)
                var north = row - 1 >= 0;
                var south = row + 1 < _inputMap.GetLength(1);
                var east = column + 1 < _inputMap.GetLength(0);
                var west = column - 1 >= 0;

                // Dijkstra Weight = Current Value + ("Change in Location Cost" + "Input Map Cost") 
                //
                // PROBLEM:         Negative gradient "costs" cause problems because they interrupt the
                //                 accumulated weight. Example: Walk-up-and-then-down a mountain. The
                //                 other side of the mountain will subtract off the accumulated cost of
                //                 climbing it.
                //
                // SOLUTION:       Use "Cost Map" instead of "Gradient Map"
                //

                // CARDINAL LOCATIONS
                if (north && !visitedMap[column, row - 1])
                {
                    // Update the output map
                    _outputMap[column, row - 1].Weight = System.Math.Min(_outputMap[column, row - 1].Weight, currentWeight + _inputMap[column, row - 1] + CELL_MOVEMENT_COST);

                    // Update the frontier (Force update of the sorted list)
                    if (frontier.ContainsKey(_outputMap[column, row - 1]))
                        frontier.Remove(_outputMap[column, row - 1]);

                    frontier.Add(_outputMap[column, row - 1], _outputMap[column, row - 1]);
                }

                if (south && !visitedMap[column, row + 1])
                {
                    _outputMap[column, row + 1].Weight = System.Math.Min(_outputMap[column, row + 1].Weight, currentWeight + _inputMap[column, row + 1] + CELL_MOVEMENT_COST);

                    // Update the frontier (Force update of the sorted list)
                    if (frontier.ContainsKey(_outputMap[column, row + 1]))
                        frontier.Remove(_outputMap[column, row + 1]);

                    frontier.Add(_outputMap[column, row + 1], _outputMap[column, row + 1]);
                }

                if (east && !visitedMap[column + 1, row])
                {
                    _outputMap[column + 1, row].Weight = System.Math.Min(_outputMap[column + 1, row].Weight, currentWeight + _inputMap[column + 1, row] + CELL_MOVEMENT_COST);

                    // Update the frontier (Force update of the sorted list)
                    if (frontier.ContainsKey(_outputMap[column + 1, row]))
                        frontier.Remove(_outputMap[column + 1, row]);

                    frontier.Add(_outputMap[column + 1, row], _outputMap[column + 1, row]);
                }

                if (west && !visitedMap[column - 1, row])
                {
                    _outputMap[column - 1, row].Weight = System.Math.Min(_outputMap[column - 1, row].Weight, currentWeight + _inputMap[column - 1, row] + CELL_MOVEMENT_COST);

                    // Update the frontier (Force update of the sorted list)
                    if (frontier.ContainsKey(_outputMap[column - 1, row]))
                        frontier.Remove(_outputMap[column - 1, row]);

                    frontier.Add(_outputMap[column - 1, row], _outputMap[column - 1, row]);
                }

                // NON-CARDINAL LOCATIONS
                if (!_obeyCardinalMovement && north && east && !visitedMap[column + 1, row - 1])
                {
                    _outputMap[column + 1, row - 1].Weight = System.Math.Min(_outputMap[column + 1, row - 1].Weight, currentWeight + _inputMap[column + 1, row - 1] + CELL_MOVEMENT_COST);

                    // Update the frontier (Force update of the sorted list)
                    if (frontier.ContainsKey(_outputMap[column + 1, row - 1]))
                        frontier.Remove(_outputMap[column + 1, row - 1]);

                    frontier.Add(_outputMap[column + 1, row - 1], _outputMap[column + 1, row - 1]);
                }

                if (!_obeyCardinalMovement && north && west && !visitedMap[column - 1, row - 1])
                {
                    _outputMap[column - 1, row - 1].Weight = System.Math.Min(_outputMap[column - 1, row - 1].Weight, currentWeight + _inputMap[column - 1, row - 1] + CELL_MOVEMENT_COST);

                    // Update the frontier (Force update of the sorted list)
                    if (frontier.ContainsKey(_outputMap[column - 1, row - 1]))
                        frontier.Remove(_outputMap[column - 1, row - 1]);

                    frontier.Add(_outputMap[column - 1, row - 1], _outputMap[column - 1, row - 1]);
                }

                if (!_obeyCardinalMovement && south && east && !visitedMap[column + 1, row + 1])
                {
                    _outputMap[column + 1, row + 1].Weight = System.Math.Min(_outputMap[column + 1, row + 1].Weight, currentWeight + _inputMap[column + 1, row + 1] + CELL_MOVEMENT_COST);

                    // Update the frontier (Force update of the sorted list)
                    if (frontier.ContainsKey(_outputMap[column + 1, row + 1]))
                        frontier.Remove(_outputMap[column + 1, row + 1]);

                    frontier.Add(_outputMap[column + 1, row + 1], _outputMap[column + 1, row + 1]);
                }

                if (!_obeyCardinalMovement && south && west && !visitedMap[column - 1, row + 1])
                {
                    _outputMap[column - 1, row + 1].Weight = System.Math.Min(_outputMap[column - 1, row + 1].Weight, currentWeight + _inputMap[column - 1, row + 1] + CELL_MOVEMENT_COST);

                    // Update the frontier (Force update of the sorted list)
                    if (frontier.ContainsKey(_outputMap[column - 1, row + 1]))
                        frontier.Remove(_outputMap[column - 1, row + 1]);

                    frontier.Add(_outputMap[column - 1, row + 1], _outputMap[column - 1, row + 1]);
                }

                // Select next location from frontier queue - using the smallest weight
                if (frontier.Count > 0)
                {
                    var nextNode = frontier.First().Key;

                    column = nextNode.Column;
                    row = nextNode.Row;

                    frontier.RemoveAt(0);
                }
            }

            _hasRun = true;

            // Return true if target location found
            return column == _targetLocation.Column &&
                   row == _targetLocation.Row;
        }

        // *** TODO:TERRAIN  INTEGRATE THIS WITH THE LEVEL GRID TO PREVENT ALLOCATING MEMORY FOR THE GRID LOCATIONS
        public IEnumerable<GridLocation> GeneratePath()
        {
            if (!_hasRun)
                throw new Exception("Must call Run() before generating a path DijkstraMap");

            var result = new List<GridLocation>();

            var currentLocation = _targetLocation;
            var goalLocation = _sourceLocation;

            // Find the "easiest" route to the goal
            while (!currentLocation.Equals(goalLocation))
            {
                var column = currentLocation.Column;
                var row = currentLocation.Row;

                var north = row - 1 >= 0;
                var south = row + 1 < _outputMap.GetLength(1);
                var east = column + 1 < _outputMap.GetLength(0);
                var west = column - 1 >= 0;

                double lowestWeight = double.MaxValue;
                GridLocation lowestWeightLocation = currentLocation;

                if (north && (_outputMap[column, row - 1].Weight < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column, row - 1);
                    lowestWeight = _outputMap[column, row - 1].Weight;
                }

                if (south && (_outputMap[column, row + 1].Weight < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column, row + 1);
                    lowestWeight = _outputMap[column, row + 1].Weight;
                }

                if (east && (_outputMap[column + 1, row].Weight < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column + 1, row);
                    lowestWeight = _outputMap[column + 1, row].Weight;
                }

                if (west && (_outputMap[column - 1, row].Weight < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column - 1, row);
                    lowestWeight = _outputMap[column - 1, row].Weight;
                }

                if (north && east && !_obeyCardinalMovement && (_outputMap[column + 1, row - 1].Weight < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column + 1, row - 1);
                    lowestWeight = _outputMap[column + 1, row - 1].Weight;
                }

                if (north && west && !_obeyCardinalMovement && (_outputMap[column - 1, row - 1].Weight < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column - 1, row - 1);
                    lowestWeight = _outputMap[column - 1, row - 1].Weight;
                }

                if (south && east && !_obeyCardinalMovement && (_outputMap[column + 1, row + 1].Weight < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column + 1, row + 1);
                    lowestWeight = _outputMap[column + 1, row + 1].Weight;
                }

                if (south && west && !_obeyCardinalMovement && (_outputMap[column - 1, row + 1].Weight < lowestWeight))
                {
                    lowestWeightLocation = new GridLocation(column - 1, row + 1);
                    lowestWeight = _outputMap[column - 1, row + 1].Weight;
                }

                if (lowestWeight == double.MaxValue)
                    throw new Exception("Mishandled Dijkstra Map DijkstraMap.GeneratePath()");

                currentLocation = lowestWeightLocation;

                // Remove Wall from this cell (TODO:TERRAIN REMOVE THIS)
                if (!result.Any(location => location.Equals(lowestWeightLocation)))
                    result.Add(lowestWeightLocation);

                else
                    throw new Exception("Loop in Dijkstra Map path finding");
            }

            return result;
        }

        // Use to help debug
        public void OutputCSV(string directory, string filePrefix)
        {
            var outputMap = new double[_outputMap.GetLength(0), _outputMap.GetLength(1)];

            for (int i=0;i<outputMap.GetLength(0);i++)
            {
                for (int j = 0; j < outputMap.GetLength(1); j++)
                    outputMap[i, j] = _outputMap[i, j].Weight;
            }

            OutputCSV(_inputMap, Path.Combine(directory, filePrefix + "_input.csv"));
            OutputCSV(outputMap, Path.Combine(directory, filePrefix + "_output.csv"));
        }

        private void OutputCSV(double[,] matrix, string fileName)
        {
            var builder = new StringBuilder();

            // Output by row CSV
            for (int j = 0; j < matrix.GetLength(1); j++)
            {
                for (int i = 0; i < matrix.GetLength(0); i++)
                {
                    if (matrix[i, j] != double.MaxValue)
                        builder.Append(matrix[i, j].ToString("F3") + ", ");

                    else
                        builder.Append("MAX, ");
                }

                // Remove trailing comma
                builder.Remove(builder.Length - 1, 1);

                // Append return carriage
                builder.Append("\r\n");
            }

            File.WriteAllText(fileName, builder.ToString());
        }
    }
}
