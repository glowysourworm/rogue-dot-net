- Outro Display (I Won! - Here's my stats!) (STATS TBD)
- Statistics Display (High Scores) (TBD)
- Reveal Image Transparency (TBD)
- HINTS (TBD)
- Layout Descriptions (To lend narrative to the story... "Evil Approaches..." .. "These are the blah blah blah of the evil blah blah blah"
- Categorize: Skills / Spells; Equipment; Consumables; Animations (TBD)

(BIG TBD's)
- Player Action: Can choose to block physical (strength based), or magical (intelligence based), or maybe even to "run away" by
- 				 granting you an extra portion of a turn. This would be instead of just attacking. (TBD)

- Several Validation Points: 
	- Scenario Editor: Dungeon Template Name - UNIQUE and SET and NO FILE-NON-FRIENDLY CHARACTERS
	- Scenario: Player Name SET and UNIQUE and NO FILE-NON-FRIENDLY CHARACTERS
	- Scenario Files: Player Name + Scenario Name.. or put something in the header to show the scenario name also
- Scenario Editor: Fix up the Symbol Alteration logic for the UI. have to represent it properly for flags set.
- Dungeon Wide Events:  Alteration or note-bearing event that fires at random; or once during a specific level range. 
						- Example:  "Corruption" Adds to your player's "Corruption" level every 10,000 steps.. ish
						- Example:  "Turn back while you still can!" (from the big enemy of the scenario) (creates monster)
						- Example:  "Send player back to stairs up" :)  after X number of steps (pretty mean!)
						
- Boost Bar:  An extra boost to alterations or attack. This could be filled: On Step; On Enemy Death; On Attack. So, player 
			  can choose when to use their boost bar to add to the attack.			 

- Alteration:  Teleport within visible range or within range of X or something where enemies teleport near to the player's visible range

- Multi-Level Teleportation: Coordinated using multi-level layouts
- Tertiary Behavior

- Balancing (Paladin) - Add "teleport near (within attack range)" to Hell Hound (TBD)
- Balancing (Paladin) - Add "teleport adjacent" to teleport options (TBD)

- Layout Refactoring:

	- Goals:  Support for:
				- Random Room layouts
				- Intersecting rooms 
				- Maze rooms
				- Room inside a rooms
				- Boss levels (symmetric / static-ish layouts)
				- Hidden pathways: either hidden hallways randomly; hidden paths off the grid; or hidden paths between rooms
				- multiple halls between rooms
				- Big rooms specified by a clickable grid of rooms (specify which rooms are "grouped" in the room grid)
				- Add teleporters to any layout type
				- Points of interest (allows placing objective or unique content on those points)
				- Symmetric layouts
				- Specific shapes for layouts (pentagram, square thing, etc..)
				- Challenge levels (alternate stairwell for a challenge level)
				- Room levels without doors
				- Cell Fill color
				- Linear layouts v.s. non-linear (linear => start to end without options)
				- temporary walls (can demolish by walking through)
				- Switches and push blocks! (would use to open a door or let down a wall.. YEAh!)
				- Cellular Automata (with connected rooms with parameterized hallway thickness)
				- Room "Growing" - Start with a room, create a door or hall with random length. Then iterate to create the next room
				  or rooms (maybe 2 or 3)
				  
				- "Antfarm" procedure that uses random hall splitting (recursive)
				- Identify 'main room' or "first" and "last" rooms. Create connected rooms by showing they're connected to a single room
				  via some other room. First and Last rooms may have the stairwells.. So, could generate sequential "problem" set by having
				  conditions for advancement (beat a monster, find a key, etc..)
				- Monster generation per level (parameter) also, party room parameter
				
				- POINTS OF INTEREST:  Doodads are important to scenarios. Having special points of interest can make it possible to arrange
									   content to suggest a narrative - which is what Rogue.NET is supposed to be about.
									   
									   Idea:  Have points along the wall designated as POIs. 
									   
									   Idea:  Have points near an entrance (on each side) designated as POIs. (Idea from Brogue Dar Blademasters)
									   
				- Level Tree:  Have the level generation be a tree to support probabilistically generated branches of the scenario. 
				
							   Idea: Could randomly choose a stairs down image to help make it more difficult for people to know where to go.
							   
							   Idea: Could have stairs-up be sealed off.. but would have to reconnect to the primary branch at some point.
				
- Windows: Would treat like an open door that you can't pass through.. (But maybe could break)
				
- Zones:   Related to level layouts. 

		   - Idea: This would combine level content and layout generation
		   
		   - Goal: To separate the layout into "Zones" that are sequential. Each would have an "Exit Condition"
		   
				   - Step on a switch
				   - Defeat (All, Some, One of "These") enemies
				   - Collect Content
				   - Find a key

		   - Design Problem:  Have to build a layout based on a sequence of zones
		   
				   - ISSUE: CAN'T PERMIT "PITFALL" TYPE EFFECTS BECAUSE THEY BREAK SEQUENCE
				   - Can only allow linear progress through zones. CAN GO BACKWARD (RANDOM LEVEL UP) BUT NOT FORWARD (RANDOM LEVEL DOWN or PITFALL)
		   
		   - Idea: Description of zone problem built into scenario level zone template. 
		   
				   - Describes what to do for exit condition ALONG WITH story-line!
				   
					 GREAT. IDEA.
					 
					 Would allow for something like: "You're in King William's prison in the castle in Britain. You must find a 
													  way out of your cell.. Perhaps there's a secret passage nearby..."
													  
													  for the Level 1 template for zone 1! VERY. COOL.
													  
				   - This would give a LOT of power to the scenario by not only allowing for progressive rewards; but also accrued
					 descriptive - and totally configurable - storyline! :) :) VERY. VERY. GOOD.
					 
		   - Idea: Have a "Check Mark" box to show completion of objective(s) for current Level->Zone.
		   
		   - Side Objectives:  
		   
				   - These would be configured on the Zone object to allow the player to find some kind of other hidden
					 room, passage, etc... But essentially use the same engine to create the objective that would be used
					 for linear progression.
					 
						- Examples:  Switched door, hidden passage, keyed door, hidden cache (treasure chest), hidden room, etc...
						
				   - These would be optional so don't require explanation (text)
				
		   - Exit Conditions:  HAVE TO BE ABLE TO GO BACKWARDS.
		   
				   - Switch:  Two state doodad, Riddle Doodad, Temporary event, Weighted doodad
				   
						- Two State Doodad:  ON or OFF - icon for each state
						- Riddle Doodad:     Set the dials on the doodad to create a word to solve the riddle
						- Weighted Doodad:   Stepping on this triggers a "Zone Event" - which may be a timed event
											 
											 Idea:  Could use weight of items to weigh down the switch. So, would need
													weight parameter. Problem with overlapping weight of enemy, or flying enemy, etc...
													
											 Idea:  Push, Pull a block to set on the switch.
											 
											 Idea:  Create a push / pull block problem to solve (like seen in many games) to advance
													to the next zone.
													
										     Idea:  Have switches that you must UN-weight in order to open the door (Example: pedestal)
													
				   - Defeat Enemy(ies):  Have to defeat a speific, all, or one of ____ enemies to advance
				   - Collect Item(s):    Have to collect specific items to advance

									     Idea:  Create special item room with a "pedestal" or point of interest for an item.
										 
										 Idea:  Create item "room" with points of interest.. (something similar)
										 
				   - Collect Key:   Hide the key somewhere to collect. 
				   
									- Generate in enemy inventory (MANDATORY)
									- Generate in level (MANDATORY)
									- Generate in treasure chest cache (MANDATORY)
									- Generate in special item room (MANDATORY)
									
		   - Reversable:  MUST BE ABLE TO GO BACKWARDS
		   
						  - For switched doors, have to have a switch on the other side (INCLUDES SIDE OBJECTIVES)
						  - For content related doors (enemies, items) have to leave the door open
						  
				  
				
- Recipes: New consumable type that blends other misc consumables to create a new one

- Animation refactoring:  Support for...

		- RANDOM SEED EACH ANIMATION (NO REPEATS!)

		- Fading Chain (chain lightning)
		- Earthquake! (shaking screen)
		- "Jumps" (Character jumps .. like a prelude to an "Earthquake" skill or something)
		- Other shapes (square, rectangle, some, other, enumerated, types)
		- Easing functions (Normal easing, plus things like "Pause and go" that make it come alive!)
		- More interesting animations (ease out, come back, etc...)
		- Better language to describe more complex animations
		- Slow animation speeds relative to animation time
		- Criss Cross animation
		- Tracers!
		- Spiral inward
		- Lightning
		- Screen Shaking
		- Gas Animation (Something like burning flames.. figure out how to "diffuse" them upward)
		- Gaseous Projectile - Diffuse Bubbles while travelling / Also Goo (maybe have a weight parameter)
		- "Dim the Lights" (Turns down screen brightness during animation)
		- Explosion Animation - Something like a "half dome" over a character
		- "Hold End" Parameter
		
- Water:  Player has a "Water Meter". Standing water could be a doodad to replenish your supply. Would need alterations to
		  support water replenishment.
		  
		  Also, have skills that depend on water. (use water to cast a spell, etc..)
		
- Alteration Effect: Push Back Enemies ("X" number of spaces).. Possibly on a "Wave" with animations (but that's tricky)

- Teleportation:  Add a standard animation for teleporting that shows the trajectory of the path to the new location.						

- Character classes:  Add class selection and set for equipment. Provide choice at the beginning of class.
					 (Defined in Scenario): Example: Elf, Dwarf, Employee, Wizard, Worlock, etc... These would
					 have equipment trade-offs, combat implications, and attribute bonuses.
					 
					 Equipment: Have different patameter sets per class. OR just a flag to say "Out of class" or "In class"
								to make it simpler.
								
					 Idea:  Chose race (elf, golem, etc...); chose attack attribute bonus to start with. Race could make you 
					 immune to certain altered states.					

					 Also, could spend points at start instead of being assigned attribute values. So, need more intelligence,
					 and agility combat consequences.

				     Altered States:  Certain classes are immune from certain states. Example: Stone Golem immune from stone..

					 Enemy Classes:   Could support combat adjustment from interacting character classes. Example:  Stone Golem
									  has a multiplier v.s. Wizard and Worlock classes. Or, a "Miss Ratio" multiplier.. But these
									  would be set up in the Scenario Editor.. 

									  Setup:  Character Class "Elf": (contains) ClassAttribute, List<ClassAttributeMelee>
											  
											  ClassAttribute:  Any Player Stat (Strength, Agility, ..., Attack, Defense, Miss Ratio, Dodge, Critical Hit, etc...)
															   with a bonus. This would show up as a Passive Alteration. The effect could be positive or negative.

											  ClassAttributeChange = ClassAttribute (modification) + EnemyClassName

														       The effect of this would be to modify the player's stat (determined by the ClassAttribute)
															   during Melee combat ONLY.

															   WOULD REALLY WANT TO SHOW PEOPLE WHAT WAS HAPPENING HERE. So, extra combat messages are 
															   preferred to show.

															   Example:  "Stone Golem" is immune to Altered State = "Stone". His class attribute is
																	     + 0.3 for Critical Hit.

																		 Against Wizard:		    Class Attribute = -5 Intelligence
																		 Against Elf:			    Class Attribute = -3 Agility
																		 Against Water Elemental:   Class Attribute = -10 Defense
									
																	     Message (Water Elemental):  Leviathan attacked Ryan
																									 HP = 43 + Attack Attributes...
																									 Bonus attack for Water Elemental = 32

					 
- Weapons "Gain Experience" from defeating enemies. So, they would "grow" with your character. 

- Weapons can have an Attack Alteration that will heal the player when attacking an enemy. This would likely be
  a new / separate / weapons only alteration applied immediately. Could include animations; but they would be applied
  after the alteration effects due to problems forwarding an attack alteration to the ISpellEngine.

- Enemy Alteration Effect on being hit: Example: "Jelly" divides into two when hit.

- Enemy "Alteration": Riddle.... Example: The riddle of the sphinx. Alteration Effect applied if answered incorrectly (?) or correctly(?)
				
					  OR!  Just a riddle from a doodad - have one incorrect and one correct answer.
					  
					  So, would want to support RIDDLES!!!
					  
- Add - Electricity symbols.. things for lightning!

- ISSUE - Have to use engage radius as enemy "light radius". PROBLEM: HAVE TO FIX PERFORMANCE ISSUE OF MULTIPLE LIGHT RADII USING
		  WPF OPACITY MASKS. PLANNING TO TRY PAINTING ALL TO A SINGLE BITMAP AND THEN APPLYING THE OPACITY MASK ONCE.
						  
-  Add - "Scenario Oracle" - just an endless identify doodad at the end of each scenario to show the total % complete in the stats.
							 (OR) Just identify everything the player has found.
						  
- (TBD) Fade-in for opening animation; and on opening level (Also fade out when player death)					

- Icon sets: This is for randomizing item glyphs. So, probably apply to just items; but support List<SymbolDetails> for the template ONLY.

			 - Design Problem:  How to pick a random symbol from the set but keep it consistent for the rest of the scenario.
			 
- Player Stat:  Miss Ratio - BASED ON AGILITY and Equipment "Out of Class" flag. 
				
				Idea:   This stat would be factored in during combat. It would also be available for alterations
				
				Class:  Flag for equipment saying "Out of class" means that the item isn't meant to be used for that 
						character (bigger idea was class selection .. but it's not part of the game yet)
						
						So, this flag says whether or not the player has trouble wielding the weapon or piece of equipment.
						
				Effect: A simple melee calculation adjustment to factor in Miss Ratio (or Miss %).
				
				Idea:   Need way to communicate this to the user. Either we have a class specification for the player 
						on startup; and use this to specify all equipment classes.. 
						
						Example:  Scenario classes:  "Heavy Fighter", "Ranger", "Archer", "Pyro Ranger", etc...
						
								  Equipment "Fire Axe":  In Class for "Pyro Ranger", "Heavy Fighter", but Out of class for
														 "Archer", and "Ranger".
														 
								  Message to Fighter -> Ranger (class):  Equipped "Fire Axe", "Miss Ratio" Stat altered by -0.2
								  
						Simple Example:  NO Extra Classes
						
										 Equipment "Wizard Staff": Marked "Out of class" for the Fighter. So Miss Ratio altered by -0.3
								  
- Equip Messages:  Show stat changes when equipping.								  

- Player Stat Points:  AT THE BEGINNING - ALLOW USER TO SETUP PLAYER STATS USING POINT SYSTEM.

- WPF RENDER REFACTORING:  PERFORMANCE IS A PROBLEM. WANT TO TRY DRAWING THE PATH DATA TO A BITMAP BEFORE RENDERING TO TRY AND 
						   SPEED UP PERFORMANCE. IF IT WORKS - THEN GO FOR THE NEXT LAYER WHICH IS THE OPACITY.
						   
- Equipment Explainations: Add section to show parameter changes by %.

- Equipment Quality Enhancement:  Alteration to enhance quality value for equipment! Need to separate armor types
								  and weapon types just like for Enchant and Imbue.

								  Example:  Sharpening Stone - Upgrades Quality for weapons by 0.3! :)

								  Example:  Anvil - (would need ImageResources) Upgrades Quality for Armor by 0.3! :) :)

								  Name:  Maybe "Upgrade Weapon" and "Upgrade Armor"

- Player "Aura" Refactoring:  Several things...
		
		1) Separate Auras from Light Radius

		2) Use Aura Effect Range to create new aura on top of the light radius. 

		3) Choose whether to change Light Color or to apply Aura on top of Light Circle (OR JUST SHOW AURA DURING USE)

		4) Show effect range in the Alterations screen.

		Effectively this should separate the two and show them independently
						  
- PLAYER DEATH R.I.P. TOMBSTONE (ALSO  PERMADEATH)

- Agility:  Want to support "Miss Ratio" character stat - which has to be factored into the calculation. So,
			need better understanding or model for the asymptotic parts using Agility so that player can
			progress and balancing is more interesting.

- Enemy List:  Similar to enemy scope; but is a list of enemys just during combat. Shows all enemies in visible range
			   and their relevant attributes - (Mostly progress Health bar would be the best).

			   Several Ideas...

			   Idea:  Only show health meter until "Knowledge" of this enemy is increased

					  - Maybe, increase using a ratio or function of enemy / player intelligence
					  - Increase based on defeating many of the same enemies
					  - Possibly increase based on alteration (NOT LIKELY)

			   Idea:  Show in the dialog window using a split window during combat

			   Idea:  Show the last hit as first in the list. So, do an insert at the top for the last
					  enemy hit.

			   Idea:  Show this meter over the head of each enemy (similar to a live action game)

					  LIKE THIS IDEA:  It saves lots of room; and would be simple if included as part of
									   a custom framework element for each enemy. Just create a framework 
									   element; and set the progress bar's render transform to offset it 
									   "above their heads".

- Refactor "SpellTemplate" to "AlterationTemplate"

- Fix calculations in Scenario Difficulty Service for attack attibute melee.

- Refactoring:  Alteration -> Mental Alteration, Physical Alteration, Equipment Alteration, etc...
							  Trying to figure out best way to break up that class into smaller parts.

				- When Refactoring: Create another level of abstraction to add other parts to a "Spell", or "Skill",
									or "Special Effect".. including animations, display text, etc... So that it makes sense
									in terms of parameters.

- Equipment Balancing:  Some new parameters to consider. These could be mostly calculated; but flags or support from
						Equipment items need to be considered.

						- Miss %:  Calculated based on character strength, agility, class, etc...
						- Quality: Change this to "Attack Value" or "Power" - And calculate based on
								   strength, agility, intelligence, character level, speed, etc... (possibly with flag support)
								   ("Grows with Level") - Power = Quality * Level.
								   ("Grows with Enemies Slain") - Power = Quality * Enemies Slain.

						Alterations could accompany the new parameters. Example:  "Sharpening Stone" improves base quality
						instead of attack attribute.

- Alteration Effect:  "Reactive Temporary/Passive"	Applies Attribute change as a counter attack. And "Attack Attribute Reactive Temporary/Passive"
					  That applies counter attack attribute attack.

- Equipment Quality Changing Alterations:  Class Change / Quality Change + plus or - minus. Example (sharpening Stone) + 0.1 to quality. Or skill of	
											enemy changes quality -0.3 (stone golem or something chips your blade). So, new alteration types required:
											   
											- Decrease Weapon Quality:  Alteration used as skill by enemy (or player) to degrade character equipped weapon
																		quality.
																		  
											- Decrease Armor Quality:  (similar)
											   
											- De-Enchant Weapon:  Alteration to degrade equipped weapon class (used by enemy or player as skill).
										   
											- De-Enchant Armor:   (similar)
											   
											- Increase Weapon Quality:  Alteration used by Player ONLY to upgrade any weapon's quality (using UI to select)
											   
											- Increase Armor Quality:  (similar)

- Noise dynamic attribute:  Can have noise level.. Noise can be generated by walking, or fighting. Items can have a noise
							multiplier or contribution.. Can also add to alteration effect (noise dampening). Noise
							would have the effect of engaging enemies from a radius determined by the noise level. It could
							also give away your location if you're invisible.

							**Could also have the calculation based on how quickly you make moves - (i.e. the time between
							  moves). Would be kind of neat :)

- Strength Requirement for Equipment (PROBABLY JUST USE HAUL)

- Contraptions:  Consumables that can set up a doodad in the level. 

- Doodad Effect:  Have it automatically hit all enemies without having to target.  Also, want to support "Everyone in Range"
				  and "Everyone except source in Range"
				  
				  ANOTHER EFFECT:  ATTRACTS ENEMIES (NEED ANOTHER CHARACTER STATE CALLED "AGGREVATED" TO HAVE AN EFFECT ON
				  ENEMIES AND MAYBE ALSO PLAYER.
				  
- Enemy Behavior:  Want to expand on current behaviors and starting positions. Would like to support groups or hordes of 
				   enemies. Also, want to employ a tertiary behavior.. Considering having them do something on each turn 
				   besides wait for the player.. Brogue has them Wander -> Sleep -> Hunt.
				   
				   - Idea: Support a dynamic list of behaviors - with one default (being attack player). This list acts as
						   a state machine - with conditions for the state to be active.
						   
						   - Condition:  Turn counter (internal to Behavior) is less than 10 (resets with each state change)
						   
						   - Condition:  Character stat is above / below some threshold
						   
						   - Condition:  Character is able to perform attack action (skill cost is met)
						   
				   - So, the enemy's behavior could roll-over from one to the next for as many as they've been configured with. Also,
				     the default behavior would catch if the rest of them feel through.
				   
				   - Idea: Add "Randomizer" to the behavior set. This would perform the function of selecting one behavior at
						   random every "X" number of turns.
						   
				   Also, want to better support Standoffish behavior by adding a parameter to specify the number of cells to
				   "stand off" before attacking. Then, create a new movement type called "Runs and Hides".

- Doodad:  Timed fire doodad. Triggered by character movement in range.

- Alteration Effect:  Sanctuary... Needs design :)  
- Alteration Effect:  Telepathy... Brogue ripoff :( But lots of fun! :)
- Alteration Effect:  True Polymorph (random enemy)

- Brogue Idea:  Searching.. can have search timers for objects near player. Doodads / hidden doors. Basically, implement above
				Brogue-style search without the "timed event". Really like how that plays.
				
- Brogue Idea:  Self-Identify.. One major problem in Rogue.NET and other rogue likes is the number / amount / variety of different
				items that are important to the story. Brogue lets you self-identify over a number of turns. I'd like to turn this
				up a notch and have items become more important and have more levels of depth (where appropriate).
				
				Many ideas... Have a static / dynamic number of "levels of depth" for each equipment item - allowing for identified traits at
				each level (big design problem here).  
				
					Example:  "This is a short steel sword" (Level 0 Description)
					
							  "This is a short steel sword that belonged to someone of the British Empire. It appears to be 
							   high quality" (Level 1 Description)
							   
							  "This is King William's personal guardian sword. It has this magical property" (Level 2 Description)
							  
					Example (Consumable):  "The scroll appears to have a red wax seal" (Level 0)
					
										   "The scroll has a gentle aura of goodness about it" (Level 1)
										   
										   "The scroll casts a spell of Healing" (Level 2)
				
				Progressing from one level to the next could just take a number of turns. Also, USING the item or piece of equipment 
				should expedite the speed at which it progresses to become fully identified. (And, of course, you could find consumables
				or doodads that do this as an alteration)
				
- Keys:  Consider getting rid of modifiers for doors / fighting.
				   
----------------------------
						  
- Add - Scenario details to Open screen
- Add - MP Low behavior
- Add - Message when saving game
- Add - Messages for spell alterations (melee messages)

- Change - Maze level "Dim Gray" to something brighter or colored (Firebrick Red)
- Change - Zealot skeleton animation to single blink

- ISSUE - "Standoffish" Can't calculate path to run away or open obstacles like doors
- ISSUE - Have to put in safety checks for completely filled level (Get Random Cell will crash)
- ISSUE - Teleporting enemies are still shown. Can see their new location
- ISSUE - Fix door issue (not opening; but open.. can't see through)
- ISSUE - "Blink" animations reveal the level size. Should turn those into blink for the full screen
- ISSUE - Uncurse pre-condition not calculated. Allowed casting of alteration (item grid). Also, "back" button on dialog was visible
- ISSUE - Pitfall STILL VISIBLE
- ISSUE - Need way to systematize placing level content (on the backend). So, probably best to have the IModelService place ANY contents
		  So that it can always check for free cells to place content on. If there's no cell available - need to decide how to proceed.. may
		  be that the content is objective and therefore has to be placed.
- ISSUE - See Invisible isn't working.
- ISSUE - Reveal isn't showing invisible enemies
			  
- Fix - Skill learning didn't work when player learned skill AFTER required level
- Fix - Multi-use consumables not updated after use
- Fix - Problem with Blindness - didn't recalculate enemy visibility immediately
- Fix - Zealots didn't move around
- Fix - Enemy opens door - trigger topology change (something went wrong.. didn't show door opened)
- Fix - Apply limits to MP (negative value on Lynx evaporate MP)
- Fix - Update player symbol when activating skill (should be done on turn)
- Fix - Add Attack Attribute melee message to player spell and enemy spell (meleetarget)
- Fix - Spiral Target with constant velocity animation caused crash "Trying to calculate const velocity for spiral animation"
- Fix - "Vile Mother has used 'Create Vile' on"
- Fix - Identify for non-class items should identify all future non-class items with the same RogueName
- Fix - Identify All isn't updating the Encyclopedia view
- Fix - Wraith's drain experience doesn't knock player down a level (need this one for item / equipment / skill requirements)
						
- Balancing (Paladin) - Add some skills for learning: Disciple, Satanic Priest, maybe one or two other.. but EViL! >_<

--------------

IMMEDIATE TODO'S:

	- Clear out message box when re-starting.

	- Use points to increase stats instead of randomly doing it when gaining a level.
	
		- SMALL REFACTORING:  Create a few different types of level commands:  Normal; 
							  View Action Command; Imbue Equipment Command; Player Advancement Command.
							  
							  Need to expand this some to include actions with new data.  This is mainly
							  for new dialogs with other data fed back to the backend.
							  
	- Nice to have:  Explain attack attributes by having a separate UI to show how they apply
---------------
		
	- PERMADEATH
	- Dependencies:  Take the algorithm from Traingle.NET and remove code
	- Dependencies:  Look for source for Dotaway - OR just write:  a desaturation algorithm; and a pixelation algorithm.
	- FIRST BIG TODO:  Refactor Animation targeting type to handle physical cases:
	
					   Problem:  There's an un-written "coupling" between animations and alterations. Example is "Run Away"
								 which affects the source character only (as an alteration). Choosing "Target to Source" animation
								 type can cause a crash or issue because they don't relate.
								 
					   Solution: Force animation type selection to work with physical content and alteration calculating. An example
								 would be calculating some kind of "range". It's usual for an animation to have some kind of range 
								 associated with it; but it relies on the considered targets. 
								 
							     So, "Targets in range" would become something like "Calculated Alteration Targets". If you tried
								 to apply this to "Source.RunAway" then you'd have the following:  
								 
								 - Calulate Affected Characters => Source (enemy)
								 - Calulate Altertion Targets => Source (enemy)
								 - Apply Animation: No animation applied because there is no target apart from source
								 
					   Other Solution:  Add specific parameters to the animation related to the calculation. Example: Range parameter.
								 
					   Main Idea: If this can be accomplished without refactoring then it should be validated that any animation 
								  support be verified before hand so that you don't have issues in game. 
	
	- NEXT BIG TODO:  Figure out a way to calculate combat value for items based on player parameters (Level, Strength, Agility, Intelligence)
	- OTHER BIG TODO:  Redo enemy behavior
	- OTHER BIG TODO:  Make pathfinding algorithm more efficient.
	- OTHER OTHER BIG TODO:  Terrain
	- TODO: Path-finding efficiency
	- TODO: Fix up the simulator for equipment attack / defense values based on attributes; and anything else that has changed.
	- TODO: Generate Alterations right away (don't store the template on the item / enemy behavior). To randomize add a component
			to do this with some variance (gaussian distributed or whatever) around the base (mean) instead.
			
			If this works out without too much trouble - repeat this EVERYWHERE. Just get rid of RANGE values and use a randomizer!
			This will simplify the hell out of everything.
			
	- TODO: Remove the level range specification from all assets. Add a list of level specifications: each has a list of consumables,
			equipment, enemies, doodads, a layout, etc.. and generation rates, variances, etc... This would virtually eliminate the
			need for templates; but would introduce a new class of components to place / specify / randomize everything. This class
			should be MUCH smaller than the currently supported scenario configuration. 
			
	- TODO: Remove list sharing for all asset properties. Example:  Consumable.Alteration should not reference a list of alterations. Also,
			apply to attack attributes, character classes, altered state, etc... Create them in the asset UI - but show a list of what
			currently is in the scenario - with option to copy one that's already there. Then, in the "General" section, just show an
			aggregate of all of these "shared" asset properties to show what they are. Then, for meta-data, create these lists on-the-flying
			as these asset properties are generated. Example:  Create first "Poison" Attack Attribute. Event Aggregator fires the event
			and another component maintains the collection of meta-data for attack attributes. 
			
	- IDEA: To keep / maintain shared collections - use attributes for the class to identify the location of it's "master list". This will
			help avoid maintainence issues for the many "Fix Reference" methods.... Uuugh.
			
	- TODO: Clean up "engines" and systematize. Componentize things a little better; and make it known how messages are being published.
	
	- TODO: Propagate the name of the Alteration template to the corresponding Alteration Effect template.
	
	- IDEA: "Interlude" for the scenario - Fade-in message on-screen after Level "X" to show a part of the story.
	
	- IDEA: Friendly unit type. (Easier that it sounds probably). 
	
			- Friendly derived Character type
			- Add check for Player movement so that you can swap places with Friendly units to avoid obstructing your path
			- Add targeting type for Alterations to select unit type (Example:  Heal all friendly units in range, or Heal Player type units)
			
			- Then, it should be very easy to support a Necromancer scenario :)
			
	- IDEA: Undo Service. This is a difficult problem I think in most any editor program. I tried building a stack-based Undo function using
			the INotifyPropertyChanged and INotifyCollectionChanged mechanism in WPF. I think it mostly worked; but there are some nagging
			issues with event coverage because I feel like we're missing some of the events that should be forwarded and kept by the Undo Service.
			
			So, my design idea goes like this:  
			
				   Get a handle on binary serialization - to where we can represent the data as a binary "Blob" and changes to the data 
				   as SMALL "Deltas" - with some change description. 
				   
				   Example:  ModelChange { Data[], int Offset, int Length, string ChangeType, string ChangeDescription }
				   
				   So, the entire "Blob" of changes should represent the data model - just a serialized version of it that we can use
				   to provide an Undo Service. 
				   
				   Synchronizing the Undo "Blob" and the actual model is the only major worry.. but if there's a way to do this with the
				   actual model - that would be even more idea. I'm just not sure how that might work.
				   
			Thinking about it some more...
			
				   The major problem with this design (like the current design.. or any other design) is synchronization of two versions
				   of the same data model. I don't like it..
				   
				   So, a better way to do this: Create a custom serialization service
				   
						- Serializes all public properties using Reflection
						
						- Creates a custom serializer for each property type
						
						- Validates that all public properties have a serializer (or throws an exception)
						
						- Underlying binary format chosen by the serializer - with the main "Blob" being a simple byte[]. 
						
						- The Primary object graph is serialized with a CUSTOM METHOD. This is important to 
						  deal with reference checking. 
						  
						  An example of a serialization service that works ONLY FOR TREES (non-cyclical object graphs) is
						  PROTOBUF!  Which I don't think they tell you... but you have to build your own custom routine 
						  using their pseudo-language. 
						  
						  This is essentially what I'd build here - except with direct control over the byte[] in a way to
						  be able to insert, add, or remove changes.
						  
						  Example:  ScenarioConfigurationContainer has a ISerializationService implementation with a methods
									called ISerializationService.Serialize.  Then, there'd be support for changes to the model
									that needs to be worked out.. Maybe using some kind of attribute mechanism.. but I think it
									would have to be specific to the model structure. 
									
									Maybe, [SerializationUpdateAttribute( Some.. Properties.. to.. Specify.. Update )] for each
									type (or public property)
									
						  However, I believe that the INotifyPropertyChanged / INotifyCollectionChanged events would still be 
						  used - just with a different listener - which would be the ISerializationService. This service would
						  probably then notify the Undo service with some change description which would (of course) be compatible
						  with the serialization service.
						  
				   SHOULD THIS BE SUCCESSFUL:  I'd use this for the primary model serializer.. and any other serialization we do.. 
											   even just as an experiment to work with primitive data serialization more closely
											   and to understand better the crux of the problem.
											   
											   Dealing with cyclical object graphs is a trickier problem which I'd think is out of
											   scope.. but if I felt confident in trying - it might be worth the effort to learn
											   a little more from reading or research because this problem is fundamental and I don't
											   see it done properly anywhere .. EVER.. usually.. but the tree-object-graph is simple
											   and this one is done well.
											   
    - TODO: Validate that the AlterationContainer.RogueName (GETS COPIED TO) IAlterationEffect.RogueName. Add validation rule.
	
	- TODO: Must have "Normal" Altered State (Somehow...) Not sure how to do this one.. But it needs to be done because the boolean 
			flags to control "HasAlteredState" have been removed in favor of a default "Normal" state.
			
	- TODO: Build Enum-to-Radio-Button-with-attribute-description control to handle choosing an enum for the editor
			
	- IDEA: If there's want to do this for the Sorcerer - have different targeting "types" for moving the targeting cursor around manually.
			
				- In Visible Range: Could teleport yourself OR ANOTHER CHARACTER from one place to another in your visible range.
				
				- In Explored / Revealed Range: Could teleport yourself OR ANOTHER CHARACTER from any explored / revealed location to another.
				
				- In Range of Player "Special Reveal":  This would temporarily reveal a certain distance from your player to accomplish
														the same task of teleporting yourself or an enemy. 
														
				- Have to avoid obstacles:  Cursor should blink "Red" if you can't move there. 
				
				- ANOTHER IDEA:  "Force Enemy Back" pushes enemy in line of sight backwards into Wall / Another Enemy. Would be nice
								 to animate this - maybe kind of like "Clay-mation" (cell, cell, cell, BAM!) Or something else.. Would
								 damage all characters involved.
								 
				(The next two could support the "Doom Sorcerer")
				
				- INSTANT DEATH:  "Abolish Enemy to the Void" some kind of alteration based on character attributes.. maybe intelligence,
								  uniqueness, or some other thing that instantly kills the character.
								  
				- "CONDEMNED":  Event that goes like this:  Character 1 casts alteration on Character 2 that starts a timer (if it's not blocked). 
								The timer should be shown somewhere so that the user knows that either they're going to die or their enemy
								is going to die.
								
								The way to defeat it is to 1) Have a remedy for the temporary event alteration or 2) to defeat the other character :)
						  
	- TODO: Use either Routed Attached Event or ServiceLocator -> EventAggregator to supply changes for Undo instead of INotifyPropertyChanged. Also,
			have to Hook new complex types in UndoAccumulator when they're changed. 
			
			THIS MIGHT BE A VERY SIMPLE UNDO SERVICE
			
	- IDEA: Could support "Detect Magic"
	
	- TODO: Attack Attribute Refactoring
			
			1) REMOVE SHARED COLLECTION FROM SCENARIO CONFIGURATION
			
			2) Create Attack Attribute collections sparsely - using a service to provide a scenario-wide collection to COPY from
			   to create an instance for the asset or alteration effect
			   
			3) Shrink the UI for editing them to one-line; and add an option to show / hide the attack, resistance, and weakness appropriately
			
			4) FOR THE SCENARIO SIDE:  Either A) Leave the design AS IS and pre-copy FULL LISTS of attributes to each asset / alteration effect
										   or B) Work with sparse collections and re-design how they're used to accomodate differing sets
										   
	- TODO: Finish Alteration Effect UI
			
			- Fix up controls and fit them to the design area
			
			- MOVING BRUSHES TO NON-SHARED ASSET:  Put Brush Editor on the Animation Editor (Nothing else for now...)
			
			- REMOVE STROKE TEMPLATE
			
			- Verify that stale data doesn't stay in display when switching assets
			
			- Create one of each new Alteration effect type for the Sorcerer scenario
			
			- Validate Alteration Effects for some of the low-hanging fruits; and don't go overboard
			
			- FIX UP THE ASSET REFERENCE SERVICE
			
			- Add Default Implementation Type for IAlterationEffectTemplateViewModel.. Probably instantiate the null values in the 
			  Scenario Configuration Mapper when fixing references... OR where the source null values are instantiated (commented code)
			  in the mapper using reflection.. Not necessary though because any developer can figure out what's happening and there'safety
			  no crash in the UI for an unset alteration effect. It's just bothersome to work with.
			  
    - THOUGHT:  Using Protobuf to deal with serialization might be a good idea. Basically, it would be better to have a single 
				source for the model than two. I believe Protobuf can generate code based on its "source (custom) language". Also,
				I think it deals with serialization - and I'd like that to be handled in a single place.. If it was language
				agnostic serialization that would be IDEAL. 
				
				Protobuf treats object graphs like trees by default; but I think you can customize the "source code" for the 
				object graph to have shared instances. 
				
				If this isn't possible - it would be a fun exercise to try and build something like this from scratch; and to be able to
				handle some of the primary design issues for the Scenario Configuration:
				
					- Mapping:  Going from one namespace to the other seamlessly
					
					- Serialization: Being able to serialize the MODEL independent of the "target language" (either Model or ViewModel)
					
					- Versioning: Handling changes to the model without fear of loosing data
					
					- Code Generation:  Generating "target languages" - probably based on a text-based template:  one for the model namespace
										and one for the view-model namespace that took care of inheritance from DependencyObject, Interface 
										implementations, etc, etc...
										
					- Database Backup:  Going from the "source language" to a database schema seamlessly would be very nice.
										
				THESE WOULD BE GREAT THINGS TO HAVE.
				
	- TODO: Make Rogue.NET playable with only the mouse
	
	- TODO: Want probability parameter on the Equipment Attack Atleration.
	
	- TODO: Type-Specific tooltip for IAlterationEffect. This will help show all the wonderful / different effects of items. Also, can reuse
			the UI in other places:  Skill Tree, and Rogue Encyclopedia
			
	- TODO: Provide Brush-Copy service that provides list of all brushes in the scenario to copy from - with a preview image (add to brush editor)
	
	- TODO: Provide asset navigation from Construction -> Assets. Also, make the Construction re-load on click.
	
	- TODO: Immunity Alteration Effect - Makes you immune to a specific altered state.	
										
	- TODO: Skill / Reveal UI (clean up)
	
	- TODO: 
				- Haul Usage:  WHEN HAUL IS EXCEEDED - PLAYER MUST DROP SOMETHING TO PROCEED. This should be used when enemies drain strength from
							   player.
							   
				- Animations:  Validate parameters so they don't cause in-game error message
				
				- Modify Equipment:  Implement enemy alteration on player as EQUIPPED ONLY.
				
				- Gremlin (Fighter Scenario): Change teleport to "Blink" inside player visible range (it's super annoying :))
				
	- TODO: Hide the Scenario Seed and randomize it by default
			
	- TBD:  If the scenarios need to be randomized for items (the symbol color) - might consider refactoring the images:
	
			1) Use SVG vector graphics
			
			2) Find a default coloring that works with HUE shifts to create the various colors (or) build some kind of 
			   rotating color filter that can handle creating something like primary -> secondary -> tertiary colors from
			   maybe a set of mask colors that can be used to create the base SVG.
			   
			3) Using a color filter - apply to create symbol changes instead of the parameterized one that's there. That
			   would save a lot of time / parameter space.
			   
			4) Find a way to convert symbols into SVG's - should reduce the resource set by a factor of 10.
			
			5) Consider creating a subset of UTF-8 as a vector image set to show / size into cell containers. Problem is
			   that some symbols get cut off - so would want to resize to fit. (Probably could do this by measuring the
			   TextBlock first also)
			   
	- TODO:  Attack Attribute Refactoring:
	
				1) REMOVE SHARED ATTACK ATTRIBUTE COLLECTION FROM SCENARIO CONFIGURATION AND SCENARIO.
				
				2) Use sparse attack attributes; but create some centralized methods to apply them
				
				3) Simplify Alteration Effects by using SINGLE attack attributes for some; but breaking up the class into
				   several use cases:
				   
					- Attack Attribute:  (A, R, W)
					- Attack Attribute Positive Change:  (A, R, W) -> (+, +, -)
					- Attack Attribute Negative Change:  (A, R, W) -> (-, -, +)
					
				4) Provide services for supplying the full attack attribute list
				
	- TODO: Deal with proper nouns. Probably can do this using a flag on the enemy. "Use Proper Noun" (when addressing enemy)
	
	- TODO: HasAlteredState flag for each temporary
	
	- TODO: Enemy Light Radius - HAS BEEN MOVED TO CHARACTER BASED
			
			- NEXT:  Design behavior around Light Radius (Engage / Disengage) - (not necessarily around this parameter)
			
			- Then:  Enemy Targeting - Skill behavior around light radius
			
			- Then:  Line-of-sight per character - calculated on turn.
			
			- Then:  Enemy / Doodad as light source :)
			
			After that - decide how to do targeting:
			
				- Player "target what you can see?"
						 "miss if out of range?"
						 "miss probability?"
						 "miss probability per alteration effect?"
				
				- Enemy  "target what you can see?"
					     "engage if illuminated?"
						 "engage if you can HEAR?"
						 
			The idea is just to enhance the API - but to keep it INTUITIVE. So, if it makes sense to do
			then do it. Right now it's calculated all based on the Player visible range; but that can
			change if the light-of-sight calculation isn't too intensive.
			
			If it is - then just use the enemy light radius in calculations.
	
	- TODO: Refactor End-Of-Turn logic.
	
			- This generally needs to be systematized. It's all out of sorts - and there's no sequencing. It should
			  be pretty easy and straight forward to do.
			  
	- TODO: Refactor Front-end logic some to remove ambiguity about updating player v.s. enemy (just do characters)
			
			Also, have a single enumeration (or method) to run an update per character (unless processing gets too slow);
			but mostly to handle updating everything about a character without ambiguity.
			
			Example:  Apply an alteration. RogueUpdateEvent(AffectedCharacter.Id, Enum.SomeSpecificProperty [Flags])
					  Can handle the update. 
					  
					  The problem is that the symbols for the characters are handled when they move around. This needs
					  to be decoupled.
					  
					  If necessary - add a simple front-end controller to handle "Update for a character"
					  
					  IContentUpdateController
					  
						- UpdateSymbol(CharacterBase.Id)
						- UpdateEquipment(CharacterBase.Id)
						- UpdateAlterations(CharacterBase.Id)
						- Remove(CharacterBase.Id)
						- Add(Character)
						
					  Also, break up and componentize LevelCanvasViewModel - which basically is a collection of ScenarioImage
					  elements - to be drawn / updated somewhere else; and collected by the IContentUpdateController.
					  
	- TODO: Make sure to apply "Generate on step" to enemies
	
	- TODO: Make throwing generic - not pre-specified:
	
			1) Every item has a base throw effect - something like (Strength * [Throw Quality])
			   AND something to deal with accuracy - maybe (function(Strength, Agility, and maybe [Throw Accuracy]))
			   
			   Probably want a couple parameters for the item so that it makes sense.. Can't do much
			   damage throwing armor; but you could try...  (it won't help to be strong)
			   
			2) Player can try throwing any item; AND it's only consumed when it strikes the enemy 
			   (like DOS Rogue or Brogue)
			   
			3) If there's ever time to do the per-step-identify (Identify items in levels based on 
			   a) how long you have them (by type) and b) if you're using them, etc...) Then, this
			   could be a part of that. (IdentifyParameter class to specify how it all happens. One
			   per effect to identify)
			   
			4) For any special effects - they'd have to be added to the item. So, that could be done
			   on the base class so that the player could try throwing equipment. 
			   
			That's pretty much all; but the idea is to try different things instead of being guided
			by the throw effect that's already there on the consumable.
			
	- TODO: Skill Alteration UI: Fix up Block Type, Animation Opacity Binding (all alterations), Visibility for
			Aura Source parameters.
			
	- TODO: Fix overlapping characters - seeing a problem using "Blink" and create monster (near the player).
	
	- TODO: Restrict Equipment Attack Alteration to One / Two handed melee weapons
	
	- TODO: Create Drain [Parameter] Equipment Attack Atleration Effect. Basically, Drain HP; but make a different
			class to support it. Apply ONLY as an Equipment Attack Atleration.
			
	- TODO: Set Attack Attribute Collections EN-MAS for any new asset. FIX EXISTING ASSETS (Asset Reference Service)
			   
	- TODO: Consider systematizing part of the alteration effect pattern to consolidate some of the type inspection.
	
	- TODO: Finish alteration sub-panel by showing what aura effects do - and effects of enemy equipment auras.
	
	DECIDED TO CREATE A COMPONENT FOR STORING GRID-LEVEL INFORMATION ABOUT LINE-OF-SIGHT / LIGHT RADIUS / AURA RADII
	
		Assumptions:       Player Type (currently) is treated as a light SOURCE; "Light Radius" really means "Sight Radius" (TODO - Refactor).
						   Auras are independent of "Light Radius" and light SOURCES.
						
						   Any character (or object) COULD be marked as a "Light Source"; but that's not currently supported. It
						   would be nice to have light sources in the scenario.. Possibly even on the walls (like a flag on each
						   cell to be accounted for on this component).
						
		How to Calculate:  What's this for? This will calculate all characters' line-of-sight: locations; objects (enemies, doodads, items);
						   Light "radius" locations; and aura radius locations for all alterations. PER CHARACTER.
						   
						   The state should be stored here; but not serialized. 
	
		Input:  		   Any Character
		
		Calculations:      Line-of-sight, Light Radius, Aura Radius (per aura)
		
		Output:   		   Line-of-sight:        Locations
						   Light Radius:  		 Locations
						   Aura (many):          Locations, Colors
						   
		Future TBD: 	   The point of this component is to start to consolidate some of the grid-related scenario data that 
						   needs to be calculated and stored. 
						   
						   There's lots of ideas of what to do in the future if there's time. One would be to create more light 
						   sources - which is pretty straight forward given this design. Another could be cell coloring or opacity
						   based on many different character's auras, light source (maybe colors), etc.. Then, line-of-sight 
						   is probably more important - as it could change some of the possible actions of the characters.
						   
						   Example: Enemy is far away; but in a lit-up tile (another object's light radius). You could try and
									throw / fire something at the enemy; but have a small % of success. 
									
									More imporantly - you could see the enemy.
									
						   Another idea is to have patches of lit up tiles as part of the layout. This would be to simulate light
						   coming in through the ceiling. (varying per level)
						   
						   One final one - requiring more design - is TERRAIN :) :) :)  Water, Fire, Swamp, Steam, Anything Brouge
						   tried - but only if there's others helping because it's a lot to do.
						   
						   Light sources, auras, and line-of-sight would probably be enough for this guy.
						 
	- TODO: Draw a Diagram of the Backend Processing.
	
				- Start with the ScenarioService - drawing pointers for each method entry into the engines.
				
				- Show the flow of events onto the ScenarioService queues.
				
				- Show the updating of the UI from events.
				
			Need to know how the backend is updated - specifically:
			
				- Character stats
				
				- Layout (Topology and visibility and line-of-sight)
				
				- Character Visibility (Same component)
				
				- Item / Object Visibility (And Revealed / Explored status)
				
			So, need to understand the sequence of events surrounding specific actions to be able to be
			confindent systematizing the backend end-of-turn logic.
			
			IDEA:  Hide the Level object inside the IModelService (or something like that component) and
				   prevent firing of events to the queues where possible.
				   
				   It would be easier to think of if the update events were encapsulated into components;
				   and the major data containers were also encapsulated with those components - so updating
				   the front end and queuing up other events was much more intuitive.
				   
			NEEDS TODO:  It's getting a little too involved to keep queuing events for the back end. The
						 processing needs to be refactored to make it easier to manage the state (IModelService)
						 sequentially.
						 
						 IDEA:  SEQUENCE all character activities. This could be accomplished with some other
								simple queue architecture that allowed sequences (maybe per character) to be
								processed before continuing with other sequences.
								
								Example:  Player Reveal Item -> Animation, Consumable Item Remove, Revealed Content, 
									      UI Updates -> Enemy 1 Reaction (.., .., ..) -> Enemy 2 Reaction -> (.., .., ..)
										  
										  What this means is that the queues could provide a sequence for these 
										  actions. 
										  
										  BUT - there's a big problem with updating the state. Model updates have
										  to be injected where they're important.. maybe between characters. 
										  
										  Player -> Model update -> Enemy 1 -> Model Update -> ...
										  
										  There might be a better way; but trying to sequence all of these things
										  at the "End of Turn" really doesn't work right.
										  
										  I'm thinking it should be more like this:
										  
										  Player -> Player End of Turn -> Model update -> Check for Scenario Event (Player Died, etc..)
										   -> Enemy 1 -> Enemy 1 end of turn -> Model update -> Check for Scenario Event (Player Died, etc..)
						   
										  So, as long as the processing isn't too involved - it might be easier just
										  to check "everything" or "everything per character" (which includes bigger
										  events like player death, or level change, or maybe dialog events) between
										  queued reactions.
										  
										  Then, one final primary concern is when to update the UI. Animations should
										  take the highest priority; but UI updates I'd think should also be done 
										  between characters. And, the Update types probably should be thinned out and
										  just refactored.
										  
										  The LevelCanvasViewModel is also too crowded and needs refactoring. 
										  
										  The design favoring a front-end controller would be ideal for processing 
										  updates PER-CHARACTER. So, if this new queueing design is implemented - 
										  it might be a good idea to try and work with the front end to break up
										  some of that junk that's collected to update view models.
										  
	- IDEA:  Have an enemy behavior condition that "helps them when they're lagging behind the player". Maybe like 
			 the hippogrif in the socerer scenario casts "gather" when they're lagging behind. or teleport near player.
			 
			 Also, TELEPORT ADJACENT PLAYER would be a nice-to-have effect enum.
			 
	- NOTE:  Aura support for enemies was to deal with equipment auras that would be applied to enemy equipment.
	
	- IDEA:  Split up level canvas into several layers to deal with z-index; and to break up the collections to store
			 the ui elements.
			 
				- Each layer is associated with a separate view-model type (LevelCanvasImageViewModel, LevelCanvasAuraViewModel, 
																			LevelCanvasLightRadiusViewModel, ...)
																			
				- Collection of view-models is bound to a layer in the view (maybe ItemsControl)
				
				- The collection of collections is known to a UI controller (somewhere) to handle updating
				
	- TODO:  Fix enemy / player aura removal:  steal item, un-equipment
			
		     Fix enemy / player aura application:  enemy doesn't show unless they react. player doesn't show at all.
			 
	- IDEA:  AURA / LIGHT RADIUS RENDERING:  Thinking that the performance issue may have been about dealing with the
										     level layout PATH FIGURES - using software rendering (not sure what that means) - 
											 so that probably means that all of those figures had to be calculated in when
											 applying the opacity mask.
											 
											 So, since the brush for the light radius is [LEVEL WIDTH, LEVEL HEIGHT], it probably
											 was doing much more than it had to. 
											 
											 I'm GUESSING that could be solved in a couple ways:
											 
											 1) making an "Outlined Path Geometry" for the layout cells - which may clump
												together all of those stream geometry strokes. I'm not convinced that the
												stream geometry is any faster in this particular case.
												
											 2) Make the "light radius" or "aura" size constant based on the number of cells
												in the radius (light radius = 5) or aura. 
												
												This would make the size of the rectangle boundary constant so that the 
												brush wouldn't change shape as a character approached the wall.
												
											 Then, the last question is whether or not applying the opacity mask to the container
											 object for the layer (ItemsControl or Canvas) is performing better than applying
											 it to the individual aura / light radius.
											 
											 (I'M GUESSING IT HELPS).. But, i'm not doing any benchmarking. So, just a matter
											 of avoiding the performance problem.. Which was something like: 40 zombies with 40
											 auras at once.. That was like several seconds between steps.. maybe like 5-10 seconds
											 to render each step.
											 
	- TODO: Front end is updating on each step (DrawContent).. Already needs fixing to deal with a controller.. so will have to
			make this granular again.
			
	- TODO: Break down "Food Usage Per Turn" UI to show contributions per type (Alteration, Haul)
	
	- IDEA: Consider getting rid of Dodge, Mental Block, and Critical hit statistics. (And the related alteration parameters).
	
			Instead: Have a new alteration that BLOCKS ALL (something).. to replace an alteration that boosts your "Mental Block %"
			
			Also:    Go ahead and calculate blocking behind-the-scenes; and show it as a % of success somewhat like Brogue on
					 a mouse-over. Do the same for Dodge, and Critical hit.
					 
			Also:    Need to calculate a Miss %. So, there's things to do for character interactions.
			
			Then:    Maybe would want to show some of the calculated parameters for changing equipment; and possibly active skills.
			
	- IDEA: Maybe change HP -> Health; and MP -> (something like) Stamina (but it's for skills / alterations that require stamina)
	
	- IDEA: Maybe try some proof-of-concept scenarios for some of the weirder support that Rogue.NET provides. Maybe, have a game
			centered around "keeping the lights on" - where everything you do affects your light radius (?) Maybe even simple attacks
			(using weapons with attack alterations).
			
			Other things to make it interesting... ? (too many to count) How about multiple stair-wells? Or, challenge levels (?) 
			(an alternate stairwell with a single room and no other way down after that) 
			
			I like - PUZZLES~! Pretty sure there's a lot of ways to do that; but anything working with the level to solve a puzzle
			would be really really phenomenal:  Hidden passages, locked-rooms-with-one-key outside the room, locked-rooms-with-enemy
			guards; button sequences (stand on one, stand on another, don't mess up - or you will be in "danger" (enemies, etc..))
			
	- TODO: Explain attack attributes in terms of % difference between two values:
	
			Example: Equipment shows % + or - change when worn or removed. 
			
			PROBLEM: Have a dependence on Attack and Resistence for a change in the value.
			
					 [F(A, R, W = 0) - F(A, R + e, W = 0)] / F(A, R, W = 0) = 1 - [(A + R) / (A + R + e)]
					 
					 So, if A = R = 5 and e = 1, dF / F = 1 / 11. 
					 
					     if A = R = 10 and e = 1, dF / F = 1 / 21.
			
					 That means the % difference is dependent on A and R. That's a problem for 
					 showing to users because you can't factor out A.
					 
					 So, what if the resistance was based on a simple rational function just
					 of R. The output of F(R) would be [0,1) (for all R >= 0). Similarly, the Weakness function
					 would just be a simple function G(W) that doesn't depend on A either. So,
					 The total attack value is:
					 
					 Attack Value = A * [F(R) + G(W)] 
					 
					 Where:
					 
					 Resistence = Arctan(R) (maybe 2/pi * arctan(R))
					 
					 But, it won't actually work. Because, that would say you're "Adding on a % of resistance" - which
					 only works relative to A. 
					 
					 So, FOR SHOWING THE USERS how effective their equipment and alterations are at defending or
					 attacking based on attack attributes - the number they see will have to suffice. 
					 
					 BUT, it will have to show you what's happening for those attributes so that you know (DURING COMBAT).
					 
					 And, the method that's being used now is really perfect for attack attributes because it gives
					 you a ratio of 1/2 for R=A.. which guarantees A always wins (which it should) (same with strength)..
					 but having this kind of calculation will be the best for every type of attack attribute related
					 effect. 
					 
					 So, probably, the UI will have to be easy to intuit for these - whether it be a log, or an enemy
					 HP meter with "the last hit shown (in terms of attack attributes", or some visual queue when there's
					 an attack being made with them (maybe). But, they have to be considered to know easily.
					
	TODO: GET RID OF Range<T>.HighLimit and Range<T>.LowLimit from the class - and move to the UI only.
	
	TODO: Make (most) Attack Attribute properties "single-attribute".  
	
		  Example:  Equipment Attack Attributes - Probably won't ever use more than one at a time - espeically because
					there's a lot of equipment! (two rings, a belt, shoulders, an orb, an amulet, etc... etc... So, 
					probably want the "innate" attack attribute for the equipment to either
					
					1) Go away (in favor of the attack alteration)
					
					(or)

					2) Go to a single attribute (each equipment item just gets one)
					
		  I'd think probably along these lines for changing this:
		  
			- Enemies get a full list 
			
			- Equipment innate properties go to ONE attribute - with the addition of another ONE attribute for each Alteration
			  (Attack, Equip, Curse)
			  
			- All other alteration effects go to just ONE attribute
			
			- Character class also goes to a SINGLE attribute.
			
		  Then, change Rogue.NET to deal with sparse collections of attack attributes:
		  
		  Example:  For Enemies, the editor should add on to a list of attack attributes - allowing just a SINGLE INSTANCE per
					NAME of attack attribute. 
					
					The editor should provide a dropdown list of current attribute to select from to prevent creating new ones
					with the same name; and to copy over the name / symbol for each one to create a new instance for the enemy.
					
					The editor should provide a way to create a new attribute NOT in the dropdown to add to the scenario 
					(calculated) collection. This can be modified RIGHT THERE; but once it's done - the attribute will NOT be
					allowed to be modified - just DELETED. The primary scenario list will be managed by probably the 
					ScenarioEditorModule using Events.
					
	- TODO: Problems with "Magic Block", "Criticl Hit" and "Dodge" as a probability. 
					
			1) Too many "things" to fuss with for the user. (And for the UI).. But, primarily, these don't do enough to show you
			   that they're important. 
			   
			2) Using different forms of balancing (Attack Attributes, Character Class, Base Attributes, and Altered States) the
			   user would want to know when / how to BLOCK, DODGE, or CRITICALLY HIT based on those.
			   
			3) The calculated [ Hit, Miss, Dodge, Critical Hit ] could be based on base attributes [Strength, Intelligence, Agility]
			   but, most likely, kept more like simple PHYSICAL combat [ Hit, Miss, Dodge, Critical Hit* ]
			   
		    One of the PRIMARY problems designing a "Magical" Character (like the Sorcerer) - was dealing with Intelligence-based 
			combat using weapons.
			
			This problem was solved by introducing an attribute parameter that specifies the base attribute to use in the 
			calculation. 
			
			BUT, that doesn't deal with other things like [ Hit, Miss, Dodge, Critical Hit ]. These really should probably be 
			calculated BEHIND-THE-SCENES; but not shown to the user unless it can be done without confusing them. Brogue does
			a pretty good job of this with their "interaction dialog" describing what "could happen" when they attack.
			
			Here's what I think COULD happen for doing blocking in a bigger way to include some of the other things like 
			[ Attack Attributes, Character Class, and Altered States ]
			
				1) BLOCKING AN ALTERATION should be based on a) The switch on the Alteration (Physical / Mental) (CHANGE TO
				   BASE ATTRIBUTE [ Strength, Agility, Intelligence ]; and the base attributes. 
				   
				   The current calculation uses a trancendental function (Arctan) to come up with probability based on 
				   the RATIO of the attributes: P = F(Enemy Attribute, Player Attribute) = C * Arctan( f(E / P) ).. which
				   will provide a number between [0, 1].
				   
				   This should work fine; but we don't want to over-display this probability.. Just maybe show when it's
				   useful to show and not overwhelming. (Something like the Brogue mouse-over for enemies would be fine)
				   
				   FINALLY, Blocking an Alteration NEEDS TO BE SHOWN. The Animation NEEDS TO PLAY Before blocking. A blocking
				   animation WOULD BE NICE (As an addition on the Alteration). (I LIKE THIS IDEA). But, it's not necessary 
				   so long as the user understands what happened.
				   
				   The in-game log is a little to much to parse continually to know what's going on. Probably better to remove
				   it in favor of an intuitive UI that shows the enemies actions (like a list of enemies with their HP meter
				   and maybe something about their last action.. like an Alteration or Attack Attributes used or Critical hit)
				   
				2) CRITICAL HIT should be moved because it's not based on an innate character attribute. It should be removed
				   from alterations and put directly on the EQUIPMENT item. 

				   This would make it an innate property of the equipment - which is a lot easier to think about from the user's
				   perspective.
				   
				   So, the Equipment item would have a CRITICAL HIT %. 
				   
				   The Equipment Attack Alteration COULD have a boost for this; but it's really not necessary. 
				   
				3) [ Hit, Miss, Dodge ] based on character base attributes [ Strength , Agility, Intelligence ].
				
					BUT, HOW? 
					
					For Attribute based Melee - keep the hit calculation based on the attribute.
					
					Example:  "Sorcerer's Staff" - (Based on Intelligence) v.s. "Worlock's Magic Armor" (Based on Intelligence)
					
						      Attack = F(Intellgience, Staff Quality, Staff Class) v.s. Defense = F(Intelligence, Armor Quality, Armor Class)

						      Hit = Attack - Defense (clipped to zero)
							  
							  Miss % = ???
							  
							  Dodge % = ???
							  
					Those will remain % based on base attributes. 
					
						Miss = Function ( ??? ) 

					Brogue would make this based on what's difficult for the character to use. Like, "my strength determines my Miss %".
					
					That might be fine - so long as the UI makes it apparent and SIMPLE to understand. 
					
					So, probably 
					
						Miss = Function ( Strength / Item Weight ) 
						
					Miss % could be based on just the ratio of the character's strength to the item weight. This DOES NOT DEPEND
					ON the character's Agility OR the Enemy's Agility.
					
					WHICH DECOUPLES IT from any other parameters - which means it can be displayed in the UI in the equipment 
					list. (with the equipment details)
					
					The Dodge % should remain based on the ratio of character agility:
					
						Dodge = Function ( Player Agility / Enemy Agility )
						
					So, Miss does NOT depend (or is NOT COUPLED) to Dodge. THIS IS GOOD. It would cause a problem showing, displaying,
					and otherwise confusing the player.
					
					Miss still needs to be implemented.
					
				4) Would like to introduce IMMUNITY in several possible ways:
				
					- Attack Attribute Immunity:  Easiest approach to implement would be a flag on the attack attribute. DON'T DO IT 
												  THIS WAY! It would overlap parameters and is not a good idea. EXISTING ALTERATIONS
												  USE ATTACK ATTRIBUTES IN A CERTAIN WAY - AND IT WOULD NOT BE A GOOD IDEA TO ADD
												  FUNCTIONALITY TO THOSE.												  
												  
												  INSTEAD:  Move Attack Attribute Immunity to a SEPARATE set of Alterations.
												  
															- AttackAttributeTemporaryImmunityAlterationEffect
															
															- AttackAttributePassiveImmunityAlterationEffect
															
												  FOR ENEMIES:  Since they don't have an innate property for this - go ahead and 
																give them one for PERMANENT IMMUNITY.
																
															- Enemy:  List< AttackAttributeImmunity >
															
																The UI might have to be set up to show both the attack attribute 
																collection AND the immunity collection together. (which is tricky
																but that UI is already overcrowded.. so a refactoring to do this
																might be ok)
																
																BUT, the attack attribute and attack attribute immunity collections
																should be SEPARATE. 
																
																Combining them would be too confusing to keep straight.
																
																(ONE MORE THING) Adding an enum option to the Combat Type (Friendly,
																Malign, Immunity) is NOT a good idea because of overlapping uses.
																	
																We don't want an Aura of immunity. Maybe in the future; but NOT NOW.
															
												  ALSO:  (Just thought of this) Character Class is supposed to provide things like
														 this idea because it would work well to balance the scenario.
														 
														 So, would like to do PERMANENT IMMUNITY for the Character BASE class. This
														 would mean that the Player could have permanent attack attribute immunity. 
														 
														 The way to make this work easily is to let the Character Class select basically
														 an entirely different PlayerTemplate. :) :) :) :) :)
														 
														 This would be MUCH MUCH MUCH BETTER than just specifying a couple bonus attributes.
														 
														 1) It would remove the Character Class Alteration from the Character Alteration
															that is supposed to be for all the Dynamic alteration data only.
															
														 2) It would provide lots more alternatives for starting with different options: 
															Equipment, Consumables, Stats, Attack Attributes, Immunities, etc...
															
														 3) IT WOULD PROVIDE A DIFFERENT CHARACTER SYMBOL :) :) :)
														 
														 This is EASILY accomplished by creating a list of PlayerTemplate instances per
														 scenario; and would share the Enemy UI for Attack Attribute Immunity.
														 
					- Altered State Immunity:  This should be similar to attack attribute immunity for the Character base. It would 
											   be part of the Enemy and Player (per class) design.
											   
											   Altered State Immunity:  Each Character gets a SINGLE immunity chosen from a list of
																		Altered States.
																		
											   Alterations:  Provide Passive and Temporary Alteration Effects to grant immunity
															
																- AlteredStateImmunityPassiveAlterationEffect
																
																- AlteredStateImmunityTemporaryAlterationEffect
																
															 These should be provided just for the Player to INVOKE. The Equipment
															 Effects COULD be granted to the Enemy like Auras but are not given as
															 Enemy Skills. 
															 
															 The innate Character immunity will grant the Enemy with ONE option for
															 this. Anything extra will have to be equipment.
															 
											   Character Class:  The Attack Attributes, Attack Attribute Immunities, and Altered State
															     Immunity need to be shown to the user when they're selecting a character.
																 
																 The base stats COULD be shown if it was not too much information.
																 
																 The immunities should probably be shown as part of the Attack Attribute
																 and Alteration UI's that are already there. (at least for now)
																 
																 IDEA:  Show the Character Class information as part of the Player UI
																		in the top-left. Will have to design it; and save space for it
																		somehow.
																		
																		Need to remove the Character Class entries from the Rogue
																		Encyclopedia. The reason is to force the User to try each 
																		one to see what they're about.																		
											
	- TODO: Player Invisible / Transmorgified:  when you attack an enemy, set the status of all enemies that SEE you to "IsAlerted".
												Remove the "WasAttackedByPlayer" and replace it with "IsAlerted".. And set it when
												you do something to attack an enemy for all enemies that SEE you.
												
												This should be RESET when you're out of SIGHT range (Light Radius in Line-of-Sight)
												from the Enemy's perspective. 
												
												It should allow them to track you when you're invisible and transmorgified.. (or
												whatever altered state is based on "CantBeSeenByEnemy")
												
	- TODO: Effect Range might need to be specified for several alteration effects
	
	- TODO: Modify Enemy Behavior Details to use Light Radius instead of Engage / Disengage Radius
	
	- IDEA / TODO:  Dealing with 17 different types of alteration effects is a little much for creating a UI. So, to handle 
					the Alteration list PLUS the Skill Tree - probably better to get a dual use out of the Views for each effect.
					
					So, if it doesn't look right working with the Alteration Effect Views in the Alteration List - then create
					2 sections in each Alteration Effect View - one to support "List Mode".. which can be added as a parameter.
					
	- TODO:  Calculated parameters for alterations need a way to prevent type inspection:
	
			 - Supports Blocking
			 - Cost Type
			 - etc...
			 
			 Probably, should consider adding Attributes to the class to provide these parameters.
			 
	- TODO: Forgot Equipment Equip Alteration Cost (HAVE TO ADD)
	
	- IDEA FORGOT:  For Blocking - Should consider having a Blocking Animation specifically for Alterations. This would alert
					the user that there was a block that happened.
					
					(The BlockAnimationGroup would be per Alteration Effect that supported blocking)
					
	- TODO: Probably remove support for all of the interface types from Equipment Damage Alteration Effect EXCEPT for Enemy and
			Consumable and (MAYBE) Doodad. 
			
			The problem is that it's ambiguous. The primary use is for an Enemy to damage the player's equipment. The next obvious
			use is for a consumable that will damage your Player's equipment. Then, MAYBE a Doodad that will do that same.
			
			The real problem is that you don't know what the enemy is wearing for equipment. So, it's really pretty pointless to 
			support unless the enemy equipment is shown on the screen (WHICH IT WON'T BE.)
			
			So, this is probably a good TODO. Doodad support could stay there; but would need to be sure to have SOURCE targeting
			ONLY for this effect type (FOR DOODADS) (if it's possible) (SAME FOR CONSUMABLES)
			
	- TODO: I know I wrote this down before...... But ... WE NEED TO REMOVE THE ENTIRE TEMPLATE CLASS SET FROM ROGUE.NET!
	
			Here's what I'd Like:
			
				- Sceanrio Assets are just the ordinary Scenario objects: Enemy, Player, Doodad, Consumable, Alteration, etc...
				  
				  BUT, WITH ADDED RANDOMIZER COMPONENTS FOR RANDOMIZING SPECIFIC PARAMETERS.
				  
				  Example:  Enemy (Scenario namespace)
							
							- double Strength 
							- double Agility
							- double Intellgience
							- ...
							- BehaviorDetails
								- Behaviors [] 
									- Skill
										- IAlterationEffect  (These types of burried parameters are problematic)
							
					(IDEA)	ParameterRandomizer  (Scenario namespace)
							
							- RogueBase Asset
							
							- string PropertyPath
							
							- double Variance
							
							
							ScenarioConfiguration  (Scenario namespace)
							
							- Enemy[] Enemies  				(Enemy Assets)
							- Doodad[] Doodads
							- ...
							- ParameterRandomizer[] Randomizers
														
							When the Enemy is generated - the Randomizers are involved - but some kind of
							property lookup would need to be invoked to randomize parameters.
							
							That might be fine; but NOT LIKED unless it could be validated somehow.
							
							Also, during game-play, random values are always drawn - especially for alterations.
							
							So, that would be extra-concerning. However, what COULD work is to create
							actual Randomizers built INTO the model that are instantiated - with the soul
							purpose of randomizing one parameter. 
							
							The obvious use-case would be for Alterations (which use their parent Template for
							randomizing each time).
							
							The main idea is to avoid creating a "Template" like class structure to do all the
							randomizing!! 
							
							So, the best way I can think of right now is to attach randomizer components somehow.
							
							AND, there may just be a way to do that WITHOUT using Reflection.. Which is really the
							only way I think I'd consider it because reflection is too buggy.
							
	- TODO: Just found "Key not present in Dictionary" for the CharacterLayoutInformation component.
	
			THIS MEANS:  There's a sequencing problem with the queues. The character had died but a calculation
					     was run for the character's aura locations. 
						 
						 The IModelService MUST UPDATE after EACH CHARACTER. So, what has to happen is like this:
						 
						 Player Attacks -> IModelService Updates -> Enemy 1 Attacks -> IModelService Updates -> ...
						 
						 AND: After each action - Enemies and ALL CONTENT MUST BE REMOVED BEFORE RUNNING THE UPDATE.
						 
						 This HAS to be done right or there'll be some unintended bugs.						
	
	- TODO: If there's room on the Skill Tree - (looks like there's a "quadrant" left to fill up...) Could show a large
			"Smiley" with the effect applied. :)
			
	- TODO: See if the Xceed WPF Toolkit TabControl has something with an ADD button by DEFAULT. Otherwise, find something
			that does. (Don't bother making a custom control)
			
	- TODO: Just re-iterating this idea. Reference-type objects that are shared in the scenario configuration are a big
			source of problems - mostly because the references have to be "Fixed" after mapping. And, doing anything other
			than creating a "tree structure" of an object graph begins to become a lot more work to maintain. 
			
			The ideal thing to do is to not have to worry about fixing references; and to have them work better with 
			serialization.
			
			The first step to dealing with serialization is to use something like Protobuf - to create a custom serialization
			routine that knows how to repair the object graph - with the purpose of sharing the data structure between two 
			different deserialization targets (basically, different "languages".. but this would be one for the model and one
			for the view-model which requires dependency objects).
			
			So, deserializing / mapping would be accomplished all at once - using a common routine. I'm pretty sure Protobuf
			provides something LIKE this; but I got upset trying to implement it.
			
			THE MODEL AND VIEW-MODEL MUST BE AUTO-GENERATED. AUTO-UPDATED. AUTO-VERSIONED. WITHOUT ANY EXTRA WORK. (USING CODE TEMPLATES)
			
			So, update source model -> auto-update model & auto-update view-model. Changing source model works well with
			versioning.
			
			AND - WE NEED DATABASE SUPPORT. To prevent data change issues. So, should there be a problem, the data can be
			maintained.
			
	- TODO: Create some Smiley Moods that help support different character classes
	
	- TODO: Consider buidling support for "Building" or "Creating" or "Making" or (some generic word) for making one item out of
			many. 
			
			- Consumable Type "Ingredient"
			- Equipment Type "Part"
			
			- Alteration "Make" or "Create" (or whatever word)
			
			This would support some more interesting characters like "Alchemist" or "Engineer" or .... or creating "The Ultimate Weapon".. etc...
			
	- TODO: Maybe change "Rogue.NET" to "Rogue Builder" (?) Needs a NON-MICROSOFT name...