- Outro Display (I Won! - Here's my stats!) (STATS TBD)
- Statistics Display (High Scores) (TBD)
- Reveal Image Transparency (TBD)
- HINTS (TBD)
- Layout Descriptions (To lend narrative to the story... "Evil Approaches..." .. "These are the blah blah blah of the evil blah blah blah"
- Categorize: Skills / Spells; Equipment; Consumables; Animations (TBD)

(BIG TBD's)
- Player Action: Can choose to block physical (strength based), or magical (intelligence based), or maybe even to "run away" by
- 				 granting you an extra portion of a turn. This would be instead of just attacking. (TBD)

- Several Validation Points: 
	- Scenario Editor: Dungeon Template Name - UNIQUE and SET and NO FILE-NON-FRIENDLY CHARACTERS
	- Scenario: Player Name SET and UNIQUE and NO FILE-NON-FRIENDLY CHARACTERS
	- Scenario Files: Player Name + Scenario Name.. or put something in the header to show the scenario name also
- Scenario Editor: Fix up the Symbol Alteration logic for the UI. have to represent it properly for flags set.
- Dungeon Wide Events:  Alteration or note-bearing event that fires at random; or once during a specific level range. 
						- Example:  "Corruption" Adds to your player's "Corruption" level every 10,000 steps.. ish
						- Example:  "Turn back while you still can!" (from the big enemy of the scenario) (creates monster)
						- Example:  "Send player back to stairs up" :)  after X number of steps (pretty mean!)
						
- Boost Bar:  An extra boost to alterations or attack. This could be filled: On Step; On Enemy Death; On Attack. So, player 
			  can choose when to use their boost bar to add to the attack.			 

- Alteration:  Teleport within visible range or within range of X or something where enemies teleport near to the player's visible range

- Multi-Level Teleportation: Coordinated using multi-level layouts
- Tertiary Behavior

- Balancing (Paladin) - Add "teleport near (within attack range)" to Hell Hound (TBD)
- Balancing (Paladin) - Add "teleport adjacent" to teleport options (TBD)

- Layout Refactoring:

	- Goals:  Support for:
				- Random Room layouts
				- Intersecting rooms 
				- Maze rooms
				- Room inside a rooms
				- Boss levels (symmetric / static-ish layouts)
				- Hidden pathways: either hidden hallways randomly; hidden paths off the grid; or hidden paths between rooms
				- multiple halls between rooms
				- Big rooms specified by a clickable grid of rooms (specify which rooms are "grouped" in the room grid)
				- Add teleporters to any layout type
				- Points of interest (allows placing objective or unique content on those points)
				- Symmetric layouts
				- Specific shapes for layouts (pentagram, square thing, etc..)
				- Challenge levels (alternate stairwell for a challenge level)
				- Room levels without doors
				- Cell Fill color
				- Linear layouts v.s. non-linear (linear => start to end without options)
				- temporary walls (can demolish by walking through)
				- Switches and push blocks! (would use to open a door or let down a wall.. YEAh!)
				- Cellular Automata (with connected rooms with parameterized hallway thickness)
				- Room "Growing" - Start with a room, create a door or hall with random length. Then iterate to create the next room
				  or rooms (maybe 2 or 3)
				  
				- "Antfarm" procedure that uses random hall splitting (recursive)
				- Identify 'main room' or "first" and "last" rooms. Create connected rooms by showing they're connected to a single room
				  via some other room. First and Last rooms may have the stairwells.. So, could generate sequential "problem" set by having
				  conditions for advancement (beat a monster, find a key, etc..)
				- Monster generation per level (parameter) also, party room parameter
				
				- POINTS OF INTEREST:  Doodads are important to scenarios. Having special points of interest can make it possible to arrange
									   content to suggest a narrative - which is what Rogue.NET is supposed to be about.
									   
									   Idea:  Have points along the wall designated as POIs. 
									   
									   Idea:  Have points near an entrance (on each side) designated as POIs. (Idea from Brogue Dar Blademasters)
									   
				- Level Tree:  Have the level generation be a tree to support probabilistically generated branches of the scenario. 
				
							   Idea: Could randomly choose a stairs down image to help make it more difficult for people to know where to go.
							   
							   Idea: Could have stairs-up be sealed off.. but would have to reconnect to the primary branch at some point.
				
- Windows: Would treat like an open door that you can't pass through.. (But maybe could break)
				
- Zones:   Related to level layouts. 

		   - Idea: This would combine level content and layout generation
		   
		   - Goal: To separate the layout into "Zones" that are sequential. Each would have an "Exit Condition"
		   
				   - Step on a switch
				   - Defeat (All, Some, One of "These") enemies
				   - Collect Content
				   - Find a key

		   - Design Problem:  Have to build a layout based on a sequence of zones
		   
				   - ISSUE: CAN'T PERMIT "PITFALL" TYPE EFFECTS BECAUSE THEY BREAK SEQUENCE
				   - Can only allow linear progress through zones. CAN GO BACKWARD (RANDOM LEVEL UP) BUT NOT FORWARD (RANDOM LEVEL DOWN or PITFALL)
		   
		   - Idea: Description of zone problem built into scenario level zone template. 
		   
				   - Describes what to do for exit condition ALONG WITH story-line!
				   
					 GREAT. IDEA.
					 
					 Would allow for something like: "You're in King William's prison in the castle in Britain. You must find a 
													  way out of your cell.. Perhaps there's a secret passage nearby..."
													  
													  for the Level 1 template for zone 1! VERY. COOL.
													  
				   - This would give a LOT of power to the scenario by not only allowing for progressive rewards; but also accrued
					 descriptive - and totally configurable - storyline! :) :) VERY. VERY. GOOD.
					 
		   - Idea: Have a "Check Mark" box to show completion of objective(s) for current Level->Zone.
		   
		   - Side Objectives:  
		   
				   - These would be configured on the Zone object to allow the player to find some kind of other hidden
					 room, passage, etc... But essentially use the same engine to create the objective that would be used
					 for linear progression.
					 
						- Examples:  Switched door, hidden passage, keyed door, hidden cache (treasure chest), hidden room, etc...
						
				   - These would be optional so don't require explanation (text)
				
		   - Exit Conditions:  HAVE TO BE ABLE TO GO BACKWARDS.
		   
				   - Switch:  Two state doodad, Riddle Doodad, Temporary event, Weighted doodad
				   
						- Two State Doodad:  ON or OFF - icon for each state
						- Riddle Doodad:     Set the dials on the doodad to create a word to solve the riddle
						- Weighted Doodad:   Stepping on this triggers a "Zone Event" - which may be a timed event
											 
											 Idea:  Could use weight of items to weigh down the switch. So, would need
													weight parameter. Problem with overlapping weight of enemy, or flying enemy, etc...
													
											 Idea:  Push, Pull a block to set on the switch.
											 
											 Idea:  Create a push / pull block problem to solve (like seen in many games) to advance
													to the next zone.
													
										     Idea:  Have switches that you must UN-weight in order to open the door (Example: pedestal)
													
				   - Defeat Enemy(ies):  Have to defeat a speific, all, or one of ____ enemies to advance
				   - Collect Item(s):    Have to collect specific items to advance

									     Idea:  Create special item room with a "pedestal" or point of interest for an item.
										 
										 Idea:  Create item "room" with points of interest.. (something similar)
										 
				   - Collect Key:   Hide the key somewhere to collect. 
				   
									- Generate in enemy inventory (MANDATORY)
									- Generate in level (MANDATORY)
									- Generate in treasure chest cache (MANDATORY)
									- Generate in special item room (MANDATORY)
									
		   - Reversable:  MUST BE ABLE TO GO BACKWARDS
		   
						  - For switched doors, have to have a switch on the other side (INCLUDES SIDE OBJECTIVES)
						  - For content related doors (enemies, items) have to leave the door open
						  
				  
				
- Recipes: New consumable type that blends other misc consumables to create a new one

- Animation refactoring:  Support for...

		- RANDOM SEED EACH ANIMATION (NO REPEATS!)

		- Fading Chain (chain lightning)
		- Earthquake! (shaking screen)
		- "Jumps" (Character jumps .. like a prelude to an "Earthquake" skill or something)
		- Other shapes (square, rectangle, some, other, enumerated, types)
		- Easing functions (Normal easing, plus things like "Pause and go" that make it come alive!)
		- More interesting animations (ease out, come back, etc...)
		- Better language to describe more complex animations
		- Slow animation speeds relative to animation time
		- Criss Cross animation
		- Tracers!
		- Spiral inward
		- Lightning
		- Screen Shaking
		- Gas Animation (Something like burning flames.. figure out how to "diffuse" them upward)
		- Gaseous Projectile - Diffuse Bubbles while travelling / Also Goo (maybe have a weight parameter)
		- "Dim the Lights" (Turns down screen brightness during animation)
		- Explosion Animation - Something like a "half dome" over a character
		- "Hold End" Parameter
		
- Water:  Player has a "Water Meter". Standing water could be a doodad to replenish your supply. Would need alterations to
		  support water replenishment.
		  
		  Also, have skills that depend on water. (use water to cast a spell, etc..)
		
- Alteration Effect: Push Back Enemies ("X" number of spaces).. Possibly on a "Wave" with animations (but that's tricky)

- Teleportation:  Add a standard animation for teleporting that shows the trajectory of the path to the new location.						

- Character classes:  Add class selection and set for equipment. Provide choice at the beginning of class.
					 (Defined in Scenario): Example: Elf, Dwarf, Employee, Wizard, Worlock, etc... These would
					 have equipment trade-offs, combat implications, and attribute bonuses.
					 
					 Equipment: Have different patameter sets per class. OR just a flag to say "Out of class" or "In class"
								to make it simpler.
								
					 Idea:  Chose race (elf, golem, etc...); chose attack attribute bonus to start with. Race could make you 
					 immune to certain altered states.					

					 Also, could spend points at start instead of being assigned attribute values. So, need more intelligence,
					 and agility combat consequences.

				     Altered States:  Certain classes are immune from certain states. Example: Stone Golem immune from stone..

					 Enemy Classes:   Could support combat adjustment from interacting character classes. Example:  Stone Golem
									  has a multiplier v.s. Wizard and Worlock classes. Or, a "Miss Ratio" multiplier.. But these
									  would be set up in the Scenario Editor.. 

									  Setup:  Character Class "Elf": (contains) ClassAttribute, List<ClassAttributeMelee>
											  
											  ClassAttribute:  Any Player Stat (Strength, Agility, ..., Attack, Defense, Miss Ratio, Dodge, Critical Hit, etc...)
															   with a bonus. This would show up as a Passive Alteration. The effect could be positive or negative.

											  ClassAttributeChange = ClassAttribute (modification) + EnemyClassName

														       The effect of this would be to modify the player's stat (determined by the ClassAttribute)
															   during Melee combat ONLY.

															   WOULD REALLY WANT TO SHOW PEOPLE WHAT WAS HAPPENING HERE. So, extra combat messages are 
															   preferred to show.

															   Example:  "Stone Golem" is immune to Altered State = "Stone". His class attribute is
																	     + 0.3 for Critical Hit.

																		 Against Wizard:		    Class Attribute = -5 Intelligence
																		 Against Elf:			    Class Attribute = -3 Agility
																		 Against Water Elemental:   Class Attribute = -10 Defense
									
																	     Message (Water Elemental):  Leviathan attacked Ryan
																									 HP = 43 + Attack Attributes...
																									 Bonus attack for Water Elemental = 32

					 
- Weapons "Gain Experience" from defeating enemies. So, they would "grow" with your character. 

- Weapons can have an Attack Alteration that will heal the player when attacking an enemy. This would likely be
  a new / separate / weapons only alteration applied immediately. Could include animations; but they would be applied
  after the alteration effects due to problems forwarding an attack alteration to the ISpellEngine.

- Enemy Alteration Effect on being hit: Example: "Jelly" divides into two when hit.

- Enemy "Alteration": Riddle.... Example: The riddle of the sphinx. Alteration Effect applied if answered incorrectly (?) or correctly(?)
				
					  OR!  Just a riddle from a doodad - have one incorrect and one correct answer.
					  
					  So, would want to support RIDDLES!!!
					  
- Add - Electricity symbols.. things for lightning!

- ISSUE - Have to use engage radius as enemy "light radius". PROBLEM: HAVE TO FIX PERFORMANCE ISSUE OF MULTIPLE LIGHT RADII USING
		  WPF OPACITY MASKS. PLANNING TO TRY PAINTING ALL TO A SINGLE BITMAP AND THEN APPLYING THE OPACITY MASK ONCE.
						  
-  Add - "Scenario Oracle" - just an endless identify doodad at the end of each scenario to show the total % complete in the stats.
							 (OR) Just identify everything the player has found.
						  
- (TBD) Fade-in for opening animation; and on opening level (Also fade out when player death)					

- Icon sets: This is for randomizing item glyphs. So, probably apply to just items; but support List<SymbolDetails> for the template ONLY.

			 - Design Problem:  How to pick a random symbol from the set but keep it consistent for the rest of the scenario.
			 
- Player Stat:  Miss Ratio - BASED ON AGILITY and Equipment "Out of Class" flag. 
				
				Idea:   This stat would be factored in during combat. It would also be available for alterations
				
				Class:  Flag for equipment saying "Out of class" means that the item isn't meant to be used for that 
						character (bigger idea was class selection .. but it's not part of the game yet)
						
						So, this flag says whether or not the player has trouble wielding the weapon or piece of equipment.
						
				Effect: A simple melee calculation adjustment to factor in Miss Ratio (or Miss %).
				
				Idea:   Need way to communicate this to the user. Either we have a class specification for the player 
						on startup; and use this to specify all equipment classes.. 
						
						Example:  Scenario classes:  "Heavy Fighter", "Ranger", "Archer", "Pyro Ranger", etc...
						
								  Equipment "Fire Axe":  In Class for "Pyro Ranger", "Heavy Fighter", but Out of class for
														 "Archer", and "Ranger".
														 
								  Message to Fighter -> Ranger (class):  Equipped "Fire Axe", "Miss Ratio" Stat altered by -0.2
								  
						Simple Example:  NO Extra Classes
						
										 Equipment "Wizard Staff": Marked "Out of class" for the Fighter. So Miss Ratio altered by -0.3
								  
- Equip Messages:  Show stat changes when equipping.								  

- Player Stat Points:  AT THE BEGINNING - ALLOW USER TO SETUP PLAYER STATS USING POINT SYSTEM.

- WPF RENDER REFACTORING:  PERFORMANCE IS A PROBLEM. WANT TO TRY DRAWING THE PATH DATA TO A BITMAP BEFORE RENDERING TO TRY AND 
						   SPEED UP PERFORMANCE. IF IT WORKS - THEN GO FOR THE NEXT LAYER WHICH IS THE OPACITY.
						   
- Equipment Explainations: Add section to show parameter changes by %.

- Equipment Quality Enhancement:  Alteration to enhance quality value for equipment! Need to separate armor types
								  and weapon types just like for Enchant and Imbue.

								  Example:  Sharpening Stone - Upgrades Quality for weapons by 0.3! :)

								  Example:  Anvil - (would need ImageResources) Upgrades Quality for Armor by 0.3! :) :)

								  Name:  Maybe "Upgrade Weapon" and "Upgrade Armor"

- Player "Aura" Refactoring:  Several things...
		
		1) Separate Auras from Light Radius

		2) Use Aura Effect Range to create new aura on top of the light radius. 

		3) Choose whether to change Light Color or to apply Aura on top of Light Circle (OR JUST SHOW AURA DURING USE)

		4) Show effect range in the Alterations screen.

		Effectively this should separate the two and show them independently
						  
- PLAYER DEATH R.I.P. TOMBSTONE (ALSO  PERMADEATH)

- Agility:  Want to support "Miss Ratio" character stat - which has to be factored into the calculation. So,
			need better understanding or model for the asymptotic parts using Agility so that player can
			progress and balancing is more interesting.

- Enemy List:  Similar to enemy scope; but is a list of enemys just during combat. Shows all enemies in visible range
			   and their relevant attributes - (Mostly progress Health bar would be the best).

			   Several Ideas...

			   Idea:  Only show health meter until "Knowledge" of this enemy is increased

					  - Maybe, increase using a ratio or function of enemy / player intelligence
					  - Increase based on defeating many of the same enemies
					  - Possibly increase based on alteration (NOT LIKELY)

			   Idea:  Show in the dialog window using a split window during combat

			   Idea:  Show the last hit as first in the list. So, do an insert at the top for the last
					  enemy hit.

			   Idea:  Show this meter over the head of each enemy (similar to a live action game)

					  LIKE THIS IDEA:  It saves lots of room; and would be simple if included as part of
									   a custom framework element for each enemy. Just create a framework 
									   element; and set the progress bar's render transform to offset it 
									   "above their heads".

- Refactor "SpellTemplate" to "AlterationTemplate"

- Fix calculations in Scenario Difficulty Service for attack attibute melee.

- Refactoring:  Alteration -> Mental Alteration, Physical Alteration, Equipment Alteration, etc...
							  Trying to figure out best way to break up that class into smaller parts.

				- When Refactoring: Create another level of abstraction to add other parts to a "Spell", or "Skill",
									or "Special Effect".. including animations, display text, etc... So that it makes sense
									in terms of parameters.

- Equipment Balancing:  Some new parameters to consider. These could be mostly calculated; but flags or support from
						Equipment items need to be considered.

						- Miss %:  Calculated based on character strength, agility, class, etc...
						- Quality: Change this to "Attack Value" or "Power" - And calculate based on
								   strength, agility, intelligence, character level, speed, etc... (possibly with flag support)
								   ("Grows with Level") - Power = Quality * Level.
								   ("Grows with Enemies Slain") - Power = Quality * Enemies Slain.

						Alterations could accompany the new parameters. Example:  "Sharpening Stone" improves base quality
						instead of attack attribute.

- Alteration Effect:  "Reactive Temporary/Passive"	Applies Attribute change as a counter attack. And "Attack Attribute Reactive Temporary/Passive"
					  That applies counter attack attribute attack.

- Equipment Quality Changing Alterations:  Class Change / Quality Change + plus or - minus. Example (sharpening Stone) + 0.1 to quality. Or skill of	
											enemy changes quality -0.3 (stone golem or something chips your blade). So, new alteration types required:
											   
											- Decrease Weapon Quality:  Alteration used as skill by enemy (or player) to degrade character equipped weapon
																		quality.
																		  
											- Decrease Armor Quality:  (similar)
											   
											- De-Enchant Weapon:  Alteration to degrade equipped weapon class (used by enemy or player as skill).
										   
											- De-Enchant Armor:   (similar)
											   
											- Increase Weapon Quality:  Alteration used by Player ONLY to upgrade any weapon's quality (using UI to select)
											   
											- Increase Armor Quality:  (similar)

- Noise dynamic attribute:  Can have noise level.. Noise can be generated by walking, or fighting. Items can have a noise
							multiplier or contribution.. Can also add to alteration effect (noise dampening). Noise
							would have the effect of engaging enemies from a radius determined by the noise level. It could
							also give away your location if you're invisible.

							**Could also have the calculation based on how quickly you make moves - (i.e. the time between
							  moves). Would be kind of neat :)

- Strength Requirement for Equipment (PROBABLY JUST USE HAUL)

- Contraptions:  Consumables that can set up a doodad in the level. 

- Doodad Effect:  Have it automatically hit all enemies without having to target.  Also, want to support "Everyone in Range"
				  and "Everyone except source in Range"
				  
				  ANOTHER EFFECT:  ATTRACTS ENEMIES (NEED ANOTHER CHARACTER STATE CALLED "AGGREVATED" TO HAVE AN EFFECT ON
				  ENEMIES AND MAYBE ALSO PLAYER.
				  
- Enemy Behavior:  Want to expand on current behaviors and starting positions. Would like to support groups or hordes of 
				   enemies. Also, want to employ a tertiary behavior.. Considering having them do something on each turn 
				   besides wait for the player.. Brogue has them Wander -> Sleep -> Hunt.
				   
				   - Idea: Support a dynamic list of behaviors - with one default (being attack player). This list acts as
						   a state machine - with conditions for the state to be active.
						   
						   - Condition:  Turn counter (internal to Behavior) is less than 10 (resets with each state change)
						   
						   - Condition:  Character stat is above / below some threshold
						   
						   - Condition:  Character is able to perform attack action (skill cost is met)
						   
				   - So, the enemy's behavior could roll-over from one to the next for as many as they've been configured with. Also,
				     the default behavior would catch if the rest of them feel through.
				   
				   - Idea: Add "Randomizer" to the behavior set. This would perform the function of selecting one behavior at
						   random every "X" number of turns.
						   
				   Also, want to better support Standoffish behavior by adding a parameter to specify the number of cells to
				   "stand off" before attacking. Then, create a new movement type called "Runs and Hides".

- Doodad:  Timed fire doodad. Triggered by character movement in range.

- Alteration Effect:  Sanctuary... Needs design :)  
- Alteration Effect:  Telepathy... Brogue ripoff :( But lots of fun! :)
- Alteration Effect:  True Polymorph (random enemy)

- Brogue Idea:  Searching.. can have search timers for objects near player. Doodads / hidden doors. Basically, implement above
				Brogue-style search without the "timed event". Really like how that plays.
				
- Brogue Idea:  Self-Identify.. One major problem in Rogue.NET and other rogue likes is the number / amount / variety of different
				items that are important to the story. Brogue lets you self-identify over a number of turns. I'd like to turn this
				up a notch and have items become more important and have more levels of depth (where appropriate).
				
				Many ideas... Have a static / dynamic number of "levels of depth" for each equipment item - allowing for identified traits at
				each level (big design problem here).  
				
					Example:  "This is a short steel sword" (Level 0 Description)
					
							  "This is a short steel sword that belonged to someone of the British Empire. It appears to be 
							   high quality" (Level 1 Description)
							   
							  "This is King William's personal guardian sword. It has this magical property" (Level 2 Description)
							  
					Example (Consumable):  "The scroll appears to have a red wax seal" (Level 0)
					
										   "The scroll has a gentle aura of goodness about it" (Level 1)
										   
										   "The scroll casts a spell of Healing" (Level 2)
				
				Progressing from one level to the next could just take a number of turns. Also, USING the item or piece of equipment 
				should expedite the speed at which it progresses to become fully identified. (And, of course, you could find consumables
				or doodads that do this as an alteration)
				
- Keys:  Consider getting rid of modifiers for doors / fighting.
				   
----------------------------
						  
- Add - Scenario details to Open screen
- Add - MP Low behavior
- Add - Message when saving game
- Add - Messages for spell alterations (melee messages)

- Change - Maze level "Dim Gray" to something brighter or colored (Firebrick Red)
- Change - Zealot skeleton animation to single blink

- ISSUE - "Standoffish" Can't calculate path to run away or open obstacles like doors
- ISSUE - Have to put in safety checks for completely filled level (Get Random Cell will crash)
- ISSUE - Teleporting enemies are still shown. Can see their new location
- ISSUE - Fix door issue (not opening; but open.. can't see through)
- ISSUE - "Blink" animations reveal the level size. Should turn those into blink for the full screen
- ISSUE - Uncurse pre-condition not calculated. Allowed casting of alteration (item grid). Also, "back" button on dialog was visible
- ISSUE - Pitfall STILL VISIBLE
- ISSUE - Need way to systematize placing level content (on the backend). So, probably best to have the IModelService place ANY contents
		  So that it can always check for free cells to place content on. If there's no cell available - need to decide how to proceed.. may
		  be that the content is objective and therefore has to be placed.
- ISSUE - See Invisible isn't working.
- ISSUE - Reveal isn't showing invisible enemies
			  
- Fix - Skill learning didn't work when player learned skill AFTER required level
- Fix - Multi-use consumables not updated after use
- Fix - Problem with Blindness - didn't recalculate enemy visibility immediately
- Fix - Zealots didn't move around
- Fix - Enemy opens door - trigger topology change (something went wrong.. didn't show door opened)
- Fix - Apply limits to MP (negative value on Lynx evaporate MP)
- Fix - Update player symbol when activating skill (should be done on turn)
- Fix - Add Attack Attribute melee message to player spell and enemy spell (meleetarget)
- Fix - Spiral Target with constant velocity animation caused crash "Trying to calculate const velocity for spiral animation"
- Fix - "Vile Mother has used 'Create Vile' on"
- Fix - Identify for non-class items should identify all future non-class items with the same RogueName
- Fix - Identify All isn't updating the Encyclopedia view
- Fix - Wraith's drain experience doesn't knock player down a level (need this one for item / equipment / skill requirements)
						
- Balancing (Paladin) - Add some skills for learning: Disciple, Satanic Priest, maybe one or two other.. but EViL! >_<

--------------

IMMEDIATE TODO'S:

	- Clear out message box when re-starting.

	- Use points to increase stats instead of randomly doing it when gaining a level.
	
		- SMALL REFACTORING:  Create a few different types of level commands:  Normal; 
							  View Action Command; Imbue Equipment Command; Player Advancement Command.
							  
							  Need to expand this some to include actions with new data.  This is mainly
							  for new dialogs with other data fed back to the backend.
							  
	- Nice to have:  Explain attack attributes by having a separate UI to show how they apply
---------------
		
	- PERMADEATH
	- Dependencies:  Take the algorithm from Traingle.NET and remove code
	- Dependencies:  Look for source for Dotaway - OR just write:  a desaturation algorithm; and a pixelation algorithm.
	- FIRST BIG TODO:  Refactor Animation targeting type to handle physical cases:
	
					   Problem:  There's an un-written "coupling" between animations and alterations. Example is "Run Away"
								 which affects the source character only (as an alteration). Choosing "Target to Source" animation
								 type can cause a crash or issue because they don't relate.
								 
					   Solution: Force animation type selection to work with physical content and alteration calculating. An example
								 would be calculating some kind of "range". It's usual for an animation to have some kind of range 
								 associated with it; but it relies on the considered targets. 
								 
							     So, "Targets in range" would become something like "Calculated Alteration Targets". If you tried
								 to apply this to "Source.RunAway" then you'd have the following:  
								 
								 - Calulate Affected Characters => Source (enemy)
								 - Calulate Altertion Targets => Source (enemy)
								 - Apply Animation: No animation applied because there is no target apart from source
								 
					   Other Solution:  Add specific parameters to the animation related to the calculation. Example: Range parameter.
								 
					   Main Idea: If this can be accomplished without refactoring then it should be validated that any animation 
								  support be verified before hand so that you don't have issues in game. 
	
	- NEXT BIG TODO:  Figure out a way to calculate combat value for items based on player parameters (Level, Strength, Agility, Intelligence)
	- OTHER BIG TODO:  Redo enemy behavior
	- OTHER BIG TODO:  Make pathfinding algorithm more efficient.
	- OTHER OTHER BIG TODO:  Terrain
	- TODO: Path-finding efficiency (need to learn about heuristics)
	- TODO: Fix up the simulator for equipment attack / defense values based on attributes; and anything else that has changed.
	- TODO: Generate Alterations right away (don't store the template on the item / enemy behavior). To randomize add a component
			to do this with some variance (gaussian distributed or whatever) around the base (mean) instead.
			
			If this works out without too much trouble - repeat this EVERYWHERE. Just get rid of RANGE values and use a randomizer!
			This will simplify the hell out of everything.
			
	- TODO: Remove the level range specification from all assets. Add a list of level specifications: each has a list of consumables,
			equipment, enemies, doodads, a layout, etc.. and generation rates, variances, etc... This would virtually eliminate the
			need for templates; but would introduce a new class of components to place / specify / randomize everything. This class
			should be MUCH smaller than the currently supported scenario configuration. 
			
	- TODO: Remove list sharing for all asset properties. Example:  Consumable.Alteration should not reference a list of alterations. Also,
			apply to attack attributes, character classes, altered state, etc... Create them in the asset UI - but show a list of what
			currently is in the scenario - with option to copy one that's already there. Then, in the "General" section, just show an
			aggregate of all of these "shared" asset properties to show what they are. Then, for meta-data, create these lists on-the-flying
			as these asset properties are generated. Example:  Create first "Poison" Attack Attribute. Event Aggregator fires the event
			and another component maintains the collection of meta-data for attack attributes. 
			
	- IDEA: To keep / maintain shared collections - use attributes for the class to identify the location of it's "master list". This will
			help avoid maintainence issues for the many "Fix Reference" methods.... Uuugh.
			
	- TODO: Clean up "engines" and systematize. Componentize things a little better; and make it known how messages are being published.
	
	- TODO: Propagate the name of the Alteration template to the corresponding Alteration Effect template.
	
	- IDEA: "Interlude" for the scenario - Fade-in message on-screen after Level "X" to show a part of the story.
	
	- IDEA: Friendly unit type. (Easier that it sounds probably). 
	
			- Friendly derived Character type
			- Add check for Player movement so that you can swap places with Friendly units to avoid obstructing your path
			- Add targeting type for Alterations to select unit type (Example:  Heal all friendly units in range, or Heal Player type units)
			
			- Then, it should be very easy to support a Necromancer scenario :)
			
	- IDEA: Undo Service. This is a difficult problem I think in most any editor program. I tried building a stack-based Undo function using
			the INotifyPropertyChanged and INotifyCollectionChanged mechanism in WPF. I think it mostly worked; but there are some nagging
			issues with event coverage because I feel like we're missing some of the events that should be forwarded and kept by the Undo Service.
			
			So, my design idea goes like this:  
			
				   Get a handle on binary serialization - to where we can represent the data as a binary "Blob" and changes to the data 
				   as SMALL "Deltas" - with some change description. 
				   
				   Example:  ModelChange { Data[], int Offset, int Length, string ChangeType, string ChangeDescription }
				   
				   So, the entire "Blob" of changes should represent the data model - just a serialized version of it that we can use
				   to provide an Undo Service. 
				   
				   Synchronizing the Undo "Blob" and the actual model is the only major worry.. but if there's a way to do this with the
				   actual model - that would be even more idea. I'm just not sure how that might work.
				   
			Thinking about it some more...
			
				   The major problem with this design (like the current design.. or any other design) is synchronization of two versions
				   of the same data model. I don't like it..
				   
				   So, a better way to do this: Create a custom serialization service
				   
						- Serializes all public properties using Reflection
						
						- Creates a custom serializer for each property type
						
						- Validates that all public properties have a serializer (or throws an exception)
						
						- Underlying binary format chosen by the serializer - with the main "Blob" being a simple byte[]. 
						
						- The Primary object graph is serialized with a CUSTOM METHOD. This is important to 
						  deal with reference checking. 
						  
						  An example of a serialization service that works ONLY FOR TREES (non-cyclical object graphs) is
						  PROTOBUF!  Which I don't think they tell you... but you have to build your own custom routine 
						  using their pseudo-language. 
						  
						  This is essentially what I'd build here - except with direct control over the byte[] in a way to
						  be able to insert, add, or remove changes.
						  
						  Example:  ScenarioConfigurationContainer has a ISerializationService implementation with a methods
									called ISerializationService.Serialize.  Then, there'd be support for changes to the model
									that needs to be worked out.. Maybe using some kind of attribute mechanism.. but I think it
									would have to be specific to the model structure. 
									
									Maybe, [SerializationUpdateAttribute( Some.. Properties.. to.. Specify.. Update )] for each
									type (or public property)
									
						  However, I believe that the INotifyPropertyChanged / INotifyCollectionChanged events would still be 
						  used - just with a different listener - which would be the ISerializationService. This service would
						  probably then notify the Undo service with some change description which would (of course) be compatible
						  with the serialization service.
						  
				   SHOULD THIS BE SUCCESSFUL:  I'd use this for the primary model serializer.. and any other serialization we do.. 
											   even just as an experiment to work with primitive data serialization more closely
											   and to understand better the crux of the problem.
											   
											   Dealing with cyclical object graphs is a trickier problem which I'd think is out of
											   scope.. but if I felt confident in trying - it might be worth the effort to learn
											   a little more from reading or research because this problem is fundamental and I don't
											   see it done properly anywhere .. EVER.. usually.. but the tree-object-graph is simple
											   and this one is done well.
											   
    - TODO: Validate that the AlterationContainer.RogueName (GETS COPIED TO) IAlterationEffect.RogueName. Add validation rule.
	
	- TODO: Must have "Normal" Altered State (Somehow...) Not sure how to do this one.. But it needs to be done because the boolean 
			flags to control "HasAlteredState" have been removed in favor of a default "Normal" state.
			
	- TODO: Build Enum-to-Radio-Button-with-attribute-description control to handle choosing an enum for the editor
			
	- IDEA: If there's want to do this for the Sorcerer - have different targeting "types" for moving the targeting cursor around manually.
			
				- In Visible Range: Could teleport yourself OR ANOTHER CHARACTER from one place to another in your visible range.
				
				- In Explored / Revealed Range: Could teleport yourself OR ANOTHER CHARACTER from any explored / revealed location to another.
				
				- In Range of Player "Special Reveal":  This would temporarily reveal a certain distance from your player to accomplish
														the same task of teleporting yourself or an enemy. 
														
				- Have to avoid obstacles:  Cursor should blink "Red" if you can't move there. 
				
				- ANOTHER IDEA:  "Force Enemy Back" pushes enemy in line of sight backwards into Wall / Another Enemy. Would be nice
								 to animate this - maybe kind of like "Clay-mation" (cell, cell, cell, BAM!) Or something else.. Would
								 damage all characters involved.
								 
				(The next two could support the "Doom Sorcerer")
				
				- INSTANT DEATH:  "Abolish Enemy to the Void" some kind of alteration based on character attributes.. maybe intelligence,
								  uniqueness, or some other thing that instantly kills the character.
								  
				- "CONDEMNED":  Event that goes like this:  Character 1 casts alteration on Character 2 that starts a timer (if it's not blocked). 
								The timer should be shown somewhere so that the user knows that either they're going to die or their enemy
								is going to die.
								
								The way to defeat it is to 1) Have a remedy for the temporary event alteration or 2) to defeat the other character :)
						  
	- TODO: Use either Routed Attached Event or ServiceLocator -> EventAggregator to supply changes for Undo instead of INotifyPropertyChanged. Also,
			have to Hook new complex types in UndoAccumulator when they're changed. 
			
			THIS MIGHT BE A VERY SIMPLE UNDO SERVICE
			
	- IDEA: Could support "Detect Magic"
	
			- Design Problem: Purpose of "Detect Magic" is to reveal / identify (in your inventory AND on the map) things that are "Bad" or "Good". 
			
							  1) What does it mean to be "Bad" or "Good". Either calculate a value based on the alteration OR just
								 add a flag to the Alteration and have the scenario editor set it. (probably that way)
								 
							  2) Then, why stop there? Create some kind of categorization of Alterations (or Alteration Effects) that
								 carries several uses:
								 
									- Bad or Good? (Detec "Magic")
									
									- Type / Category:  
									
											 This is a "Dark Magic" Alteration (Used for identification to supply Blocking Alteration Effect)
									
											 (Also thought of an Amplification Alteration.. but that's tricky)
											 
											 Example:  "Amplify Dark Magic" - would target specific parameters to "Amplify" by some multiplier
											 
											 Probably:  Blocking is the best use I can think of for grouping by "Type". Because, it would allow
														a 100% block (immunity) for specific Alteration Effects.
														
														"Osiris casts Condemn" .. "Blocked by Player's Amulet"

									So, design would be Alteration -> Effect -> [Effect MetaData] { Category, Alignment }

									And, if we wanted to support blocking:  Alteration -> Block Alteration Category Effect

									Then, "Detect Magic" would be "Detect Alteration Alignment" (effect). But, there could also
									be "Detect Black Magic" would be "Detect Alteration Category".
														
									*** Attack Attributes:  Why not identify attack attributes using something like "reveal" or "Detect Fire".
									
									THIS ONE IS A GOOD ONE TO DESIGN WITH:  
									
										Problem:  Can't know anything about Attack Attributes without looking at the Enemy in depth or
												  having some sort of UI show the user. 
												  
												  This prevents Attack Attributes from being know in a way that makes them important.
												  
										Solution: Besides using the UI to show them; why not add something like "Detect Fire" to show
												  a fire symbol on the map where an alteration effect, or innate attack attribute sits?
												  
										Also:     Like "Detect Magic", it could affect your inventory to identify attack attributes - both
												  innate ones; and alteration effects (which still need a UI)
									
									
	
	- TODO: Attack Attribute Refactoring
			
			1) REMOVE SHARED COLLECTION FROM SCENARIO CONFIGURATION
			
			2) Create Attack Attribute collections sparsely - using a service to provide a scenario-wide collection to COPY from
			   to create an instance for the asset or alteration effect
			   
			3) Shrink the UI for editing them to one-line; and add an option to show / hide the attack, resistance, and weakness appropriately
			
			4) FOR THE SCENARIO SIDE:  Either A) Leave the design AS IS and pre-copy FULL LISTS of attributes to each asset / alteration effect
										   or B) Work with sparse collections and re-design how they're used to accomodate differing sets
										   
	- TODO: Finish Alteration Effect UI
			
			- Fix up controls and fit them to the design area
			
			- MOVING BRUSHES TO NON-SHARED ASSET:  Put Brush Editor on the Animation Editor (Nothing else for now...)
			
			- REMOVE STROKE TEMPLATE
			
			- Verify that stale data doesn't stay in display when switching assets
			
			- Create one of each new Alteration effect type for the Sorcerer scenario
			
			- Validate Alteration Effects for some of the low-hanging fruits; and don't go overboard
			
			- FIX UP THE ASSET REFERENCE SERVICE
			
			- Add Default Implementation Type for IAlterationEffectTemplateViewModel.. Probably instantiate the null values in the 
			  Scenario Configuration Mapper when fixing references... OR where the source null values are instantiated (commented code)
			  in the mapper using reflection.. Not necessary though because any developer can figure out what's happening and there'safety
			  no crash in the UI for an unset alteration effect. It's just bothersome to work with.
			  
    - THOUGHT:  Using Protobuf to deal with serialization might be a good idea. Basically, it would be better to have a single 
				source for the model than two. I believe Protobuf can generate code based on its "source (custom) language". Also,
				I think it deals with serialization - and I'd like that to be handled in a single place.. If it was language
				agnostic serialization that would be IDEAL. 
				
				Protobuf treats object graphs like trees by default; but I think you can customize the "source code" for the 
				object graph to have shared instances. 
				
				If this isn't possible - it would be a fun exercise to try and build something like this from scratch; and to be able to
				handle some of the primary design issues for the Scenario Configuration:
				
					- Mapping:  Going from one namespace to the other seamlessly
					
					- Serialization: Being able to serialize the MODEL independent of the "target language" (either Model or ViewModel)
					
					- Versioning: Handling changes to the model without fear of loosing data
					
					- Code Generation:  Generating "target languages" - probably based on a text-based template:  one for the model namespace
										and one for the view-model namespace that took care of inheritance from DependencyObject, Interface 
										implementations, etc, etc...
										
					- Database Backup:  Going from the "source language" to a database schema seamlessly would be very nice.
										
				THESE WOULD BE GREAT THINGS TO HAVE.
				
	- TODO: Make Rogue.NET playable with only the mouse
	
	- TODO: Want probability parameter on the Equipment Attack Atleration.
	
	- TODO: Type-Specific tooltip for IAlterationEffect. This will help show all the wonderful / different effects of items. Also, can reuse
			the UI in other places:  Skill Tree, and Rogue Encyclopedia
			
	- TODO: Provide Brush-Copy service that provides list of all brushes in the scenario to copy from - with a preview image (add to brush editor)
	
	- TODO: Provide asset navigation from Construction -> Assets. Also, make the Construction re-load on click.
	
	- TODO: Immunity Alteration Effect - Makes you immune to a specific altered state.	
										
	- TODO: Skill / Reveal UI (clean up)
	
	- TODO: 
				- Haul Usage:  WHEN HAUL IS EXCEEDED - PLAYER MUST DROP SOMETHING TO PROCEED. This should be used when enemies drain strength from
							   player.
							   
				- Animations:  Validate parameters so they don't cause in-game error message
				
				- Modify Equipment:  Implement enemy alteration on player as EQUIPPED ONLY.
				
				- Gremlin (Fighter Scenario): Change teleport to "Blink" inside player visible range (it's super annoying :))
				
	- TODO: Hide the Scenario Seed and randomize it by default
			
	- TBD:  If the scenarios need to be randomized for items (the symbol color) - might consider refactoring the images:
	
			1) Use SVG vector graphics
			
			2) Find a default coloring that works with HUE shifts to create the various colors (or) build some kind of 
			   rotating color filter that can handle creating something like primary -> secondary -> tertiary colors from
			   maybe a set of mask colors that can be used to create the base SVG.
			   
			3) Using a color filter - apply to create symbol changes instead of the parameterized one that's there. That
			   would save a lot of time / parameter space.
			   
			4) Find a way to convert symbols into SVG's - should reduce the resource set by a factor of 10.
			
			5) Consider creating a subset of UTF-8 as a vector image set to show / size into cell containers. Problem is
			   that some symbols get cut off - so would want to resize to fit. (Probably could do this by measuring the
			   TextBlock first also)
			   
	- TODO:  Attack Attribute Refactoring:
	
				1) REMOVE SHARED ATTACK ATTRIBUTE COLLECTION FROM SCENARIO CONFIGURATION AND SCENARIO.
				
				2) Use sparse attack attributes; but create some centralized methods to apply them
				
				3) Simplify Alteration Effects by using SINGLE attack attributes for some; but breaking up the class into
				   several use cases:
				   
					- Attack Attribute:  (A, R, W)
					- Attack Attribute Positive Change:  (A, R, W) -> (+, +, -)
					- Attack Attribute Negative Change:  (A, R, W) -> (-, -, +)
					
				4) Provide services for supplying the full attack attribute list
				
	- TODO: Deal with proper nouns. Probably can do this using a flag on the enemy. "Use Proper Noun" (when addressing enemy)
	
	- TODO: HasAlteredState flag for each temporary
	
	- TODO: Enemy Light Radius - HAS BEEN MOVED TO CHARACTER BASED
			
			- NEXT:  Design behavior around Light Radius (Engage / Disengage) - (not necessarily around this parameter)
			
			- Then:  Enemy Targeting - Skill behavior around light radius
			
			- Then:  Line-of-sight per character - calculated on turn.
			
			- Then:  Enemy / Doodad as light source :)
			
			After that - decide how to do targeting:
			
				- Player "target what you can see?"
						 "miss if out of range?"
						 "miss probability?"
						 "miss probability per alteration effect?"
				
				- Enemy  "target what you can see?"
					     "engage if illuminated?"
						 "engage if you can HEAR?"
						 
			The idea is just to enhance the API - but to keep it INTUITIVE. So, if it makes sense to do
			then do it. Right now it's calculated all based on the Player visible range; but that can
			change if the light-of-sight calculation isn't too intensive.
			
			If it is - then just use the enemy light radius in calculations.
	
	- TODO: Refactor End-Of-Turn logic.
	
			- This generally needs to be systematized. It's all out of sorts - and there's no sequencing. It should
			  be pretty easy and straight forward to do.
			  
	- TODO: Refactor Front-end logic some to remove ambiguity about updating player v.s. enemy (just do characters)
			
			Also, have a single enumeration (or method) to run an update per character (unless processing gets too slow);
			but mostly to handle updating everything about a character without ambiguity.
			
			Example:  Apply an alteration. RogueUpdateEvent(AffectedCharacter.Id, Enum.SomeSpecificProperty [Flags])
					  Can handle the update. 
					  
					  The problem is that the symbols for the characters are handled when they move around. This needs
					  to be decoupled.
					  
					  If necessary - add a simple front-end controller to handle "Update for a character"
					  
					  IContentUpdateController
					  
						- UpdateSymbol(CharacterBase.Id)
						- UpdateEquipment(CharacterBase.Id)
						- UpdateAlterations(CharacterBase.Id)
						- Remove(CharacterBase.Id)
						- Add(Character)
						
					  Also, break up and componentize LevelCanvasViewModel - which basically is a collection of ScenarioImage
					  elements - to be drawn / updated somewhere else; and collected by the IContentUpdateController.
					  
	- TODO: Make sure to apply "Generate on step" to enemies
	
	- TODO: Make throwing generic - not pre-specified:
	
			1) Every item has a base throw effect - something like (Strength * [Throw Quality])
			   AND something to deal with accuracy - maybe (function(Strength, Agility, and maybe [Throw Accuracy]))
			   
			   Probably want a couple parameters for the item so that it makes sense.. Can't do much
			   damage throwing armor; but you could try...  (it won't help to be strong)
			   
			2) Player can try throwing any item; AND it's only consumed when it strikes the enemy 
			   (like DOS Rogue or Brogue)
			   
			3) If there's ever time to do the per-step-identify (Identify items in levels based on 
			   a) how long you have them (by type) and b) if you're using them, etc...) Then, this
			   could be a part of that. (IdentifyParameter class to specify how it all happens. One
			   per effect to identify)
			   
			4) For any special effects - they'd have to be added to the item. So, that could be done
			   on the base class so that the player could try throwing equipment. 
			   
			That's pretty much all; but the idea is to try different things instead of being guided
			by the throw effect that's already there on the consumable.
			
	- TODO: Skill Alteration UI: Fix up Block Type, Animation Opacity Binding (all alterations), Visibility for
			Aura Source parameters.
			
	- TODO: Fix overlapping characters - seeing a problem using "Blink" and create monster (near the player).
	
	- TODO: Restrict Equipment Attack Alteration to One / Two handed melee weapons
	
	- TODO: Create Drain [Parameter] Equipment Attack Atleration Effect. Basically, Drain HP; but make a different
			class to support it. Apply ONLY as an Equipment Attack Atleration.
			
	- TODO: Set Attack Attribute Collections EN-MAS for any new asset. FIX EXISTING ASSETS (Asset Reference Service)
			   
	- TODO: Consider systematizing part of the alteration effect pattern to consolidate some of the type inspection.
	
	- TODO: Finish alteration sub-panel by showing what aura effects do - and effects of enemy equipment auras.
	
	DECIDED TO CREATE A COMPONENT FOR STORING GRID-LEVEL INFORMATION ABOUT LINE-OF-SIGHT / LIGHT RADIUS / AURA RADII
	
		Assumptions:       Player Type (currently) is treated as a light SOURCE; "Light Radius" really means "Sight Radius" (TODO - Refactor).
						   Auras are independent of "Light Radius" and light SOURCES.
						
						   Any character (or object) COULD be marked as a "Light Source"; but that's not currently supported. It
						   would be nice to have light sources in the scenario.. Possibly even on the walls (like a flag on each
						   cell to be accounted for on this component).
						
		How to Calculate:  What's this for? This will calculate all characters' line-of-sight: locations; objects (enemies, doodads, items);
						   Light "radius" locations; and aura radius locations for all alterations. PER CHARACTER.
						   
						   The state should be stored here; but not serialized. 
	
		Input:  		   Any Character
		
		Calculations:      Line-of-sight, Light Radius, Aura Radius (per aura)
		
		Output:   		   Line-of-sight:        Locations
						   Light Radius:  		 Locations
						   Aura (many):          Locations, Colors
						   
		Future TBD: 	   The point of this component is to start to consolidate some of the grid-related scenario data that 
						   needs to be calculated and stored. 
						   
						   There's lots of ideas of what to do in the future if there's time. One would be to create more light 
						   sources - which is pretty straight forward given this design. Another could be cell coloring or opacity
						   based on many different character's auras, light source (maybe colors), etc.. Then, line-of-sight 
						   is probably more important - as it could change some of the possible actions of the characters.
						   
						   Example: Enemy is far away; but in a lit-up tile (another object's light radius). You could try and
									throw / fire something at the enemy; but have a small % of success. 
									
									More imporantly - you could see the enemy.
									
						   Another idea is to have patches of lit up tiles as part of the layout. This would be to simulate light
						   coming in through the ceiling. (varying per level)
						   
						   One final one - requiring more design - is TERRAIN :) :) :)  Water, Fire, Swamp, Steam, Anything Brouge
						   tried - but only if there's others helping because it's a lot to do.
						   
						   Light sources, auras, and line-of-sight would probably be enough for this guy.
						 
	- TODO: Draw a Diagram of the Backend Processing.
	
				- Start with the ScenarioService - drawing pointers for each method entry into the engines.
				
				- Show the flow of events onto the ScenarioService queues.
				
				- Show the updating of the UI from events.
				
			Need to know how the backend is updated - specifically:
			
				- Character stats
				
				- Layout (Topology and visibility and line-of-sight)
				
				- Character Visibility (Same component)
				
				- Item / Object Visibility (And Revealed / Explored status)
				
			So, need to understand the sequence of events surrounding specific actions to be able to be
			confindent systematizing the backend end-of-turn logic.
			
			IDEA:  Hide the Level object inside the IModelService (or something like that component) and
				   prevent firing of events to the queues where possible.
				   
				   It would be easier to think of if the update events were encapsulated into components;
				   and the major data containers were also encapsulated with those components - so updating
				   the front end and queuing up other events was much more intuitive.
				   
			NEEDS TODO:  It's getting a little too involved to keep queuing events for the back end. The
						 processing needs to be refactored to make it easier to manage the state (IModelService)
						 sequentially.
						 
						 IDEA:  SEQUENCE all character activities. This could be accomplished with some other
								simple queue architecture that allowed sequences (maybe per character) to be
								processed before continuing with other sequences.
								
								Example:  Player Reveal Item -> Animation, Consumable Item Remove, Revealed Content, 
									      UI Updates -> Enemy 1 Reaction (.., .., ..) -> Enemy 2 Reaction -> (.., .., ..)
										  
										  What this means is that the queues could provide a sequence for these 
										  actions. 
										  
										  BUT - there's a big problem with updating the state. Model updates have
										  to be injected where they're important.. maybe between characters. 
										  
										  Player -> Model update -> Enemy 1 -> Model Update -> ...
										  
										  There might be a better way; but trying to sequence all of these things
										  at the "End of Turn" really doesn't work right.
										  
										  I'm thinking it should be more like this:
										  
										  Player -> Player End of Turn -> Model update -> Check for Scenario Event (Player Died, etc..)
										   -> Enemy 1 -> Enemy 1 end of turn -> Model update -> Check for Scenario Event (Player Died, etc..)
						   
										  So, as long as the processing isn't too involved - it might be easier just
										  to check "everything" or "everything per character" (which includes bigger
										  events like player death, or level change, or maybe dialog events) between
										  queued reactions.
										  
										  Then, one final primary concern is when to update the UI. Animations should
										  take the highest priority; but UI updates I'd think should also be done 
										  between characters. And, the Update types probably should be thinned out and
										  just refactored.
										  
										  The LevelCanvasViewModel is also too crowded and needs refactoring. 
										  
										  The design favoring a front-end controller would be ideal for processing 
										  updates PER-CHARACTER. So, if this new queueing design is implemented - 
										  it might be a good idea to try and work with the front end to break up
										  some of that junk that's collected to update view models.
										  
	- IDEA:  Have an enemy behavior condition that "helps them when they're lagging behind the player". Maybe like 
			 the hippogrif in the socerer scenario casts "gather" when they're lagging behind. or teleport near player.
			 
			 Also, TELEPORT ADJACENT PLAYER would be a nice-to-have effect enum.
			 
	- NOTE:  Aura support for enemies was to deal with equipment auras that would be applied to enemy equipment.
	
	- IDEA:  Split up level canvas into several layers to deal with z-index; and to break up the collections to store
			 the ui elements.
			 
				- Each layer is associated with a separate view-model type (LevelCanvasImageViewModel, LevelCanvasAuraViewModel, 
																			LevelCanvasLightRadiusViewModel, ...)
																			
				- Collection of view-models is bound to a layer in the view (maybe ItemsControl)
				
				- The collection of collections is known to a UI controller (somewhere) to handle updating
				
	- TODO:  Fix enemy / player aura removal:  steal item, un-equipment
			
		     Fix enemy / player aura application:  enemy doesn't show unless they react. player doesn't show at all.
			 
	- IDEA:  AURA / LIGHT RADIUS RENDERING:  Thinking that the performance issue may have been about dealing with the
										     level layout PATH FIGURES - using software rendering (not sure what that means) - 
											 so that probably means that all of those figures had to be calculated in when
											 applying the opacity mask.
											 
											 So, since the brush for the light radius is [LEVEL WIDTH, LEVEL HEIGHT], it probably
											 was doing much more than it had to. 
											 
											 I'm GUESSING that could be solved in a couple ways:
											 
											 1) making an "Outlined Path Geometry" for the layout cells - which may clump
												together all of those stream geometry strokes. I'm not convinced that the
												stream geometry is any faster in this particular case.
												
											 2) Make the "light radius" or "aura" size constant based on the number of cells
												in the radius (light radius = 5) or aura. 
												
												This would make the size of the rectangle boundary constant so that the 
												brush wouldn't change shape as a character approached the wall.
												
											 Then, the last question is whether or not applying the opacity mask to the container
											 object for the layer (ItemsControl or Canvas) is performing better than applying
											 it to the individual aura / light radius.
											 
											 (I'M GUESSING IT HELPS).. But, i'm not doing any benchmarking. So, just a matter
											 of avoiding the performance problem.. Which was something like: 40 zombies with 40
											 auras at once.. That was like several seconds between steps.. maybe like 5-10 seconds
											 to render each step.
											 
	- TODO: Front end is updating on each step (DrawContent).. Already needs fixing to deal with a controller.. so will have to
			make this granular again.
			
	- TODO: Break down "Food Usage Per Turn" UI to show contributions per type (Alteration, Haul)
	
	- IDEA: Consider getting rid of Dodge, Mental Block, and Critical hit statistics. (And the related alteration parameters).
	
			Instead: Have a new alteration that BLOCKS ALL (something).. to replace an alteration that boosts your "Mental Block %"
			
			Also:    Go ahead and calculate blocking behind-the-scenes; and show it as a % of success somewhat like Brogue on
					 a mouse-over. Do the same for Dodge, and Critical hit.
					 
			Also:    Need to calculate a Miss %. So, there's things to do for character interactions.
			
			Then:    Maybe would want to show some of the calculated parameters for changing equipment; and possibly active skills.
			
	- IDEA: Maybe change HP -> Health; and MP -> (something like) Stamina (but it's for skills / alterations that require stamina)
	
	- IDEA: Maybe try some proof-of-concept scenarios for some of the weirder support that Rogue.NET provides. Maybe, have a game
			centered around "keeping the lights on" - where everything you do affects your light radius (?) Maybe even simple attacks
			(using weapons with attack alterations).
			
			Other things to make it interesting... ? (too many to count) How about multiple stair-wells? Or, challenge levels (?) 
			(an alternate stairwell with a single room and no other way down after that) 
			
			I like - PUZZLES~! Pretty sure there's a lot of ways to do that; but anything working with the level to solve a puzzle
			would be really really phenomenal:  Hidden passages, locked-rooms-with-one-key outside the room, locked-rooms-with-enemy
			guards; button sequences (stand on one, stand on another, don't mess up - or you will be in "danger" (enemies, etc..))
			
	- TODO: Explain attack attributes in terms of % difference between two values:
	
			Example: Equipment shows % + or - change when worn or removed. 
			
			PROBLEM: Have a dependence on Attack and Resistence for a change in the value.
			
					 [F(A, R, W = 0) - F(A, R + e, W = 0)] / F(A, R, W = 0) = 1 - [(A + R) / (A + R + e)]
					 
					 So, if A = R = 5 and e = 1, dF / F = 1 / 11. 
					 
					     if A = R = 10 and e = 1, dF / F = 1 / 21.
			
					 That means the % difference is dependent on A and R. That's a problem for 
					 showing to users because you can't factor out A.
					 
					 So, what if the resistance was based on a simple rational function just
					 of R. The output of F(R) would be [0,1) (for all R >= 0). Similarly, the Weakness function
					 would just be a simple function G(W) that doesn't depend on A either. So,
					 The total attack value is:
					 
					 Attack Value = A * [F(R) + G(W)] 
					 
					 Where:
					 
					 Resistence = Arctan(R) (maybe 2/pi * arctan(R))
					 
					 But, it won't actually work. Because, that would say you're "Adding on a % of resistance" - which
					 only works relative to A. 
					 
					 So, FOR SHOWING THE USERS how effective their equipment and alterations are at defending or
					 attacking based on attack attributes - the number they see will have to suffice. 
					 
					 BUT, it will have to show you what's happening for those attributes so that you know (DURING COMBAT).
					 
					 And, the method that's being used now is really perfect for attack attributes because it gives
					 you a ratio of 1/2 for R=A.. which guarantees A always wins (which it should) (same with strength)..
					 but having this kind of calculation will be the best for every type of attack attribute related
					 effect. 
					 
					 So, probably, the UI will have to be easy to intuit for these - whether it be a log, or an enemy
					 HP meter with "the last hit shown (in terms of attack attributes", or some visual queue when there's
					 an attack being made with them (maybe). But, they have to be considered to know easily.
					
	TODO: GET RID OF Range<T>.HighLimit and Range<T>.LowLimit from the class - and move to the UI only.
	
	TODO: Make (most) Attack Attribute properties "single-attribute".  
	
		  Example:  Equipment Attack Attributes - Probably won't ever use more than one at a time - espeically because
					there's a lot of equipment! (two rings, a belt, shoulders, an orb, an amulet, etc... etc... So, 
					probably want the "innate" attack attribute for the equipment to either
					
					1) Go away (in favor of the attack alteration)
					
					(or)

					2) Go to a single attribute (each equipment item just gets one)
					
		  I'd think probably along these lines for changing this:
		  
			- Enemies get a full list 
			
			- Equipment innate properties go to ONE attribute - with the addition of another ONE attribute for each Alteration
			  (Attack, Equip, Curse)
			  
			- All other alteration effects go to just ONE attribute
			
			- Character class also goes to a SINGLE attribute.
			
		  Then, change Rogue.NET to deal with sparse collections of attack attributes:
		  
		  Example:  For Enemies, the editor should add on to a list of attack attributes - allowing just a SINGLE INSTANCE per
					NAME of attack attribute. 
					
					The editor should provide a dropdown list of current attribute to select from to prevent creating new ones
					with the same name; and to copy over the name / symbol for each one to create a new instance for the enemy.
					
					The editor should provide a way to create a new attribute NOT in the dropdown to add to the scenario 
					(calculated) collection. This can be modified RIGHT THERE; but once it's done - the attribute will NOT be
					allowed to be modified - just DELETED. The primary scenario list will be managed by probably the 
					ScenarioEditorModule using Events.
					
	- TODO: Problems with "Magic Block", "Criticl Hit" and "Dodge" as a probability. 
					
			1) Too many "things" to fuss with for the user. (And for the UI).. But, primarily, these don't do enough to show you
			   that they're important. 
			   
			2) Using different forms of balancing (Attack Attributes, Character Class, Base Attributes, and Altered States) the
			   user would want to know when / how to BLOCK, DODGE, or CRITICALLY HIT based on those.
			   
			3) The calculated [ Hit, Miss, Dodge, Critical Hit ] could be based on base attributes [Strength, Intelligence, Agility]
			   but, most likely, kept more like simple PHYSICAL combat [ Hit, Miss, Dodge, Critical Hit* ]
			   
		    One of the PRIMARY problems designing a "Magical" Character (like the Sorcerer) - was dealing with Intelligence-based 
			combat using weapons.
			
			This problem was solved by introducing an attribute parameter that specifies the base attribute to use in the 
			calculation. 
			
			BUT, that doesn't deal with other things like [ Hit, Miss, Dodge, Critical Hit ]. These really should probably be 
			calculated BEHIND-THE-SCENES; but not shown to the user unless it can be done without confusing them. Brogue does
			a pretty good job of this with their "interaction dialog" describing what "could happen" when they attack.
			
			Here's what I think COULD happen for doing blocking in a bigger way to include some of the other things like 
			[ Attack Attributes, Character Class, and Altered States ]
			
				1) BLOCKING AN ALTERATION should be based on a) The switch on the Alteration (Physical / Mental) (CHANGE TO
				   BASE ATTRIBUTE [ Strength, Agility, Intelligence ]; and the base attributes. 
				   
				   The current calculation uses a trancendental function (Arctan) to come up with probability based on 
				   the RATIO of the attributes: P = F(Enemy Attribute, Player Attribute) = C * Arctan( f(E / P) ).. which
				   will provide a number between [0, 1].
				   
				   This should work fine; but we don't want to over-display this probability.. Just maybe show when it's
				   useful to show and not overwhelming. (Something like the Brogue mouse-over for enemies would be fine)
				   
				   FINALLY, Blocking an Alteration NEEDS TO BE SHOWN. The Animation NEEDS TO PLAY Before blocking. A blocking
				   animation WOULD BE NICE (As an addition on the Alteration). (I LIKE THIS IDEA). But, it's not necessary 
				   so long as the user understands what happened.
				   
				   The in-game log is a little to much to parse continually to know what's going on. Probably better to remove
				   it in favor of an intuitive UI that shows the enemies actions (like a list of enemies with their HP meter
				   and maybe something about their last action.. like an Alteration or Attack Attributes used or Critical hit)
				   
				2) CRITICAL HIT should be moved because it's not based on an innate character attribute. It should be removed
				   from alterations and put directly on the EQUIPMENT item. 

				   This would make it an innate property of the equipment - which is a lot easier to think about from the user's
				   perspective.
				   
				   So, the Equipment item would have a CRITICAL HIT %. 
				   
				   The Equipment Attack Alteration COULD have a boost for this; but it's really not necessary. 
				   
				3) [ Hit, Miss, Dodge ] based on character base attributes [ Strength , Agility, Intelligence ].
				
					BUT, HOW? 
					
					For Attribute based Melee - keep the hit calculation based on the attribute.
					
					Example:  "Sorcerer's Staff" - (Based on Intelligence) v.s. "Worlock's Magic Armor" (Based on Intelligence)
					
						      Attack = F(Intellgience, Staff Quality, Staff Class) v.s. Defense = F(Intelligence, Armor Quality, Armor Class)

						      Hit = Attack - Defense (clipped to zero)
							  
							  Miss % = ???
							  
							  Dodge % = ???
							  
					Those will remain % based on base attributes. 
					
						Miss = Function ( ??? ) 

					Brogue would make this based on what's difficult for the character to use. Like, "my strength determines my Miss %".
					
					That might be fine - so long as the UI makes it apparent and SIMPLE to understand. 
					
					So, probably 
					
						Miss = Function ( Strength / Item Weight ) 
						
					Miss % could be based on just the ratio of the character's strength to the item weight. This DOES NOT DEPEND
					ON the character's Agility OR the Enemy's Agility.
					
					WHICH DECOUPLES IT from any other parameters - which means it can be displayed in the UI in the equipment 
					list. (with the equipment details)
					
					The Dodge % should remain based on the ratio of character agility:
					
						Dodge = Function ( Player Agility / Enemy Agility )
						
					So, Miss does NOT depend (or is NOT COUPLED) to Dodge. THIS IS GOOD. It would cause a problem showing, displaying,
					and otherwise confusing the player.
					
					Miss still needs to be implemented.
					
				4) Would like to introduce IMMUNITY in several possible ways:
				
					- Attack Attribute Immunity:  Easiest approach to implement would be a flag on the attack attribute. DON'T DO IT 
												  THIS WAY! It would overlap parameters and is not a good idea. EXISTING ALTERATIONS
												  USE ATTACK ATTRIBUTES IN A CERTAIN WAY - AND IT WOULD NOT BE A GOOD IDEA TO ADD
												  FUNCTIONALITY TO THOSE.												  
												  
												  INSTEAD:  Move Attack Attribute Immunity to a SEPARATE set of Alterations.
												  
															- AttackAttributeTemporaryImmunityAlterationEffect
															
															- AttackAttributePassiveImmunityAlterationEffect
															
												  FOR ENEMIES:  Since they don't have an innate property for this - go ahead and 
																give them one for PERMANENT IMMUNITY.
																
															- Enemy:  List< AttackAttributeImmunity >
															
																The UI might have to be set up to show both the attack attribute 
																collection AND the immunity collection together. (which is tricky
																but that UI is already overcrowded.. so a refactoring to do this
																might be ok)
																
																BUT, the attack attribute and attack attribute immunity collections
																should be SEPARATE. 
																
																Combining them would be too confusing to keep straight.
																
																(ONE MORE THING) Adding an enum option to the Combat Type (Friendly,
																Malign, Immunity) is NOT a good idea because of overlapping uses.
																	
																We don't want an Aura of immunity. Maybe in the future; but NOT NOW.
															
												  ALSO:  (Just thought of this) Character Class is supposed to provide things like
														 this idea because it would work well to balance the scenario.
														 
														 So, would like to do PERMANENT IMMUNITY for the Character BASE class. This
														 would mean that the Player could have permanent attack attribute immunity. 
														 
														 The way to make this work easily is to let the Character Class select basically
														 an entirely different PlayerTemplate. :) :) :) :) :)
														 
														 This would be MUCH MUCH MUCH BETTER than just specifying a couple bonus attributes.
														 
														 1) It would remove the Character Class Alteration from the Character Alteration
															that is supposed to be for all the Dynamic alteration data only.
															
														 2) It would provide lots more alternatives for starting with different options: 
															Equipment, Consumables, Stats, Attack Attributes, Immunities, etc...
															
														 3) IT WOULD PROVIDE A DIFFERENT CHARACTER SYMBOL :) :) :)
														 
														 This is EASILY accomplished by creating a list of PlayerTemplate instances per
														 scenario; and would share the Enemy UI for Attack Attribute Immunity.
														 
					- Altered State Immunity:  This should be similar to attack attribute immunity for the Character base. It would 
											   be part of the Enemy and Player (per class) design.
											   
											   Altered State Immunity:  Each Character gets a SINGLE immunity chosen from a list of
																		Altered States.
																		
											   Alterations:  Provide Passive and Temporary Alteration Effects to grant immunity
															
																- AlteredStateImmunityPassiveAlterationEffect
																
																- AlteredStateImmunityTemporaryAlterationEffect
																
															 These should be provided just for the Player to INVOKE. The Equipment
															 Effects COULD be granted to the Enemy like Auras but are not given as
															 Enemy Skills. 
															 
															 The innate Character immunity will grant the Enemy with ONE option for
															 this. Anything extra will have to be equipment.
															 
											   Character Class:  The Attack Attributes, Attack Attribute Immunities, and Altered State
															     Immunity need to be shown to the user when they're selecting a character.
																 
																 The base stats COULD be shown if it was not too much information.
																 
																 The immunities should probably be shown as part of the Attack Attribute
																 and Alteration UI's that are already there. (at least for now)
																 
																 IDEA:  Show the Character Class information as part of the Player UI
																		in the top-left. Will have to design it; and save space for it
																		somehow.
																		
																		Need to remove the Character Class entries from the Rogue
																		Encyclopedia. The reason is to force the User to try each 
																		one to see what they're about.																		
											
	- TODO: Player Invisible / Transmorgified:  when you attack an enemy, set the status of all enemies that SEE you to "IsAlerted".
												Remove the "WasAttackedByPlayer" and replace it with "IsAlerted".. And set it when
												you do something to attack an enemy for all enemies that SEE you.
												
												This should be RESET when you're out of SIGHT range (Light Radius in Line-of-Sight)
												from the Enemy's perspective. 
												
												It should allow them to track you when you're invisible and transmorgified.. (or
												whatever altered state is based on "CantBeSeenByEnemy")
												
	- TODO: Effect Range might need to be specified for several alteration effects
	
	- TODO: Modify Enemy Behavior Details to use Light Radius instead of Engage / Disengage Radius
	
	- IDEA / TODO:  Dealing with 17 different types of alteration effects is a little much for creating a UI. So, to handle 
					the Alteration list PLUS the Skill Tree - probably better to get a dual use out of the Views for each effect.
					
					So, if it doesn't look right working with the Alteration Effect Views in the Alteration List - then create
					2 sections in each Alteration Effect View - one to support "List Mode".. which can be added as a parameter.
					
	- TODO:  Calculated parameters for alterations need a way to prevent type inspection:
	
			 - Supports Blocking
			 - Cost Type
			 - etc...
			 
			 Probably, should consider adding Attributes to the class to provide these parameters.
			 
	- TODO: Forgot Equipment Equip Alteration Cost (HAVE TO ADD)
	
	- IDEA FORGOT:  For Blocking - Should consider having a Blocking Animation specifically for Alterations. This would alert
					the user that there was a block that happened.
					
					(The BlockAnimationGroup would be per Alteration Effect that supported blocking)
					
	- TODO: Probably remove support for all of the interface types from Equipment Damage Alteration Effect EXCEPT for Enemy and
			Consumable and (MAYBE) Doodad. 
			
			The problem is that it's ambiguous. The primary use is for an Enemy to damage the player's equipment. The next obvious
			use is for a consumable that will damage your Player's equipment. Then, MAYBE a Doodad that will do that same.
			
			The real problem is that you don't know what the enemy is wearing for equipment. So, it's really pretty pointless to 
			support unless the enemy equipment is shown on the screen (WHICH IT WON'T BE.)
			
			So, this is probably a good TODO. Doodad support could stay there; but would need to be sure to have SOURCE targeting
			ONLY for this effect type (FOR DOODADS) (if it's possible) (SAME FOR CONSUMABLES)
			
	- TODO: I know I wrote this down before...... But ... WE NEED TO REMOVE THE ENTIRE TEMPLATE CLASS SET FROM ROGUE.NET!
	
			Here's what I'd Like:
			
				- Sceanrio Assets are just the ordinary Scenario objects: Enemy, Player, Doodad, Consumable, Alteration, etc...
				  
				  BUT, WITH ADDED RANDOMIZER COMPONENTS FOR RANDOMIZING SPECIFIC PARAMETERS.
				  
				  Example:  Enemy (Scenario namespace)
							
							- double Strength 
							- double Agility
							- double Intellgience
							- ...
							- BehaviorDetails
								- Behaviors [] 
									- Skill
										- IAlterationEffect  (These types of burried parameters are problematic)
							
					(IDEA)	ParameterRandomizer  (Scenario namespace)
							
							- RogueBase Asset
							
							- string PropertyPath
							
							- double Variance
							
							
							ScenarioConfiguration  (Scenario namespace)
							
							- Enemy[] Enemies  				(Enemy Assets)
							- Doodad[] Doodads
							- ...
							- ParameterRandomizer[] Randomizers
														
							When the Enemy is generated - the Randomizers are involved - but some kind of
							property lookup would need to be invoked to randomize parameters.
							
							That might be fine; but NOT LIKED unless it could be validated somehow.
							
							Also, during game-play, random values are always drawn - especially for alterations.
							
							So, that would be extra-concerning. However, what COULD work is to create
							actual Randomizers built INTO the model that are instantiated - with the soul
							purpose of randomizing one parameter. 
							
							The obvious use-case would be for Alterations (which use their parent Template for
							randomizing each time).
							
							The main idea is to avoid creating a "Template" like class structure to do all the
							randomizing!! 
							
							So, the best way I can think of right now is to attach randomizer components somehow.
							
							AND, there may just be a way to do that WITHOUT using Reflection.. Which is really the
							only way I think I'd consider it because reflection is too buggy.
							
	- TODO: Just found "Key not present in Dictionary" for the CharacterLayoutInformation component.
	
			THIS MEANS:  There's a sequencing problem with the queues. The character had died but a calculation
					     was run for the character's aura locations. 
						 
						 The IModelService MUST UPDATE after EACH CHARACTER. So, what has to happen is like this:
						 
						 Player Attacks -> IModelService Updates -> Enemy 1 Attacks -> IModelService Updates -> ...
						 
						 AND: After each action - Enemies and ALL CONTENT MUST BE REMOVED BEFORE RUNNING THE UPDATE.
						 
						 This HAS to be done right or there'll be some unintended bugs.	

			UPDATE: Fixed the bug - but still need to refactor the queueing
	
	- TODO: If there's room on the Skill Tree - (looks like there's a "quadrant" left to fill up...) Could show a large
			"Smiley" with the effect applied. :)
			
	- TODO: See if the Xceed WPF Toolkit TabControl has something with an ADD button by DEFAULT. Otherwise, find something
			that does. (Don't bother making a custom control)
			
	- TODO: Just re-iterating this idea. Reference-type objects that are shared in the scenario configuration are a big
			source of problems - mostly because the references have to be "Fixed" after mapping. And, doing anything other
			than creating a "tree structure" of an object graph begins to become a lot more work to maintain. 
			
			The ideal thing to do is to not have to worry about fixing references; and to have them work better with 
			serialization.
			
			The first step to dealing with serialization is to use something like Protobuf - to create a custom serialization
			routine that knows how to repair the object graph - with the purpose of sharing the data structure between two 
			different deserialization targets (basically, different "languages".. but this would be one for the model and one
			for the view-model which requires dependency objects).
			
			So, deserializing / mapping would be accomplished all at once - using a common routine. I'm pretty sure Protobuf
			provides something LIKE this; but I got upset trying to implement it.
			
			THE MODEL AND VIEW-MODEL MUST BE AUTO-GENERATED. AUTO-UPDATED. AUTO-VERSIONED. WITHOUT ANY EXTRA WORK. (USING CODE TEMPLATES)
			
			So, update source model -> auto-update model & auto-update view-model. Changing source model works well with
			versioning.
			
			AND - WE NEED DATABASE SUPPORT. To prevent data change issues. So, should there be a problem, the data can be
			maintained.
			
	- TODO: Create some Smiley Moods that help support different character classes. Maybe, LeftWink, RightWink, Emoji >_<, 
			Frustrated, Gleeful, whatever can be done.. probably change the enum to SmileyExpression, and clean up the control
			to make it symmetric; and to scale the line thickness automatically. 
			
			Would be nice to do that with the Radius also, and keep the aspect ratio to the cell width x cell height. So, very
			easy to scale and fewer parameters.
	
	- TODO: Consider buidling support for "Building" or "Creating" or "Making" or (some generic word) for making one item out of
			many. 
			
			- Consumable Type "Ingredient"
			- Equipment Type "Part"
			
			- Alteration "Make" or "Create" (or whatever word)
			
			This would support some more interesting characters like "Alchemist" or "Engineer" or .... or creating "The Ultimate Weapon".. etc...
			
	- TODO: Maybe change "Rogue.NET" to "Rogue Builder" (?) Needs a NON-MICROSOFT name...
	
	- TOOD: Think the Hippogrif create monster was the cause of the aura location crash (model service). but, still need long
			term fix of creating full-proof queue.
			
	- TODO: There's a fundamental issue dealing with the design of the Template (Base) -> RogueBase.
	
			The Template.Name property is typically thought of as the unique identifier FOR THE TEMPLATE. So, when using
			the template as a generator for some of the content - DURING GAMEPLAY - the uniqueness isn't accounted for other
			than by Template.Name.
			
			EXAMPLE 1: Alteration Effect - is unique up to Alteration.Name (which is propagated to) AlterationEffect.Name when
					   saving in the editor. (THIS NEEDS TO BE FIXED)
					   
					   These templates are stored in the Scenario namespace during gameplay and resolved when instantiating
					   the actual IAlterationEffect - which has a RogueBase.Name property == Template.Name.
					   
			EXAMPLE 2: Items saved in the Player / Enemy inventory are resolved by Template.Name before they're saved on the
					   editor side. The references to the primary list of assets are fixed as part of mapping the configuraiton.
					   
					   This really should be fixed (by serialization first); but also probably by Template.Id. The Name property
					   COULD be unique - BUT IT SHOULD NOT BE A REQUIREMENT.
					   
			EXAMPLE 3: Enemies for "Create Monster" are referenced by string to the Tempalte.Name. 
			
					   I essentially gave up trying to make this more constrained because of dealing with the Id; and reference
					   matching during serialization.
					   
					   While it was more intuitive to match by the Template.Name property - it was another constraint that shouldn't
					   be there. 
					   
			EXAMPLE 4: Recipe Alteration Effect has lists of items that are referenced by Template.Name. so, the same issue here.
			
			
			Problem 1: Reference "matching" shouldn't have to happen when deserializing. The mapping component for the serializer
					   needs to be removed and replaced with something like Protobuf - which has a single source for the data 
					   deserialization - and maps to any number of targets using it's templates (like a wpf-view-model-template and
					   a poco-template).
					   
					   If I can't get THAT to work - THEN, I'M GOING TO BUILD IT MYSELF!!! It's too much work to deal with all of
					   each namespace and serialization issues EACH TIME!
					   
		    Problem 2: Referencing the primary lists of assets COULD be done easily if serialization were fixed. 
			
					   However, there's the problem of updating dangling references for leaf objects when a primary asset is removed.
					   
					   An obvious example is enemy inventory (remove an item from the primary consumable list) - must update the
					   enemy inventory list to remove it.
					   
					   Would be nice to do this without code; but if it came to it - probably a simple attribute mechanism to do some
					   event listening could auto-update the list.
					   
			Problem 3: The Template.Id - MUST BE A UNIQUE IDENTIFIER - For the TYPE of asset (or asset effect, or branch asset, or 
					   anything deriving from Template) in the game.
					   
					   So, the Template.Id property could be used to carry an identifier for a Template somewhere else in either the
					   editor namespace or the scenario namespace. 
					   
					   This isn't currently working because of these issues; but IS NEEDS TO.
					
	- TODO: When Haul > Haul Max - don't allow character to move. 
	
			AND:  When there's no room to drop anything, go ahead and allow multiple drops per space. (but, prefer an empty one)
			
	- TODO: Transmute Skill - Basically, a skill to develop that is a random transmutation of selected items...
	
			- IDEA:  So, it goes like this:
			
					 - Transmute "Tries" to create a product; but has a set of weighted products that are 
					   selected from.
					   
					 - INPUT: A selected set of items
					 
					 - OUTPUT: A SINGLE item selected at random from a list
					 
					 How do you know what to do? Hmmm...
					 
					 Well, you'd need some kind of a hint. 
					 
					 - "Transmute Potion":  Applied to an item - creates a "better potion"
					 
					 Maybe, if you add "other things" to the list of INPUTS, you get a better product (?)
					 
			- AS IT DEVELOPS:  It sounds like development of this skill would depend on having a classification
							   of "what makes better".
							   
							   I'd force this classification to be parameterized on the Alteration Effect class.
							   
							       - Create some sort of "vector" of classification:
								   
										Transmute Item:
										
											- Name   ProductItem
											- Name[] RequiredItems											
											- Weighting
											- Intelligence [or base attribute] Requirement
											- Level Requirement
											
										Transmute Classification:
										
											- Transmute Item[] Vector;
											- Transmute Item   DefaultItem;										
										
									- So, the chosen product would be a random draw from the weighted products; and
									  the weightings would have to be chosen so that it made sense WHAT would be 
									  drawn at a higher level.
									  
									  (If you have 10 items with equal weighting - the higher level ones wouldn't
									   take precedence when they're discovered.. so, up to the developer)									   
									 
									  
			- WHAT ABOUT WEIRD STUFF?:  It would be fun to have "random things" pop out of the transmute effect.
			
								So, here's our data model...
			
								Transmute Effect:
								
									Transmute Classification:
									
										- Transmute Item[] Vector;
										- Transmute Item   DefaultItem;
										* Hash [Name, Name] Direct Products;
										
								The Hash table "Direct Products" behaves like "If you put this SPECIFIC thing in, Then you get this SPECIFIC thing out".							
								
								When there's multiple items with a "Direct Product" - choose one at random. This
								would cover some corner cases like "I put my unique super item in the effect and
								got this weird rock"								
								
			- APPLICATIONS:  Witch potion brewing; Fighter equipment crafting; etc.. etc.. etc.. etc..
			
			- EXAMPLE:  Witch Transmute Potion:
			
						- Transmute Item 1:  Input: healing herbs, Output: a bat's wing (useless),  Level 0, Intelligence 4
						- Transmute Item 2:  Input: healing herbs, Output: A mana potion, 			Level 0, Intelligence 4
						- Transmute Item 3:  Input: healing herbs, Output: A major healing potion,  Level 1, Intelligence 5
						...
						
						- Transmute Item 10: Inputs: healing herbs, torch oil, sulfur powder, empty vial, Output: Imbue Fire Ointment, Level 15, Intelligence 10
						
						...
						
						The sky is the limit; and you can have things that blow up on you.. maybe some "bad ingredients" or
						"you're not intelligent enough to try this yet and it will fail" .. but there are a MILLION ways to 
						make this fun. And, you won't really ever know if you got it right. 
						
						You could also leave NOTES around the map to find hints on this too... Lots of ideas.
						
						And, it relieves the burden of input ingredients for a recipe because it's sort of different than that
						in a way that will be more of a "skill".
						
			- ONE CONSTRAINT:  The Default Item should probably not be there. If you don't have at least one Transmute Item 
							   selected because of requirements (inputs or player stats), then you probably should just have
							   it fail and not do anything.
							   
			- ONE OTHER ISSUE: People might get upset if they transmute some important item. So, you might want to have a flag
							   on the item base to protect it from trasmutation - which would mean you can't transmute it at all.
							   
							   One obvious one is for Scenario Objective Items; but those are already known. 
							   
							   This might not be necessary; but it might be nice to have for people.
							   
			- UPDATE:  Removing the Level and Intellgience [attribute] requirement from the alteration effect because it's too
					   complex for an Alteration Effect - and also it's part of the Skill design.
						
	- TODO: SERIALIZATION PROBLEM:	
	
			Haven't yet had self referential loops in the mapper. 
			
			One scenario where this COULD happen is if an Alteration has a reference to an Asset. This WOULD have been "Create Monster"
			but that ended up being a string.. And, I think there actually may have been a problem where this caused a stack overflow.
			
			The Agile Mapper was used to try and solve a problem like this earlier on.. and I remember seeing something about self-referencing 
			loops in the XML comments; but was never satisfied with how it worked. Probalby something with configuring it.
			
			SOLVING THIS PROBLEM: I THINK - relies on storing a hash of object references. The first time an object is encountered its
								  reference is stored in the hash to retrieve later as a subtitute for iterating a second, third, .. , nth reference.
								  
			I'd like to try implementing this simple idea in the mapping utility we built. So, first, I'll make it crash using the new
			Transmute alteration effect - having a self referential item that has the Transmute effect as a use alteration.
			
			Should it work, it will replace the "FixReferences" method! :) :) :)  That would be a great step towards removing that type
			of code from the editor.
			
	- IDEA ON MAPPING: 
	
			There should not be any "Generator" code in the Scenario namepsace. It should be replaced by a mapper that takes custom
			types specific to "Generating".
			
				Example:  Range<T> random draw types 
				
						  Obvious solution would be to have an interface to set up a special mapping method to do a random draw.
						  
						  public class Range<T> : ICustomMapperProvider<T> where T : IComparable
						  {
							  ...
							  
							  public T ICustomMapperProvider.ProvideValue( ... )
							  {
							      return [Get Random Value In Range]
							  }	  
				
				The idea is pretty simple:  Create an interface to provide a custom method for generating the scenario model when it
											is necessary to create custom type-mapping code.
											
				This could also be done using any mapping utility with custom configuration.. So, DEFINITELY something to look into
				because we have too much simple mapping code that should NOT exist.
							
	- MORE ABOUT SERIALIZATION:
	
			The bigger issue is removing the mapping utility all together and having a single source for deserializing two object graphs
			that are equal (but different type namespace).
			
			Much thinking on this...
			
				- Protobuf is VERY limited for support on meta-programming the get / set portion of deserialization from the buffer "message".
				
			      It's also tricky to set up self referential pointers in the object graph. There would definitely be issues with "cycles" - 
				  or circular dependencies.
				  
				- Meta-programming is required to prevent writing Get / Set code into the object model. However, if it could be done
				  automatically during the compilation process, doing get / set code is fairly simple and could be written that way.
				  
			First of all, writing a parser / compiler for a custom pseudo-language would go like this:
			
				1) Create object graph into a text file
				
				2) Parse file -> Create code files for each domain to compile
				
				3) Create a serializer for each type in the object graph
				
				4) Deserialize data from file
				
				5) Construct type instances from the deserialized data using meta-programming for each domain
				
			Trying to construct code classes from the pseudo-language might be a little too far out-of-scope. However, using meta-programming
			in .NET to create the custom classes might be a little easier.
			
				1) Create meta-description for primary object graph in .NET (using reflection or reflection.emit or expressions or some other facility)
			
				2) Create meta-description for types in each domain - probably using patterned public property names to 
				   make it easier.
				   
				3) Probably would try serializing / deserializing in one of the two domains to make it easy.. But, the
				   goal is to serialize in the primary "domain" which is the basic instructions on creating the object 
				   graph in a memory stream.
				   
			So, basically, we will have created a mapping utility anyway.. And not gained much from doing it because the problems will
			be the same. 
			
			I'd only think that creating the full solution:  pseudo-language; parser; code generator; deserializer; meta-programming (get/set)
			would provide the greatest benefit. 
			
			But, this is a bigger problem that would take a lot of time to solve and provide robust code.
			
			So, probably, the best solution (for the moment) is to remove reference "fixing" by storing object references and
			using reflection - which seems to work well for our special case:
			
				1) Class names follow a strict pattern "Template" -> "TemplateViewModel"
				
				2) Public property names are the same (case sensitive)
				
				3) Collections all must implement IList
				
				4) Interfaces must follow the same pattern "Template" -> "TemplateViewModel" (to find implementation)
				
			For now, probably going to implement an object hash to prevent duplicating data for shared references; and also to prevent
			circular dependency issues that cause stack overflows.
			
	THOUGHT OF A NAME!!!
	
		***"Rogue Stories" or "Rogue Adventures" or "Rogue Story"
		
	- IDEA:  Use for attributes / UI settings. 
	
			 Example:  CharacterBaseAttribute (enum) [Strength, Agility, Intelligence]
			 
					   Add UIDisplayAttribute [ Name, DisplayName, ItemGridDisplayName, ScenarioEncyclopediaDisplayName ]
					   
					   For each field the enum:
					   
					   enum
					   {
							[UIDisplay(Name = "Strength", DisplayName = "Strength", ItemGridDisplayName = "S", ScenarioEncyclopediaDisplayName = "Str"]
							Strength,
							
							...
						}
			 
			 We could start to set up attributes to describe how to display enums so that there's less work to do 
			 for the UI code - like collapse some of those converters.
						
				
	- TODO: Create a UI component to show some diagnostics:
	
			1) Number of region instances in the region manager
			2) Number of distinct region types in the region manager
			3) Number of registered event types in the event aggregator
			4) Number of method handles in each event type
			
	- IDEA: When walking into an enemy, maybe there should be a penalty because it was sort of that way in the original (?)
	
	- TODO: Mapper Instance Dictionary; Animation refactoring
	
	- MORE ANIMATIONS: It'd be nice to animate the character symbol. But, going there is gonna mean support for more alterations
					   that move / animate the character symbol.. so maybe if change to vector graphics.
					   
	- TRANSMUTE:  "What if it blows up?" 
				  "What if it steals your items?"
				  "What if it turns into a monster?"  (TransmuteBlowsUpAlterationEffect)
				  
				  What if it recurses through the scenario configuration object graph and creates a stack overflow?
				  (Use the reference dictionary idea...)
				  
	- TODO: Selection Dialog should probably head towards something like "Select One" or "Select Many" instead of
			"Uncurse", "Identify", etc...
			
			The effect should be understood from the context and displayed another way. The header of the dialog 
			selection grid doesn't have to be specific to the "intended action".. and, the "intended action" should
			be decoupled from the selection.
			
	- UPDATE:  Refactoring item grid - changed model to be abstract with child classes implementing abstract delegates
			   whose only purpose is to tell the base class how to update the item collection.
			   
			   INTENDED ACTION:  This has been removed along with the Item Grid Mode - in favor of building several 
								 child classes to specify the intended action. 
								 
			   This looked to be a better pattern - with the exception of a couple things. 
			   
					1) Repeated class structure for several of the child classes
					
					2) Imperative collection structure (ordering, group by, etc..) so that the UI looks the same
					   for several modes.
					   
			   These could be avoided with another layer:
			   
					Layer 0) ItemGridViewModel
				
					Layer 1) ConsumablePrimaryItemGridViewModel, EquipmentPrimaryItemGridViewModel, ConsumableDialogItemGridViewModel, etc...
					
					Layer 2) ConsumableDropItemGridViewModel, ConsumableTransmuteDialogItemGridViewModel etc...
					
			   This might get a little verbose; but the class size should be really small - with Layer 1 handling most common 
			   methods / members. Could also use the namespace to help remove some of the specifiers (Dialog -> ConsumableTransmuteItemGridViewModel)
			   
			   So, the main issue was using these view models for two separate functions:  "Primary Mode", and "Dialog Mode".
			   
			   There are now two separate folders (namespaces) for these child classes - which will be injected where they're needed.
					
	- DISCUSS: Understand what it would mean to do something like "IRogueRegionManager.SetDataContext([RogueRegion], [object])"

			   USE CASE:  Item Grid View Models have been broken out by type to get rid of overlapping functions. This helps spread
						  out the methods dealing with the item grids by type.
						  
						  THE ONLY PROBLEM IS:  Now, changing item grid modes means CHANGING THE DATA CONTEXT!
						  
			   A couple ideas on how to deal with this:
			   
			       1) Just have the event aggregator fire an event back to change it right on the UI control
					  by accessing "RogueRegion.Content.DataContext"
					  
				   2) Have the IRogueRegionManager have a method to set data context
				   
				   3) Have something like a "View-Model Locator" to do it automatically; and trigger it using
					  the event aggregator.
					  
			   So, what's #3? It COULD be just another static component to connect views with view-models. It could be registered by
			   hand, or markup - similar to the region manager.
			   
			   But, that's similar to the region manager that's there - aside from dealing with things like data context Type (?)
			   
			   FOR NOW: The Player Subpanel can handle setting the new data context on the RogueRegion - which is NOT the
						right method. It SHOULD set it on the RogueRegion.Content.DataContext property.
						
						It might be a good idea to read up on things like view-model locators; but it would be easy to design
						something like that.
						
	- IDEA:  How to "decouple" application using an "event aggregator" (?)
	
			 How about - having a mediator thread that catches all events and schedules them?
			   
	- TODO: Try and figure out if we can remove the TemplateViewModel namespace (!!!) Then, if it works out, create a mapper
			that replaces all the "generators" by a type-specific mapping:
			
			Example:  EnemyTemplate -> (mapper) -> Enemy
						- Range<double> StrengthRange -> (Range<double> mapper) -> double Strength
						- etc...
						
			So, that the templates could be mapped directly to model objects without the need for hand written code, these
			type generators would be created for complex types that had no mapping.
			
			Example:  EnemyTemplate.Name -> Enemy.RogueName  BECAUSE string -> string (may need configuration to specify mis-matching names)
				
					  But EnemyTemplate.StrengthRange does not map to Enemy.Strength BECAUSE  Range<double> does not map to double
					  without a mapping adapter specific by type.
					  
			I'd think that the AgileMapper COULD work for this; but I'm wary to try it because I can't see that it's doing what is needed.
			
	- IDEA: Make all the Smiley's in the game the different character classes ("ROGUE STORIES") - Randomized by DateTime.Now :) :) :) :)
					  
			
	- NECROMANCER:
	
		Friendly Unit:  (Derives from Character) (NEW ASSET TYPE)
		
			Behavior: Would like a way to SHARE classes for Behavior Details with Enemy assets. So, may require:
			
					  - Target Type:  Nearest Opposing Character; Player (For friendly alterations, or enemy alterations)
					  
			Alteration: Going to require some new parameters - mostly for targeting:
			
					  - All In Range:  All Friendly Units In Range; All Opposing Units In RANGE
					  - All In Range Except Source:  (Same)
					  
					    Obviously, would need to expand on Create Monster: Create Friendly (OR) Create Enemy
						
					  - CreateFriendlyCharacter: SELECTS FROM FRIENDLY ASSETS ONLY
					  
						 + New Interface Type:  IFriendlyAlterationEffect
						 
						 + This Alteration would get support from:  ISkillAlterationEffect, IFriendlyAlterationEffect, IConsumableAlterationEffect, etc...
					  
					  - CreateEnemyCharacter:    SELECTS FROM ENEMY ASSETS ONLY
	
					     + Enemies do NOT support CreateFriendlyCharacter. Friendlies do NOT support CreateEnemyCharacter.
						 
					  - CreateFriendlyCharacterGroup:  This would be a special case for creating hordes at once (kind of fun) :)
					  
		    Targeting:  May want to expand targeting to include SELECTION of Friendly OR Enemy:
			
						enum TargetType
						{
							Source:  - The Player, Friendly, or Enemy
							
							Target:  - Expand to let Player select Friendly OR Enemy
									 - Friendly selects Player OR Enemy via Behavior target type (Nearest Opposing Character; or Player)
									 - Enemy selects Player OR Friendly via Behavior (SAME ENUM)
									 
							All In Range:  ALL CHARACTERS (in range)
							
							All In Range Except Source:  ALL CHARACTER (in range) EXCEPT SOURCE
									 
							All Allies In Range: For Player -> Means Player + Friendlies
												 For Friendly -> Means Friendlies + Player
												 For Enemy -> Means Enemies
									
							All Opposing Characters In Range:  For Player -> Enemies
															   For Friendly -> Enemies
															   For Enemy -> Player + Friendlies
							
							All Allies In Range Except Source,
							All Opposing Characters In Range Except Source
						}
						
						Expand Targeting UI to allow Player to target Friendly units; and (while we're at it) also support targeting
						random cells :) :) :)
						
						BUT, need to review Alteration namespace to see what the impact would be for allowing Friendly targeting.
						
			Inventory:  Would be nicer NOT to support Friendly inventory. However, having friendly aura's or passives might be nice
						at some point.
						
						Favoring NOT supporting Friendly inventory.
						
			Movement:   Would like to share behaviors with Enemy type characters. However, there are a few things that may be different.
			
						1) Must allow Friendlies to swap places with Player when the Player tries to move.
						
						2) Have to have something to specify how they move WITH the Player. Maybe a range to maintain (?)
						
							- "Standoffish" character behavior still needs to be fixed to have a range to maintain before
							  attempting to attack
						
						3) Have to figure out how to keep the "Party" of Friendlies + Player together
						
							- Would REALLY want to support movement from level to level
							
							Basically, this means we'd have to have two levels open to remove / add assets in some sort of 
							"Safe" space between loading the UI.
							
							Also, when starting a new level, would need to group ALL party units on a single cell - with 
							the Player up front. 
							
							I'm a little afraid this will cause some unintended issues; but it should be ok with the layout
							processing: finding un-occupied cells, Enemies targteing the group's cell right off the bat, etc...
							
							Solve things one-by-one.
							
							- Also, would want to allow Friendlies to be supported as level units that you could "Find"

							So, to support this, there would have to be some parameters on how a Friendly "Be-friends" the 
							Player. I'd favor leaving this out (maybe for now)
							
							So, probably just add Friendlies as Assets; but only allow them to be created by the Player; and
							automatically put them in the Player's party.
							
							- Want to specify how Friendlies move WITH the Player. May want some extra parameters for this 
							  like "Distance Kept From Player" or "Distance Kept From Other Friendlies"; but this could 
							  easily adapt as we learn about Friendlies (by trying...)
							  
							  
			Objective:  Why not allow Player to "Be-friend" a special unit (?)  And, if the unit dies, the scenario ends (?)
			
						Would make for a really interesting STORY - which could be useful for some people who want to do it.
						
			Unique:  May have unique friendlies; but, for now, there's no support for generating friendlies in the level. However,
					 if we do Objectives as friendlies, then there'd have to be. So, Uniqueness is important for this purpose.
					 
			Auras:   Need to grow up the aura calculations based on the new target type:  Opposing In Range, etc...
			
					 So, end-of-turn processing has to have an IModelService dependency to add auras from all sides.
					 
	- TODO: May want to consider a versioning system for Scenarios. (games and configurations) So that it becomes systematic to
			deal with them versioned. (maybe also it would follow a build version - like tac it onto the ScenarioFile / Scenario Configuration files)
			
	- TODO: Been having trouble with my mouse..... HMMM.. It has been "double-clicking" so that UI events get processed twice.
	
			BUGS HAPPEN:  Consume is an example. Click on item - sends two events with the same item id. This is causing a crash
						  because the first one removes the item from the dictionary!
						  
						  HOW TO FIX THIS? Have to make sure to block things IMMEDIATELY BEFORE issuing the event to the backend.
						  
						  Search TODO:DEBOUNCE in the code - need to debounce the commands. So, probably a simple model for that.
						  
	- TODO: Transmute has a bug with the equipment grid
		
      TODO:SERIALIZATION - ABANDON GUID'S ENTIRELY. LET OBJECT REFERENCES DO THE WORK FOR EQUALS / HASH CODES.
                           GET RID OF ANYTHING IN THE NAMESPACES THAT OVERRIDES THESE THAT DERIVES FROM TEMPLATE.	
						   
						   PUT COPY FUNCTION BACK ONLINE
						   
	TARGETING MODE:  For support for new types of targeting - going to need to new process for doing things that require a target.
	
					 - Fire:  "F" -> "Select a target..." -> (Movement) Arrow Keys -> Enter -> Commence Firing Range weapon
					 
					 - Skill:  "X" -> Skill Requires Target ? -> (True) "Select a target..." -> Arrow Keys -> Enter -> Commence using Skill
					 
					 - Consume:  (Same Process) - So, systematize for Alterations.
					 
					 - Doodad: (SHOULD NEVER REQUIRE TARGETING)
					 
					 So, need to have a "targeting mode" - but it will be more like: Fire / Skill / Consume -> Message<Backend Action> to UI -> 
					 TARGETING MODE -> "Enter Selects Target" -> Return Message<Backend Action> -> Continue Processing
					 
					 Also, support doing the targeting FIRST - then selecting some action.
					 
					 TARGETING MODE -> Arrow Keys -> "F" -> Message<Fire Range Weapon>
					 
					 - Targeted Enemy / Friendly / Doodad (?) /Cell:  Send target from front end commands (no longer part of the IModelService)
					 
				     Future support could be developed for "switches" or doodads that fire when you throw something at them. 
					 So, may "prepare" for allowing Doodad targets.
					 
					 ENTER TARGETING MODE:  "F" -> Need a Target ? -> (True) Shell component "Enters Targeting Mode" (With Fire as 
											return command)
											
					 DIALOG MODE?:  Could expand this idea to having a "command router" in the shell. 
					 
						Command Router:  Responsible for managing "mode" during game play - [ Normal (Level Mode), Dialog, Targeting ]

						Dialog mode could support other key commands for using the dialog (if we wanted to do that)
						
						
	DEFINITIONS:   Backend - Processing unit consisting of services that operate and maintain the loaded scenario model
	
				   Frontend - Set of UI components that act to display scenario data
				   
				   Dialog - Set of UI components that display data for a specifc Backend request / response sequence.
				   
				   View - Set of UI components that are containers for Frontend components
				   
				   COMMAND: Any user input that originates from the View OR from the Keyboard
				   
						- Backend Command:  Command that is applied to the backend service controller directly
						
						- Frontend Command: Command that is applied to the frontend service controller directly
						
						- View Command: Command that is applied to the view directly
						
				   EVENT: Any event-aggregator issuance that bubbles up an event from a processing unit that carries some 
						  instructions to the primary game router to issue other commands
						  
						- Backend Event: Bubbles up from the Backend
						
						- Frontend Event: Bubbles up from the Frontend
						
						- Dialog Event: Bubbles up from the Dialog
						
						Example:  DialogRequestBackendEvent -> Requests a Dialog be shown (with data stored as Event Args)

				   EVENT ARGS:  Considering how to do this.. Maybe "Oneway" / "Twoway"?
				   
								Typically, stores the state of a command OR event. But, usually, we want something that 
								will handle both the request and the response.
								
								So, possibly, define "Entities" as the data class that encompasses "this particular 'thing'".
								
								Example:  TargetingEventArgs
								
											- [ScenarioObject] TargetedContent
											
											- [RequestType] Type { Targeting Start, Fire, Consume, Targeting End, etc... }
											
								But, this gets a little messy and ambiguous. So, probably will want several types per 'thing'
								and to create namespaces to support them intuitively.
								
				   COMMAND ARGS: (Same thing as Event Args; but with a better name to suit COMMAND entities).
								
				   
				   The object is to build a IGameCommandRouter to handle all of these issuances; and to store / manage intermediate
				   state during mode changes or "things". 
											
				   NEEDS A NEW NAME - Event / EventArgs / blah blah blah is all over-used. So, going to go with "Game" prefix.
				   
				   So, { GameCommand, GameEvent, GameEventArgs }, will be the new naming convention.
				   
				   
	ROUTER:  To create a router - try "Sniffing" or "Intercepting" or "Route" Event Aggregator events.
	
			 Example:
			 
				eventAggregator.GetEvent<T>()
							   .Intercept(Func<T, bool> (payload) => 
							   {
								   // Do some processing
								   
								   return true; // to continue processing other listeners
								   
								   or 
								   
								   return false; // to halt processing
							   
							   });
							   
				So, the event aggregator will keep your delegate and run it PRIOR to all other delegates. This 
				will allow us to build a "Router". 
				
				The router will be used to intercept events from the Backend / Frontend to determine game mode
				or proper course of action for each mode. (Targeting is the first one to try)
						
				ONLY SUPPORT A SINGLE INTERCEPTOR
				
	TODO:ALTERATION
	TODO:ROUTER
	
	- Frontend Controller:
	
		The view-models have been doing their own updating using the IModelService; and are injected straight into the view with
		the event aggregator hooked up directly.
		
		Moving this to the IFrontendController might be a nicer way to subscribe for fewer updates; but won't change the design
		much - just shuffle code around.
		
		BUT, there needs to be a saved state somewhere; and I'm thinking about where to put it because it could sit on the frontend
		or backend controllers; and they could expand their responsibilities some to do other things.	
		
	- Game Router: thinking of moving it to the Scenario project; and injecting the frontend / backend controllers instead of
				   using the event aggreagator.
				   
				   The backend is going to have to specify when it needs a target; and what it was doing. So, it's going to be a little
				   more than just intercepting event aggregator events.
				   
	- TODO: NEED A FEATURE TO START A SCENARIO FROM THE EDITOR
				   
	- TODO: Get the IModelService OUT of: IGameController, maybe ALL the frontend ViewModel components, and anything else where it's 
			shared between front / backend processing without being controlled by the IBackendController / IFrontendController or
			maybe the IGameRouter
			
			Calculations for the view-model components need to be broken up into smaller pieces. I like the idea of having the 
			view-model just be a simple data container so that the logic is more controlled
			
	- TODO: Move the dialog code to the RogueModule because it's closer to the shell. And, put the splash events on the dialog region
			and maybe try animating the smiley during loading
			
	- TODO: Break up LevelCanvasViewModel into separate view-models. Maybe one for the layout, one for the content, and one for animations(?)
	
	- TODO: Make GridLocation a struct (value type) and figure out how equals works "=" for structs. Does it copy? Also, want to know
			how much of a memory footprint the Level structure has - so, if we don't need the scenario file, then go ahead and remove it.
			
	- IDEA: Could EASILY build an injector service to replace the ServiceLocator. If it goes that way - would like to consider a way to 
			place constraints on components - so that you can control what gets injected.
			
			Example: IModelService is an important model container - and should be injected only where it is supposed to be.
			
					 How to place constraints on injection?
					 
						Attributes? 
						Bootstrapper? SimpleServiceLocator.Constrain(IModelService, typeof("The interface that allows injection"));
						...
						
			But, building an injector should be pretty straight forward.
			
	- Backend Queue Design:
	
		Main Problem:  Having to know what's happening on the queues at any given time - espeically with removing / adding content
					   creates a problem dealing with:
					   
					   IModelService - updating calculated variables
					   
					   Synchronization - Frontend gets out of sync with the backend
					   
		A Solution:    Ideally, everything should be queued in order of when it was issued; and the frontend / backend should be
					   completely in sync.
					   
					   Also, "Apply End of Turn" and other things that happend after "A Turn" has commenced need to be systematized.
					   
					   To accomplish this we need to get a bigger picture on the happenings of when a command is issued:
					   
					   Player Does Something -> All Characters React (And Doodads if that's added) -> [End]
					   
					   For each action / reaction - MANY things happen - including communication with the Frontend / UI. So, to 
					   sequence all of this, we really need a new queueing mechanism. The one in place doesn't always work. We also
					   need a way to say when "UI should be synchronized" and "Calculated variables should be updated". So, something like:
					   
					   ----------- ("Backend Sequencer")
					   Player Does Something -> moves location [UI Update Event Happens] -> [end of player action] 
					   
					   DO END OF PLAYER TURN -> [Calculate Player Visibility, Calculate Player Stats (Regeneration Only), Enemies Died (removed), etc...]
					   
					   THEN CONTINUE ().
					   
					   Enemy 1 Reacts -> attacks player [UI Animation, UI Character Update] -> [end of enemy action]
					   
					   DO END OF ENEMY TURN -> [Calculate Enemy Visibility, Calculate Enemy Stats (Regeneration), Calculate Player Death, etc...]
					   
					   THEN CONTINUE ().
					   ------------
					   
					   The reason this is different is because it's going to publish all the frontend / UI updates at the appropriate time - which
					   will be right after the reaction is calculated. AND, the new enemy visibility AND content removal AND synchronization with 
					   the front end will be done IN BETWEEN reactions; but ALWAYS at the END of each sub-sequence.
					   
					   Enemy 1 Reacts -> Skill Alteration [Animation Event, 
														   Process Alteration (Enemy)]
														   
									  -> End Enemy Turn()
									  
									  -> THEN, do these [Calculate Enemy Visibility, 
														 Calculate Player Visibility (Maybe they moved?), 
														 Calculate Player Death,
														 Calculate Enemy Regen,
														 Update UI Stats,
														 Update UI Locations,
														 etc...]
									
									  - END SUB-SEQUENCE ().
									  
					   So, using this idea, the queueing needs to be re-designed some with a new "Sequencer" to do something like:
					   
					   Queue:  Player -> Enemy 1 -> Enemy 2 -> .. -> Enemy N -> ()
					   
					   Then, for each character in the queue:
					   
					   Player -> Process() -> (signals many events which are loaded IN ORDER on a sub-queue)
					   
										   -> Process Sub-Queue() IN ORDER
						
					   Enemy 1 -> Process() -> ...
					   
					   This should cause all events to be sequenced properly.
					   
					   AND, IT WILL SYSTEMATIZE THE "END OF TURN" CALCULATIONS. Which will really really really help make the whole
					   game more robust.
					   
					   
	- TODO: DEBOUNCE BUTTONS! Mouse keeps double-firing. So, put a dispatcher invoke in the event aggregator to block incoming
			requests after one has been made. Use Application.Idle or something to delay the delegate invoke.
			
			UPDATE:  DON'T DO THAT! It doesn't work nicely. Just debounce the UI.
			
	- TODO: BUILD A BACKEND SEQUENCER!!!  Could add a service to store "Things that will occur at the end of this character's turn"
	
			Like.. { DoNothing, NoRegeneration, Regenerate } becomes one parameter in the service. 
			
			The bigger picture is to have some SAFE services that keep calculated state. The IModelService needs to be carefully
			handled. But, other things like the ITargetingService and maybe "I-Chararcter-Turn-Parameters-Service" also will have
			to be SYSTEMATICALLY used, stored, monitored, cleared, etc...
			
			Player -> DoesSomething() -> All.. Stateful.. Services.. Loaded.. 
									  -> EndOfTurn(Player) 
									  -> All Stateful Services Used (Parameters Read)
									  -> All Stateful Services (Cleared / Updated / etc..)
									  -> [End]
									  
			So.. BUILD A BACKEND SEQUENCER!!!
	
	- TODO: Make Speed an integer from 1 to 10. 
	
	- IDEA: If we BUILT A BACKEND SEQUENCER .. it might be possible to add a delay for character location changes.
	
			Like... The "Heavy Fighter" has a 200ms delay because his speed is set to 0.2. Whereas a Ranged fighter might have
			a smaller delay because his speed is 0.6. (maybe 50ms). 
			
			But, we could probably do this easily if the SEQUENCER WAS BUILT.. because they'd all be in order. (only those
			visible would be delayed)
			
			It would lend some kind of physical meaning to the characters.
			
	- TODO: We really HAVE to get rid of the TemplateViewModel namespace... It's too much work every time. 
	
			But, there's MANY UI features that require DependencyObject support.
			
			I'm leaning towards:
			
				1) MOVE the TemplateViewModel namespace to the Core project
				
				2) Build a CUSTOM SERIALIZATION ROUTINE 
				
					- DON'T DO IT ALL BY HAND
					
					- Build type serializers
					
					- Leverage reflection; BUT - VALIDATE THE NAMESPACE FOR PUBLIC PROPERITES AND Collections
						
						Validation:
						
							1) All public members must be a known type (kind of like the mapper that's already built in the editor)
							
								- public property [Type { Known Serializable Complex (reference) Type, IList Collection Type, or primitive CLR type }
								
								- Known Serializable Complex (reference) Type: Implies that we have a serializer for it - or it can be recursed to
																			   serialize.
																			   
							2) All public members must be serializable (either by default OR using OUR CUSTOM SERIALIZABLE INTERFACE)
							
			Doing this, it should be pretty simple to serialize the namespace WHILE validating it each time there's a change to the 
			namespace.
			
			Then, reflection should be pretty safe to use - something like the routine we already have. I'd actually just move that
			one over.
			
			ALSO, IF THIS HAPPENS, NEED TO BUILD A MAPPING ROUTINE LEVERAGING REFLECTION FOR THE GENERATORS.
			
			*** WE COULD TRY USING EXPRESSIONS - WHICH COMPILE TO MAKE THINGS RUN FASTER.. IT MAY TAKE A LITTLE MORE WORK TO LEARN BUT 
				WOULD BE WORTH IT AS AN EXERCISE TO KNOW.
				
				OR, MAYBE REFLECTION.EMIT
				
	- IDEA: For the telepathic sorcerer - She might need a "Neo blows up the agent" effect for "Teleporting into a character".. So, maybe
			a cute effect for that one. (projectile -> aura at affected character -> blows up and dies 
			
	- TODO: Take ALL ATTRIBUTES, INTERFACE SUPPORT, STATIC METHODS, EXTENSION METHODS, ETC.. FOR ALTERATIONS AND MOVE THEM INTO A STATIC
			CONTAINER.
			
			There's too much GUNK around those that really should be moved.
			
	- TODO: Problem in Teleport effect - have to separate out manual selection by using a new effect type.

	- TODO: MAKE ENEMY DEATH ANIMATIONS SOURCE ONLY
														 
	- TODO: Decide how to handle Validation "Critical" errors - ones that will result in a crashed application. (probably should just fix
			the model)
			
	- TODO: Removed "skill at close range" attack type for enemies. We need some parameters in the alteration space somewhere to specify
			things like "range".
			
	- RENDERING ISSUE: Anything too large (100x100)ish - is slow (render transform). I don't know why but it's probably the number of 
					   path figures.
					   
					   I'm thinking the best that can be done is to piece together all the walls from a single path figure (if it's possible).
					   
					   The "Outlined Path Geometry" didn't really work. So, may have to do it by hand.. but it would hopefully speed up
					   rendering and allow for a larger layout dimension (for really really big levels)
					   
	LEVEL CREATION:
	
		The editor has something like "placements" for each of the scenario assets. It might be nicer for people to use if it just layed out
		the levels one-by-one; but with a list of weighted assets to build:
		
		Scenario Template:
		
			LevelTemplate[] Levels
			
				LevelTemplate
				
					"Layout Array with a weight"[]
					"Enemy Array with a weight"[]
					etc...
					
					int NumberOfEnemies = "Total number of draws from the enemy array with a weighting"
					etc...
		
		So, it'd be a lot more intuitive to do that way; and there could even be a separate tab for the asset tree: [Scenario Assets, Level Assets]
				
		Also, adding an asset to a level could draw from a saved "Template" -> Example: New Enemy (for Level 1) -> (Choose) { Easy, Medium, Hard }
		
		Then, it could add one with nothing special, then attack attributes, then maybe something like a skill behavior (for Hard). The same could
		go for creating a new level, or any asset; but it would be easy for people to do and see what they made right away.
		
	LEVEL OBJECTIVES:
	
		Could have objectives for each level that are something like scenario objectives; but they could be "required" or "optional" for completing a 
		level.
		
			- Defeat all enemies
			- Pull a series of levers
			- Find a special item
			- Defeat a special enemy
			- Push a block onto a switch
			- etc...
			
		Thought of having two-state doodads.. which could be simple to have. Or, collections of doodads for different purposes.. Or also room connectors
		that are stair-wells.. but something to have a goal for the level would be good.
		
	LEVEL BRANCHING:
	
		So, if the levels were setup like the above - as a definite list of templates - then, it would be straight-forward to actually have each level
		have multiple randomly chosen branches. THIS WOULD RANDOMIZE THE STORYLINE. 
	
			- Just have weights for each branch; and if it contains a scenario objective that hasn't been generated - then generate it absolutely.
			
		Example: The 7 princes of Hell
		
			- Some 10 levels (near the end) of the Paladin scenario have branched levels:
			
				- Branch 1:  Abbadon (Level Objective) (So, it would be either required or optional to defeat Abbadon on this level)
				- Branch 2:  Mephisto (Level Objective)
				- Branch 3:  ...
				- Branch 10: Normal Level
				All except for Lucifer and King William.
				
			This would give random opportunities to fight the 7 princes and, perhaps, have scenario "Interludes" to show more of the storyline
			if it's configured. (Interlude being another screen with some text)
			
			- Last 3 levels would just have King William and Lucifer; but with an optional side-quest: "Gwenyver"
			
				(Levels 48, 49)
				- Branch 1: King William (Scenario Objective) (MANDATORY ONCE)
				- Branch 2: Gwenyver (Level Objective) (You find her mirror and manifest her ghost to get more of the story)
				- Branch 3: Normal Level
				
				(Level 50)
				- Branch 1: Lucifer
						
		It would be a lot more fun if there were random parts to the story that you could discover.
		
	Friendlies / Temporary Characters:
	
		- Following the Player: Going to set desired location as Player.Location and let them move how they're configured { HeatSeeker, PathFinder, Random, etc..}
		
		- Managing Player Party: This is going to be KEPT SIMPLE.
		
			Friendlies: They become part of the Player's "Party" when they have the Player in their visible range.
			
			Temporary Characters:  They either follow the Player or just attack Player-Aligned units during combat.
								   THEY DON'T FOLLOW THE SOURCE ENEMY.
								   
			Player "Party": All friendlies become part of the Player's "Party" and are marked to be removed and added to
							the next level along with the player. 
							
							Their paths will overlap on the staircase until they move around.
							
			Temporary Characters:  These will dis-appear when the Player leaves the level.
			
	- TODO: Need to think about a better design for keeping objects to prevent exposing dictionaries. It's efficient; but exceptions may need
			to be kept a little better so that the collection can be managed internally and have more verbose exception handling.
			
			Scenario Encyclopedia, Consumables, Equipment, Inventory, etc...
			
			Also, might be nice to have a reflection based search to fill the "Encyclopedia Rouge-Tanica"
			
	- TODO: Change "Magic" Doodad to some other name.. And expand definition to form a base for new types
	
	- TODO: Force GridLocation to be a struct and use GridLocation.Empty
	
	- TODO: Get the ILayoutEngine to return EVERYTHING you want / need / will ever need to calculate 
	
			1) Free locations in level (non-occupied)
			2) Free locations in level (for character movement BY ALIGNMENT TYPE)
			3) Free locations in Range (non-occupied)
			4) Free locations in Range (for character movement BY ALIGNMENT TYPE)
			5) Free adjacent locations (SAME)
		
			"How do i get to my desired location" (method) (returns) enum { Passable, Impassable, PassableThroughDoor, PassableThroughOpposingCharacter }
			
				This would take TWO POINTS (Source, Destination) and calculate a path to get there. It would return the
				desired parameters to get there.
				
				"Character Next Move Parameters" CalculateCharacterMove( Source Location, Destination Location, Character Alignment, Can Open Doors )
				
				Which would tell you what to do next:
				
					"Character Next Move Parameters" : struct
					{
						PathObstacleType { Passable, 
										   Impassable, 
										   PassableThroughDoor, 
										   PassableThroughOpposingCharacter }
						
						GridLocation NextPathLocation;
						
						GridLocation DoorPosition1;
						GridLocation DoorPosition2;
						Compass OpeningDirection1;
						Compass OpeningDirection2;											
					}
					
				So, based on this struct, we could easily see what to do next. This should be used as a one-shot method for
				dealing with path finding and character movement.
					
				If we wanted to we could even return information on whether there's other obstacles in the way.. like a teleporter or something.. (not necessary)				
				
			
			6) Is Path to adjacent location blocked (for movement)
			...
			...
			...
			
		Pathfinding:
		
			To solve this problem more generally - we'd need a much more efficient algorithm. Brogue has a mouse-over path finder. Pretty sure
			we could get that to happen .. maybe by studying how heuristics work (?) But, it should be basically our go-to for doing anything with
			character movement and planning.
			
			But, it would be something to show the path on the UI. Don't think the creator Brogue would mind if we did that :)
			
			
		Versioning:
		
			If it came to it - the game could be versioned by:  [major release].[minor release].[patch number]
			
			Major Release:  Updates to the model and configuration that may not be backwards compatible
			
			Minor Release:  ???
			
			Patch Number:  Bug fixes only
			
			So, if the model and configuration were versioned, it could be made to be forward / backwards compatible with some work on serialization.
			
			If it were ever online - maybe using Web Assembly (?) all versions could be online. So, if a player wants to play their saved games - it
			would be the old version - and it would notify them of the update after their games are finished (maybe because of perma-death)
			
		Web Assembly:  
		
			There's a few frameworks out that build WPF for WebAssembly:  Uno, Ooui (uses Xamarin.Forms), and Frogui (ones that i found quickly)
			
			These would have to be researched; but it's promising to see that people are planning for WPF -> Web Assembly.
			
		WPF DataGrid:
		
			Performance for the item grid is very slow when changing the source collection. Maybe consider replacing it with a list box of some kind.
			
		INotifyPropertyChanged Design Issue:
		
			Need a way to send an INotifyPropertyChanged.PropertyChanged event when a collection ITEM is modified. 
			
				Example:  Brush Editor - needs to bind to the GradientStops collection using a Multi-Binding - which requires
					      that an event be sent when a gradient stop is altered.
						  
						  Sending the event just requires a simple inherit -> extend of the ObservableCollection to notify its
						  parent.
						  
						  However, sending a PropertyChanged event from the BrushTemplateViewModel for the GradientStops results
						  in an issue with the undo service trying to read it as a model change - which overlaps the actual
						  Gradient Stop property change (probably already registered by the time this happens).
						  
				UPDATE:   Looking into the BindingBase - it looks like the whole thing is built on:
				
						  1) MarkupExtension
						  2) Expression   <-- THIS COULD BE THE CAUSE OF THE PERFORMANCE ISSUE. The "Lag" during loading.
						  
						  That's pretty easy to handle! It might mean that you can pretty much build your own binding classes
						  from scratch! GOOD TO KNOW!
						  
				So, going to try to build one to listen for a custom collection changed event. I'll bet you could even use 
				Reflection to build up a binding mechanism that may perform better than Expressions; but just on the initial load
				while they're compiling.
				
				UPDATE:   BindingExpression instances can be passed to DependencyObject.SetValue(DependencyProperty, [object]) as
						  the [object] to set up a binding - which is what happens when you declare the Binding MarkupExtension.
						  
						  Also, A MarkupExtension that returns a BindingExpression will behave "like we know" - according to how
						  those work. 
						  
						  The convention for return values from MarkupExtension.ProvideValue is:
						  
							1) Return "this" when there's no target dependency property / object to see
							   (my understanding is that the extension will be re-evaluated if you return "this") (maybe not...)
							   
							2) Return BindingExpression (BindingOperations.SetBinding) to behave like the Binding "we know".
							
				ALSO:     This idea is how bindings work for item / data templates because they have to be "evaluated later"
				
	Simulation:
	
		Probably the most important tool to help build scenarios more easily. Thought of a way to use game attempts to build a
		"database" of "average tries":
		
			- Each time a user defeats a level -> in a scenario -> as a particular character class
			
				1) Aggregate the user's results with those of previous results (in a moving-average fashion)
				2) Store the result as "the result" - which is an "average" of "how well" the player usually does by
				   Level "X". 
				   
			- The calculation is as follows:
			
				1) Total # of Character Points (1-per level unless alteration is added for giving extra)
				2) Get the total # of points spent on [ Strength, Agility, Intelligence, and Skills ]
				3) Create a vector with the total # of attempts for a given point "purchase"
				
					- Strength:  	Total number of points spent by Level "X" On Average
					- Agility:   	Total number of points spent by Level "X" on average
					- Intelligence: (same)
					- Skills[]
						Skill 1:    Number of times player had Skill 1 by Level "X" (weighted by the point cost)
						Skill 2:    Number of times player had Skill 2 by Level "X" (weighted by the point cost)
						...
					
					Such that the "total expendature" by Level "X" is (on average) constant (average). So, then,
					the simulated strength, agility, intelligence, and skills are chosen from this vector in a
					"top-down" fashion. 
					
					Example:  Strength has a weighted expendature of "4.5 points by Level X" - which is the highest
							  (on average). So, the simulator would spend the first 4.5 points on Strength - and so
							  on "down the histogram" until the total number of points (on average by Level "X") is
							  reached.
							  
					IN SHORT, THE SIMULATOR IS SPENDING IT'S POINTS IN THE WAY THAT THE USER DOES (ON AVERAGE).
					
					The same should be done for items in the player's inventory; and other statistics COULD be
					averaged out - WITH SOME LIKELY NOISE.. I don't know if that will be a problem or not (food is
					an obvious issue; but I think it'll be ok.. The total number of player steps could also be 
					averaged, etc... to provide some decent calculations).
					
			This design would solve a problem of trying to figure out how the simulator should operate.
			
	- TODO: Make alteration effect type that "Refills HP, MP, Hunger" (so, no limits required it always refills the meters)
	
	7 Deadly Sins / 7 Virtues / 7 Princes
	
	Lust     / Chastity   / Asmodeus
	Gluttony / Temperance / Beelzebub
	Greed	 / Charity	  / Mammon
	Sloth	 / Diligence  / Belphegor
	Wrath	 / Forgiveness/ Satan
	Envy	 / Kindness	  / Leviathan
	Pride	 / Humility   / Lucifer

	- TODO:SYMBOL

		- Need a Default "?" symbol for the UI for the encyclopedia

		- Repair game buttons with the new SVG symbols

		- Delete some empty symbols from the SVG character sets (just a few in there)

		- IDEA:  Allow user to create symbol sets for randomization. This would prevent issues with weird looking hue shifted symbols.

		- ANOTHER IDEA:  Prevent weird hue shifted symbols by making neutral mask colors. Example:  Potion could have a WHITE flask.

						 UPDATE:  This works; but is a little much. What we need is an effect that's pre-built to accomplish this. Like...
								  "Change the primary mask color (red) to this color"

		- MARKUP EXTENSION:  Create a new markup extension to monitor the symbol details to update the symbol instead of the multi-binding

		- CENTERING:  The scaled SVG's need to be centered in the viewing area. The current scale feature will put them in the top left.

	- IDEAS:

		Doodad Pairs:      One Doodad turns on / off another Doodad. (like a teleporter that you can switch on / off). could also have 
						   light sources - so like, doodads that emit light; and can be switched on / off. Also, could emit auras that
						   switch on / off.

		Barriers:  	   	   Maybe a section of the level or a wall that is a "Barrier" to another room - switched on / off with a Doodad
	
		Zones:  	       Try creating sub-layouts in a grid. Each sub-layout would get a defined entry - exit point to connect the
					       zones - each zone with exit criteria (relates to Level Objective)

				    	   PROBLEM:  Zones would (likely) blow up the level size - and we'd have to deal with rendering

		Layout Rendering:  Could try creating the level grid as a GRAPH. This may enhance rendering and searching - but would have 
						   to rewrite the grid as a graph.

						   Why a Graph?  Because, it would prevent iterating during the build phase. But, it may not be helpful during
										 game-play. 
			
										 So, we might want both - the graph being the first one - during the build phase.

						   Rendering?    Create a combined geometry and try rendering it without each individual cell. That probably has
										 something to do with the performance

										 ALONG WITH - the opacity mask. 

										 OPACITY MASK - Needs to be replaced with a fading cell opacity - which will look more interesting
														when we have some terrain.

						   Static Layouts?  YES!  Let's build an editor

	- TODO: Saw problem with null values in AuraSourceParameters. Should definitely fix any null strings - especially colors

	- TODO: ATTACK ATTRIBUTE META-DATA / SEPARATE SCREEN FOR VIEWING - MAYBE TURN STYLE + META DATA

	- TODO: Play-from-editor-button / Layout Preview / Zoom Feature / Bulk Change UNDO

	- TODO: Add Astaroth as the "Big Baddy" for the Sorcerer scenario

	- TODO: Add feature for PERMADEATH that stores the save time in the .rdn file - which gets compared to the file-system record date-time.

	- TODO: Strip out most of the difficulty chart SIMULATION code and do the accumulated "average" data from runs of the actual scenario - 
			STARTED FROM THE EDITOR.

	- TODO: Add red foreground text coloring to the level browser for the validation "design mode". (will have to show the level browser during
			validation)

	- TODO: Design some "fun" chart to show for the "Overview" design mode. Since we can click around in the asset (or) level browser - it might
			be nice to see a related chart (?). Just something simple to show someone.

	- TODO: Level browser - collapse tree view button

	- TODO: Add probability calculation to the generated asset

	OBJECTIVE DESIGN:

		- Right now, the objective relies on assets that must be created and dealt with somewhere in the scenario. But, this could change 
		  into something that evolves the storyline. 

		- For now: Highlight anything in the editor that deals with Objectives "Cyan" and show what it means. 

				   Validate that ONE branch is created for objective levels (having multiple won't work). 

				   VALIDATE UNIQUE LEVEL BRANCH NAMES (TODO: CHANGE THIS TO GUIDS)

	- TODO: Editor dirty flag

	- TODO: REMOVE ITALIC AS UNIQUE STYLE / FORCE ALL OBJECTIVE ASSETS TO BE UNIQUE / HOOK UP COPY ASSET

	- TODO: USE UNDO SERVICE TO GET THE DIRTY FLAG FOR THE EDITOR

	- TODO: Remove experience range from enemies (DOESN'T MAKE SENSE!)

	- TODO: Hide text for level requirement. Just say "You're not able to wear this yet"

	THROW AND RANGE PROJECTILES:

		Design has a few goals:

			- Be able to "throw" any SVG

			- Be able to assign orientable SVG's to projectile weapons.

			- Have animation parameters for the projectiles (speed, rotation)
		  
			- Have parameters for every object that is thrown:

				Throw Quality:  Behaves just as attack / defense quality

		- TODO: BREAK UP ANIMATIONS BY TYPE INSTEAD OF ENUM SELECTION
		- TODO: Get rid of acceleration ratio / stroke template

	- TODO:  Consider putting the scenario objectives in the top-left corner of the level canvas

	- TODO: What about a "Brings me back to life" thing? Suppose it's like a save point - but more of a Hoarcrux (?) Maybe a doodad-only effect(?) 

	- TODO: Add explored / revealed walls / doors to the mini-map

	- TODO: DON'T ALLOW USERS TO CREATE DUPLICATE NAMED ASSETS

	- TODO: Add animation messaging to allow for character animations on the front-end. like "Animate these Character's positions (as a one-off)"

	- TODO: Passive effect should have a can-see-invisible flag

	DESIGN IDEA:  Always have trouble coming with a user-friendly name for "Alteration".

				  Thought of an idea related to Alteration Meta-data / Categorization.

				  Obviously, bringing them out using meta-data would be a way to start to describe them -
				  so, adding some text there to show to the user might work. 

				  We could even have a dynamic UI to show categories of effects - with user described names
				  for each one.. like "Dark Magic Effects", "Environment Effects".. etc.. and decide a way
				  to manage them.

				  WE DEFINITELY NEED TO CATEGORIZE ALTERATIONS. So, adding data to describe them would be
				  a start.

	REGION MANAGER DESIGN:

		HAD AN IDEA:  Having to fire a region event and listen for it is a repeated design issue. Could have the
					  listener be the actual Region Manager. That way, just firing a RogueRegionEvent would be enough
					  to load the region with a new view. The point of doing this is to centralize region loading.

					  Currently, the IModule implementations contain the only instance of the region manager.

	- TODO: Min-range for alteration ("Must be farther away to use Lightning 1")

	- TODO: Asuage hunger range selector has to be F2

	- TODO: Add "Confine" option to the Bubbles animation. The roaming feature became unbounded - which is REALLY COOL. But, you may 
			want both - confined looks more like an explosion.
			
			  