- Outro Display (I Won! - Here's my stats!) (STATS TBD)
- Statistics Display (High Scores) (TBD)
- Reveal Image Transparency (TBD)
- HINTS (TBD)
- Layout Descriptions (To lend narrative to the story... "Evil Approaches..." .. "These are the blah blah blah of the evil blah blah blah"
- Categorize: Skills / Spells; Equipment; Consumables; Animations (TBD)

(BIG TBD's)
- Player Action: Can choose to block physical (strength based), or magical (intelligence based), or maybe even to "run away" by
- 				 granting you an extra portion of a turn. This would be instead of just attacking. (TBD)

- Several Validation Points: 
	- Scenario Editor: Dungeon Template Name - UNIQUE and SET and NO FILE-NON-FRIENDLY CHARACTERS
	- Scenario: Player Name SET and UNIQUE and NO FILE-NON-FRIENDLY CHARACTERS
	- Scenario Files: Player Name + Scenario Name.. or put something in the header to show the scenario name also
- Scenario Editor: Fix up the Symbol Alteration logic for the UI. have to represent it properly for flags set.
- Dungeon Wide Events:  Alteration or note-bearing event that fires at random; or once during a specific level range. 
						- Example:  "Corruption" Adds to your player's "Corruption" level every 10,000 steps.. ish
						- Example:  "Turn back while you still can!" (from the big enemy of the scenario) (creates monster)
						- Example:  "Send player back to stairs up" :)  after X number of steps (pretty mean!)
						
- Boost Bar:  An extra boost to alterations or attack. This could be filled: On Step; On Enemy Death; On Attack. So, player 
			  can choose when to use their boost bar to add to the attack.			 

- Alteration:  Teleport within visible range or within range of X or something where enemies teleport near to the player's visible range

- Multi-Level Teleportation: Coordinated using multi-level layouts
- Tertiary Behavior

- Balancing (Paladin) - Add "teleport near (within attack range)" to Hell Hound (TBD)
- Balancing (Paladin) - Add "teleport adjacent" to teleport options (TBD)

- Layout Refactoring:

	- Goals:  Support for:
				- Random Room layouts
				- Intersecting rooms 
				- Maze rooms
				- Room inside a rooms
				- Boss levels (symmetric / static-ish layouts)
				- Hidden pathways: either hidden hallways randomly; hidden paths off the grid; or hidden paths between rooms
				- multiple halls between rooms
				- Big rooms specified by a clickable grid of rooms (specify which rooms are "grouped" in the room grid)
				- Add teleporters to any layout type
				- Points of interest (allows placing objective or unique content on those points)
				- Symmetric layouts
				- Specific shapes for layouts (pentagram, square thing, etc..)
				- Challenge levels (alternate stairwell for a challenge level)
				- Room levels without doors
				- Cell Fill color
				- Linear layouts v.s. non-linear (linear => start to end without options)
				- temporary walls (can demolish by walking through)
				- Switches and push blocks! (would use to open a door or let down a wall.. YEAh!)
				- Cellular Automata (with connected rooms with parameterized hallway thickness)
				- Room "Growing" - Start with a room, create a door or hall with random length. Then iterate to create the next room
				  or rooms (maybe 2 or 3)
				  
				- "Antfarm" procedure that uses random hall splitting (recursive)
				- Identify 'main room' or "first" and "last" rooms. Create connected rooms by showing they're connected to a single room
				  via some other room. First and Last rooms may have the stairwells.. So, could generate sequential "problem" set by having
				  conditions for advancement (beat a monster, find a key, etc..)
				- Monster generation per level (parameter) also, party room parameter
				
				- POINTS OF INTEREST:  Doodads are important to scenarios. Having special points of interest can make it possible to arrange
									   content to suggest a narrative - which is what Rogue.NET is supposed to be about.
									   
									   Idea:  Have points along the wall designated as POIs. 
									   
									   Idea:  Have points near an entrance (on each side) designated as POIs. (Idea from Brogue Dar Blademasters)
									   
				- Level Tree:  Have the level generation be a tree to support probabilistically generated branches of the scenario. 
				
							   Idea: Could randomly choose a stairs down image to help make it more difficult for people to know where to go.
							   
							   Idea: Could have stairs-up be sealed off.. but would have to reconnect to the primary branch at some point.
				
- Windows: Would treat like an open door that you can't pass through.. (But maybe could break)
				
- Zones:   Related to level layouts. 

		   - Idea: This would combine level content and layout generation
		   
		   - Goal: To separate the layout into "Zones" that are sequential. Each would have an "Exit Condition"
		   
				   - Step on a switch
				   - Defeat (All, Some, One of "These") enemies
				   - Collect Content
				   - Find a key

		   - Design Problem:  Have to build a layout based on a sequence of zones
		   
				   - ISSUE: CAN'T PERMIT "PITFALL" TYPE EFFECTS BECAUSE THEY BREAK SEQUENCE
				   - Can only allow linear progress through zones. CAN GO BACKWARD (RANDOM LEVEL UP) BUT NOT FORWARD (RANDOM LEVEL DOWN or PITFALL)
		   
		   - Idea: Description of zone problem built into scenario level zone template. 
		   
				   - Describes what to do for exit condition ALONG WITH story-line!
				   
					 GREAT. IDEA.
					 
					 Would allow for something like: "You're in King William's prison in the castle in Britain. You must find a 
													  way out of your cell.. Perhaps there's a secret passage nearby..."
													  
													  for the Level 1 template for zone 1! VERY. COOL.
													  
				   - This would give a LOT of power to the scenario by not only allowing for progressive rewards; but also accrued
					 descriptive - and totally configurable - storyline! :) :) VERY. VERY. GOOD.
					 
		   - Idea: Have a "Check Mark" box to show completion of objective(s) for current Level->Zone.
		   
		   - Side Objectives:  
		   
				   - These would be configured on the Zone object to allow the player to find some kind of other hidden
					 room, passage, etc... But essentially use the same engine to create the objective that would be used
					 for linear progression.
					 
						- Examples:  Switched door, hidden passage, keyed door, hidden cache (treasure chest), hidden room, etc...
						
				   - These would be optional so don't require explanation (text)
				
		   - Exit Conditions:  HAVE TO BE ABLE TO GO BACKWARDS.
		   
				   - Switch:  Two state doodad, Riddle Doodad, Temporary event, Weighted doodad
				   
						- Two State Doodad:  ON or OFF - icon for each state
						- Riddle Doodad:     Set the dials on the doodad to create a word to solve the riddle
						- Weighted Doodad:   Stepping on this triggers a "Zone Event" - which may be a timed event
											 
											 Idea:  Could use weight of items to weigh down the switch. So, would need
													weight parameter. Problem with overlapping weight of enemy, or flying enemy, etc...
													
											 Idea:  Push, Pull a block to set on the switch.
											 
											 Idea:  Create a push / pull block problem to solve (like seen in many games) to advance
													to the next zone.
													
										     Idea:  Have switches that you must UN-weight in order to open the door (Example: pedestal)
													
				   - Defeat Enemy(ies):  Have to defeat a speific, all, or one of ____ enemies to advance
				   - Collect Item(s):    Have to collect specific items to advance

									     Idea:  Create special item room with a "pedestal" or point of interest for an item.
										 
										 Idea:  Create item "room" with points of interest.. (something similar)
										 
				   - Collect Key:   Hide the key somewhere to collect. 
				   
									- Generate in enemy inventory (MANDATORY)
									- Generate in level (MANDATORY)
									- Generate in treasure chest cache (MANDATORY)
									- Generate in special item room (MANDATORY)
									
		   - Reversable:  MUST BE ABLE TO GO BACKWARDS
		   
						  - For switched doors, have to have a switch on the other side (INCLUDES SIDE OBJECTIVES)
						  - For content related doors (enemies, items) have to leave the door open
						  
				  
				
- Recipes: New consumable type that blends other misc consumables to create a new one

- Animation refactoring:  Support for...

		- RANDOM SEED EACH ANIMATION (NO REPEATS!)

		- Fading Chain (chain lightning)
		- Earthquake! (shaking screen)
		- "Jumps" (Character jumps .. like a prelude to an "Earthquake" skill or something)
		- Other shapes (square, rectangle, some, other, enumerated, types)
		- Easing functions (Normal easing, plus things like "Pause and go" that make it come alive!)
		- More interesting animations (ease out, come back, etc...)
		- Better language to describe more complex animations
		- Slow animation speeds relative to animation time
		- Criss Cross animation
		- Tracers!
		- Spiral inward
		- Lightning
		- Screen Shaking
		- Gas Animation (Something like burning flames.. figure out how to "diffuse" them upward)
		- Gaseous Projectile - Diffuse Bubbles while travelling / Also Goo (maybe have a weight parameter)
		- "Dim the Lights" (Turns down screen brightness during animation)
		- Explosion Animation - Something like a "half dome" over a character
		- "Hold End" Parameter
		
- Water:  Player has a "Water Meter". Standing water could be a doodad to replenish your supply. Would need alterations to
		  support water replenishment.
		  
		  Also, have skills that depend on water. (use water to cast a spell, etc..)
		
- Alteration Effect: Push Back Enemies ("X" number of spaces).. Possibly on a "Wave" with animations (but that's tricky)

- Teleportation:  Add a standard animation for teleporting that shows the trajectory of the path to the new location.						

- Character classes:  Add class selection and set for equipment. Provide choice at the beginning of class.
					 (Defined in Scenario): Example: Elf, Dwarf, Employee, Wizard, Worlock, etc... These would
					 have equipment trade-offs, combat implications, and attribute bonuses.
					 
					 Equipment: Have different patameter sets per class. OR just a flag to say "Out of class" or "In class"
								to make it simpler.
								
					 Idea:  Chose race (elf, golem, etc...); chose attack attribute bonus to start with. Race could make you 
					 immune to certain altered states.					

					 Also, could spend points at start instead of being assigned attribute values. So, need more intelligence,
					 and agility combat consequences.

				     Altered States:  Certain classes are immune from certain states. Example: Stone Golem immune from stone..

					 Enemy Classes:   Could support combat adjustment from interacting character classes. Example:  Stone Golem
									  has a multiplier v.s. Wizard and Worlock classes. Or, a "Miss Ratio" multiplier.. But these
									  would be set up in the Scenario Editor.. 

									  Setup:  Character Class "Elf": (contains) ClassAttribute, List<ClassAttributeMelee>
											  
											  ClassAttribute:  Any Player Stat (Strength, Agility, ..., Attack, Defense, Miss Ratio, Dodge, Critical Hit, etc...)
															   with a bonus. This would show up as a Passive Alteration. The effect could be positive or negative.

											  ClassAttributeChange = ClassAttribute (modification) + EnemyClassName

														       The effect of this would be to modify the player's stat (determined by the ClassAttribute)
															   during Melee combat ONLY.

															   WOULD REALLY WANT TO SHOW PEOPLE WHAT WAS HAPPENING HERE. So, extra combat messages are 
															   preferred to show.

															   Example:  "Stone Golem" is immune to Altered State = "Stone". His class attribute is
																	     + 0.3 for Critical Hit.

																		 Against Wizard:		    Class Attribute = -5 Intelligence
																		 Against Elf:			    Class Attribute = -3 Agility
																		 Against Water Elemental:   Class Attribute = -10 Defense
									
																	     Message (Water Elemental):  Leviathan attacked Ryan
																									 HP = 43 + Attack Attributes...
																									 Bonus attack for Water Elemental = 32

					 
- Weapons "Gain Experience" from defeating enemies. So, they would "grow" with your character. 

- Weapons can have an Attack Alteration that will heal the player when attacking an enemy. This would likely be
  a new / separate / weapons only alteration applied immediately. Could include animations; but they would be applied
  after the alteration effects due to problems forwarding an attack alteration to the ISpellEngine.

- Enemy Alteration Effect on being hit: Example: "Jelly" divides into two when hit.

- Enemy "Alteration": Riddle.... Example: The riddle of the sphinx. Alteration Effect applied if answered incorrectly (?) or correctly(?)
				
					  OR!  Just a riddle from a doodad - have one incorrect and one correct answer.
					  
					  So, would want to support RIDDLES!!!
					  
- Add - Electricity symbols.. things for lightning!

- ISSUE - Have to use engage radius as enemy "light radius". PROBLEM: HAVE TO FIX PERFORMANCE ISSUE OF MULTIPLE LIGHT RADII USING
		  WPF OPACITY MASKS. PLANNING TO TRY PAINTING ALL TO A SINGLE BITMAP AND THEN APPLYING THE OPACITY MASK ONCE.
						  
-  Add - "Scenario Oracle" - just an endless identify doodad at the end of each scenario to show the total % complete in the stats.
							 (OR) Just identify everything the player has found.
						  
- (TBD) Fade-in for opening animation; and on opening level (Also fade out when player death)					

- Icon sets: This is for randomizing item glyphs. So, probably apply to just items; but support List<SymbolDetails> for the template ONLY.

			 - Design Problem:  How to pick a random symbol from the set but keep it consistent for the rest of the scenario.
			 
- Player Stat:  Miss Ratio - BASED ON AGILITY and Equipment "Out of Class" flag. 
				
				Idea:   This stat would be factored in during combat. It would also be available for alterations
				
				Class:  Flag for equipment saying "Out of class" means that the item isn't meant to be used for that 
						character (bigger idea was class selection .. but it's not part of the game yet)
						
						So, this flag says whether or not the player has trouble wielding the weapon or piece of equipment.
						
				Effect: A simple melee calculation adjustment to factor in Miss Ratio (or Miss %).
				
				Idea:   Need way to communicate this to the user. Either we have a class specification for the player 
						on startup; and use this to specify all equipment classes.. 
						
						Example:  Scenario classes:  "Heavy Fighter", "Ranger", "Archer", "Pyro Ranger", etc...
						
								  Equipment "Fire Axe":  In Class for "Pyro Ranger", "Heavy Fighter", but Out of class for
														 "Archer", and "Ranger".
														 
								  Message to Fighter -> Ranger (class):  Equipped "Fire Axe", "Miss Ratio" Stat altered by -0.2
								  
						Simple Example:  NO Extra Classes
						
										 Equipment "Wizard Staff": Marked "Out of class" for the Fighter. So Miss Ratio altered by -0.3
								  
- Equip Messages:  Show stat changes when equipping.								  

- Player Stat Points:  AT THE BEGINNING - ALLOW USER TO SETUP PLAYER STATS USING POINT SYSTEM.

- WPF RENDER REFACTORING:  PERFORMANCE IS A PROBLEM. WANT TO TRY DRAWING THE PATH DATA TO A BITMAP BEFORE RENDERING TO TRY AND 
						   SPEED UP PERFORMANCE. IF IT WORKS - THEN GO FOR THE NEXT LAYER WHICH IS THE OPACITY.
						   
- Equipment Explainations: Add section to show parameter changes by %.

- Equipment Quality Enhancement:  Alteration to enhance quality value for equipment! Need to separate armor types
								  and weapon types just like for Enchant and Imbue.

								  Example:  Sharpening Stone - Upgrades Quality for weapons by 0.3! :)

								  Example:  Anvil - (would need ImageResources) Upgrades Quality for Armor by 0.3! :) :)

								  Name:  Maybe "Upgrade Weapon" and "Upgrade Armor"

- Player "Aura" Refactoring:  Several things...
		
		1) Separate Auras from Light Radius

		2) Use Aura Effect Range to create new aura on top of the light radius. 

		3) Choose whether to change Light Color or to apply Aura on top of Light Circle (OR JUST SHOW AURA DURING USE)

		4) Show effect range in the Alterations screen.

		Effectively this should separate the two and show them independently
						  
- PLAYER DEATH R.I.P. TOMBSTONE (ALSO  PERMADEATH)

- Agility:  Want to support "Miss Ratio" character stat - which has to be factored into the calculation. So,
			need better understanding or model for the asymptotic parts using Agility so that player can
			progress and balancing is more interesting.

- Enemy List:  Similar to enemy scope; but is a list of enemys just during combat. Shows all enemies in visible range
			   and their relevant attributes - (Mostly progress Health bar would be the best).

			   Several Ideas...

			   Idea:  Only show health meter until "Knowledge" of this enemy is increased

					  - Maybe, increase using a ratio or function of enemy / player intelligence
					  - Increase based on defeating many of the same enemies
					  - Possibly increase based on alteration (NOT LIKELY)

			   Idea:  Show in the dialog window using a split window during combat

			   Idea:  Show the last hit as first in the list. So, do an insert at the top for the last
					  enemy hit.

			   Idea:  Show this meter over the head of each enemy (similar to a live action game)

					  LIKE THIS IDEA:  It saves lots of room; and would be simple if included as part of
									   a custom framework element for each enemy. Just create a framework 
									   element; and set the progress bar's render transform to offset it 
									   "above their heads".

- Refactor "SpellTemplate" to "AlterationTemplate"

- Fix calculations in Scenario Difficulty Service for attack attibute melee.

- Refactoring:  Alteration -> Mental Alteration, Physical Alteration, Equipment Alteration, etc...
							  Trying to figure out best way to break up that class into smaller parts.

				- When Refactoring: Create another level of abstraction to add other parts to a "Spell", or "Skill",
									or "Special Effect".. including animations, display text, etc... So that it makes sense
									in terms of parameters.

- Equipment Balancing:  Some new parameters to consider. These could be mostly calculated; but flags or support from
						Equipment items need to be considered.

						- Miss %:  Calculated based on character strength, agility, class, etc...
						- Quality: Change this to "Attack Value" or "Power" - And calculate based on
								   strength, agility, intelligence, character level, speed, etc... (possibly with flag support)
								   ("Grows with Level") - Power = Quality * Level.
								   ("Grows with Enemies Slain") - Power = Quality * Enemies Slain.

						Alterations could accompany the new parameters. Example:  "Sharpening Stone" improves base quality
						instead of attack attribute.

- Alteration Effect:  "Reactive Temporary/Passive"	Applies Attribute change as a counter attack. And "Attack Attribute Reactive Temporary/Passive"
					  That applies counter attack attribute attack.

- Equipment Quality Changing Alterations:  Class Change / Quality Change + plus or - minus. Example (sharpening Stone) + 0.1 to quality. Or skill of	
											enemy changes quality -0.3 (stone golem or something chips your blade). So, new alteration types required:
											   
											- Decrease Weapon Quality:  Alteration used as skill by enemy (or player) to degrade character equipped weapon
																		quality.
																		  
											- Decrease Armor Quality:  (similar)
											   
											- De-Enchant Weapon:  Alteration to degrade equipped weapon class (used by enemy or player as skill).
										   
											- De-Enchant Armor:   (similar)
											   
											- Increase Weapon Quality:  Alteration used by Player ONLY to upgrade any weapon's quality (using UI to select)
											   
											- Increase Armor Quality:  (similar)

- Noise dynamic attribute:  Can have noise level.. Noise can be generated by walking, or fighting. Items can have a noise
							multiplier or contribution.. Can also add to alteration effect (noise dampening). Noise
							would have the effect of engaging enemies from a radius determined by the noise level. It could
							also give away your location if you're invisible.

							**Could also have the calculation based on how quickly you make moves - (i.e. the time between
							  moves). Would be kind of neat :)

- Strength Requirement for Equipment (PROBABLY JUST USE HAUL)

- Contraptions:  Consumables that can set up a doodad in the level. 

- Doodad Effect:  Have it automatically hit all enemies without having to target.  Also, want to support "Everyone in Range"
				  and "Everyone except source in Range"
				  
				  ANOTHER EFFECT:  ATTRACTS ENEMIES (NEED ANOTHER CHARACTER STATE CALLED "AGGREVATED" TO HAVE AN EFFECT ON
				  ENEMIES AND MAYBE ALSO PLAYER.
				  
- Enemy Behavior:  Want to expand on current behaviors and starting positions. Would like to support groups or hordes of 
				   enemies. Also, want to employ a tertiary behavior.. Considering having them do something on each turn 
				   besides wait for the player.. Brogue has them Wander -> Sleep -> Hunt.
				   
				   - Idea: Support a dynamic list of behaviors - with one default (being attack player). This list acts as
						   a state machine - with conditions for the state to be active.
						   
						   - Condition:  Turn counter (internal to Behavior) is less than 10 (resets with each state change)
						   
						   - Condition:  Character stat is above / below some threshold
						   
						   - Condition:  Character is able to perform attack action (skill cost is met)
						   
				   - So, the enemy's behavior could roll-over from one to the next for as many as they've been configured with. Also,
				     the default behavior would catch if the rest of them feel through.
				   
				   - Idea: Add "Randomizer" to the behavior set. This would perform the function of selecting one behavior at
						   random every "X" number of turns.
						   
				   Also, want to better support Standoffish behavior by adding a parameter to specify the number of cells to
				   "stand off" before attacking. Then, create a new movement type called "Runs and Hides".

- Doodad:  Timed fire doodad. Triggered by character movement in range.

- Alteration Effect:  Sanctuary... Needs design :)  
- Alteration Effect:  Telepathy... Brogue ripoff :( But lots of fun! :)
- Alteration Effect:  True Polymorph (random enemy)

- Brogue Idea:  Searching.. can have search timers for objects near player. Doodads / hidden doors. Basically, implement above
				Brogue-style search without the "timed event". Really like how that plays.
				
- Brogue Idea:  Self-Identify.. One major problem in Rogue.NET and other rogue likes is the number / amount / variety of different
				items that are important to the story. Brogue lets you self-identify over a number of turns. I'd like to turn this
				up a notch and have items become more important and have more levels of depth (where appropriate).
				
				Many ideas... Have a static / dynamic number of "levels of depth" for each equipment item - allowing for identified traits at
				each level (big design problem here).  
				
					Example:  "This is a short steel sword" (Level 0 Description)
					
							  "This is a short steel sword that belonged to someone of the British Empire. It appears to be 
							   high quality" (Level 1 Description)
							   
							  "This is King William's personal guardian sword. It has this magical property" (Level 2 Description)
							  
					Example (Consumable):  "The scroll appears to have a red wax seal" (Level 0)
					
										   "The scroll has a gentle aura of goodness about it" (Level 1)
										   
										   "The scroll casts a spell of Healing" (Level 2)
				
				Progressing from one level to the next could just take a number of turns. Also, USING the item or piece of equipment 
				should expedite the speed at which it progresses to become fully identified. (And, of course, you could find consumables
				or doodads that do this as an alteration)
				
- Keys:  Consider getting rid of modifiers for doors / fighting.
				   
----------------------------
						  
- Add - Scenario details to Open screen
- Add - MP Low behavior
- Add - Message when saving game
- Add - Messages for spell alterations (melee messages)

- Change - Maze level "Dim Gray" to something brighter or colored (Firebrick Red)
- Change - Zealot skeleton animation to single blink

- ISSUE - "Standoffish" Can't calculate path to run away or open obstacles like doors
- ISSUE - Have to put in safety checks for completely filled level (Get Random Cell will crash)
- ISSUE - Teleporting enemies are still shown. Can see their new location
- ISSUE - Fix door issue (not opening; but open.. can't see through)
- ISSUE - "Blink" animations reveal the level size. Should turn those into blink for the full screen
- ISSUE - Uncurse pre-condition not calculated. Allowed casting of alteration (item grid). Also, "back" button on dialog was visible
- ISSUE - Pitfall STILL VISIBLE
- ISSUE - Need way to systematize placing level content (on the backend). So, probably best to have the IModelService place ANY contents
		  So that it can always check for free cells to place content on. If there's no cell available - need to decide how to proceed.. may
		  be that the content is objective and therefore has to be placed.
- ISSUE - See Invisible isn't working.
- ISSUE - Reveal isn't showing invisible enemies
			  
- Fix - Skill learning didn't work when player learned skill AFTER required level
- Fix - Multi-use consumables not updated after use
- Fix - Problem with Blindness - didn't recalculate enemy visibility immediately
- Fix - Zealots didn't move around
- Fix - Enemy opens door - trigger topology change (something went wrong.. didn't show door opened)
- Fix - Apply limits to MP (negative value on Lynx evaporate MP)
- Fix - Update player symbol when activating skill (should be done on turn)
- Fix - Add Attack Attribute melee message to player spell and enemy spell (meleetarget)
- Fix - Spiral Target with constant velocity animation caused crash "Trying to calculate const velocity for spiral animation"
- Fix - "Vile Mother has used 'Create Vile' on"
- Fix - Identify for non-class items should identify all future non-class items with the same RogueName
- Fix - Identify All isn't updating the Encyclopedia view
- Fix - Wraith's drain experience doesn't knock player down a level (need this one for item / equipment / skill requirements)
						
- Balancing (Paladin) - Add some skills for learning: Disciple, Satanic Priest, maybe one or two other.. but EViL! >_<

--------------

IMMEDIATE TODO'S:

	- Clear out message box when re-starting.

	- Use points to increase stats instead of randomly doing it when gaining a level.
	
		- SMALL REFACTORING:  Create a few different types of level commands:  Normal; 
							  View Action Command; Imbue Equipment Command; Player Advancement Command.
							  
							  Need to expand this some to include actions with new data.  This is mainly
							  for new dialogs with other data fed back to the backend.
							  
	- Nice to have:  Explain attack attributes by having a separate UI to show how they apply
---------------
		
	- PERMADEATH
	- Dependencies:  Take the algorithm from Traingle.NET and remove code
	- Dependencies:  Look for source for Dotaway - OR just write:  a desaturation algorithm; and a pixelation algorithm.
	- FIRST BIG TODO:  Refactor Animation targeting type to handle physical cases:
	
					   Problem:  There's an un-written "coupling" between animations and alterations. Example is "Run Away"
								 which affects the source character only (as an alteration). Choosing "Target to Source" animation
								 type can cause a crash or issue because they don't relate.
								 
					   Solution: Force animation type selection to work with physical content and alteration calculating. An example
								 would be calculating some kind of "range". It's usual for an animation to have some kind of range 
								 associated with it; but it relies on the considered targets. 
								 
							     So, "Targets in range" would become something like "Calculated Alteration Targets". If you tried
								 to apply this to "Source.RunAway" then you'd have the following:  
								 
								 - Calulate Affected Characters => Source (enemy)
								 - Calulate Altertion Targets => Source (enemy)
								 - Apply Animation: No animation applied because there is no target apart from source
								 
					   Other Solution:  Add specific parameters to the animation related to the calculation. Example: Range parameter.
								 
					   Main Idea: If this can be accomplished without refactoring then it should be validated that any animation 
								  support be verified before hand so that you don't have issues in game. 
	
	- NEXT BIG TODO:  Figure out a way to calculate combat value for items based on player parameters (Level, Strength, Agility, Intelligence)
	- OTHER BIG TODO:  Redo enemy behavior
	- OTHER BIG TODO:  Make pathfinding algorithm more efficient.
	- OTHER OTHER BIG TODO:  Terrain
	- TODO: Path-finding efficiency
	- TODO: Fix up the simulator for equipment attack / defense values based on attributes; and anything else that has changed.
	- TODO: Generate Alterations right away (don't store the template on the item / enemy behavior). To randomize add a component
			to do this with some variance (gaussian distributed or whatever) around the base (mean) instead.
			
			If this works out without too much trouble - repeat this EVERYWHERE. Just get rid of RANGE values and use a randomizer!
			This will simplify the hell out of everything.
			
	- TODO: Remove the level range specification from all assets. Add a list of level specifications: each has a list of consumables,
			equipment, enemies, doodads, a layout, etc.. and generation rates, variances, etc... This would virtually eliminate the
			need for templates; but would introduce a new class of components to place / specify / randomize everything. This class
			should be MUCH smaller than the currently supported scenario configuration. 
			
	- TODO: Remove list sharing for all asset properties. Example:  Consumable.Alteration should not reference a list of alterations. Also,
			apply to attack attributes, character classes, altered state, etc... Create them in the asset UI - but show a list of what
			currently is in the scenario - with option to copy one that's already there. Then, in the "General" section, just show an
			aggregate of all of these "shared" asset properties to show what they are. Then, for meta-data, create these lists on-the-flying
			as these asset properties are generated. Example:  Create first "Poison" Attack Attribute. Event Aggregator fires the event
			and another component maintains the collection of meta-data for attack attributes. 
			
	- IDEA: To keep / maintain shared collections - use attributes for the class to identify the location of it's "master list". This will
			help avoid maintainence issues for the many "Fix Reference" methods.... Uuugh.
			
	- TODO: Clean up "engines" and systematize. Componentize things a little better; and make it known how messages are being published.
	
	- TODO: Propagate the name of the Alteration template to the corresponding Alteration Effect template.
	
	- IDEA: "Interlude" for the scenario - Fade-in message on-screen after Level "X" to show a part of the story.
	
	- IDEA: Friendly unit type. (Easier that it sounds probably). 
	
			- Friendly derived Character type
			- Add check for Player movement so that you can swap places with Friendly units to avoid obstructing your path
			- Add targeting type for Alterations to select unit type (Example:  Heal all friendly units in range, or Heal Player type units)
			
			- Then, it should be very easy to support a Necromancer scenario :)
			
	- IDEA: Undo Service. This is a difficult problem I think in most any editor program. I tried building a stack-based Undo function using
			the INotifyPropertyChanged and INotifyCollectionChanged mechanism in WPF. I think it mostly worked; but there are some nagging
			issues with event coverage because I feel like we're missing some of the events that should be forwarded and kept by the Undo Service.
			
			So, my design idea goes like this:  
			
				   Get a handle on binary serialization - to where we can represent the data as a binary "Blob" and changes to the data 
				   as SMALL "Deltas" - with some change description. 
				   
				   Example:  ModelChange { Data[], int Offset, int Length, string ChangeType, string ChangeDescription }
				   
				   So, the entire "Blob" of changes should represent the data model - just a serialized version of it that we can use
				   to provide an Undo Service. 
				   
				   Synchronizing the Undo "Blob" and the actual model is the only major worry.. but if there's a way to do this with the
				   actual model - that would be even more idea. I'm just not sure how that might work.
				   
			Thinking about it some more...
			
				   The major problem with this design (like the current design.. or any other design) is synchronization of two versions
				   of the same data model. I don't like it..
				   
				   So, a better way to do this: Create a custom serialization service
				   
						- Serializes all public properties using Reflection
						
						- Creates a custom serializer for each property type
						
						- Validates that all public properties have a serializer (or throws an exception)
						
						- Underlying binary format chosen by the serializer - with the main "Blob" being a simple byte[]. 
						
						- The Primary object graph is serialized with a CUSTOM METHOD. This is important to 
						  deal with reference checking. 
						  
						  An example of a serialization service that works ONLY FOR TREES (non-cyclical object graphs) is
						  PROTOBUF!  Which I don't think they tell you... but you have to build your own custom routine 
						  using their pseudo-language. 
						  
						  This is essentially what I'd build here - except with direct control over the byte[] in a way to
						  be able to insert, add, or remove changes.
						  
						  Example:  ScenarioConfigurationContainer has a ISerializationService implementation with a methods
									called ISerializationService.Serialize.  Then, there'd be support for changes to the model
									that needs to be worked out.. Maybe using some kind of attribute mechanism.. but I think it
									would have to be specific to the model structure. 
									
									Maybe, [SerializationUpdateAttribute( Some.. Properties.. to.. Specify.. Update )] for each
									type (or public property)
									
						  However, I believe that the INotifyPropertyChanged / INotifyCollectionChanged events would still be 
						  used - just with a different listener - which would be the ISerializationService. This service would
						  probably then notify the Undo service with some change description which would (of course) be compatible
						  with the serialization service.
						  
				   SHOULD THIS BE SUCCESSFUL:  I'd use this for the primary model serializer.. and any other serialization we do.. 
											   even just as an experiment to work with primitive data serialization more closely
											   and to understand better the crux of the problem.
											   
											   Dealing with cyclical object graphs is a trickier problem which I'd think is out of
											   scope.. but if I felt confident in trying - it might be worth the effort to learn
											   a little more from reading or research because this problem is fundamental and I don't
											   see it done properly anywhere .. EVER.. usually.. but the tree-object-graph is simple
											   and this one is done well.
											   
    - TODO: Validate that the AlterationContainer.RogueName (GETS COPIED TO) IAlterationEffect.RogueName. Add validation rule.
	
	- TODO: Must have "Normal" Altered State (Somehow...) Not sure how to do this one.. But it needs to be done because the boolean 
			flags to control "HasAlteredState" have been removed in favor of a default "Normal" state.
			
	- TODO: Build Enum-to-Radio-Button-with-attribute-description control to handle choosing an enum for the editor
			
	- IDEA: If there's want to do this for the Sorcerer - have different targeting "types" for moving the targeting cursor around manually.
			
				- In Visible Range: Could teleport yourself OR ANOTHER CHARACTER from one place to another in your visible range.
				
				- In Explored / Revealed Range: Could teleport yourself OR ANOTHER CHARACTER from any explored / revealed location to another.
				
				- In Range of Player "Special Reveal":  This would temporarily reveal a certain distance from your player to accomplish
														the same task of teleporting yourself or an enemy. 
														
				- Have to avoid obstacles:  Cursor should blink "Red" if you can't move there. 
				
				- ANOTHER IDEA:  "Force Enemy Back" pushes enemy in line of sight backwards into Wall / Another Enemy. Would be nice
								 to animate this - maybe kind of like "Clay-mation" (cell, cell, cell, BAM!) Or something else.. Would
								 damage all characters involved.
								 
				(The next two could support the "Doom Sorcerer")
				
				- INSTANT DEATH:  "Abolish Enemy to the Void" some kind of alteration based on character attributes.. maybe intelligence,
								  uniqueness, or some other thing that instantly kills the character.
								  
				- "CONDEMNED":  Event that goes like this:  Character 1 casts alteration on Character 2 that starts a timer (if it's not blocked). 
								The timer should be shown somewhere so that the user knows that either they're going to die or their enemy
								is going to die.
								
								The way to defeat it is to 1) Have a remedy for the temporary event alteration or 2) to defeat the other character :)
						  
	- TODO: Use either Routed Attached Event or ServiceLocator -> EventAggregator to supply changes for Undo instead of INotifyPropertyChanged. Also,
			have to Hook new complex types in UndoAccumulator when they're changed. 
			
			THIS MIGHT BE A VERY SIMPLE UNDO SERVICE
			
	- IDEA: Could support "Detect Magic"
	
	- TODO: Attack Attribute Refactoring
			
			1) REMOVE SHARED COLLECTION FROM SCENARIO CONFIGURATION
			
			2) Create Attack Attribute collections sparsely - using a service to provide a scenario-wide collection to COPY from
			   to create an instance for the asset or alteration effect
			   
			3) Shrink the UI for editing them to one-line; and add an option to show / hide the attack, resistance, and weakness appropriately
			
			4) FOR THE SCENARIO SIDE:  Either A) Leave the design AS IS and pre-copy FULL LISTS of attributes to each asset / alteration effect
										   or B) Work with sparse collections and re-design how they're used to accomodate differing sets
										   
	- TODO: Finish Alteration Effect UI
			
			- Fix up controls and fit them to the design area
			
			- MOVING BRUSHES TO NON-SHARED ASSET:  Put Brush Editor on the Animation Editor (Nothing else for now...)
			
			- REMOVE STROKE TEMPLATE
			
			- Verify that stale data doesn't stay in display when switching assets
			
			- Create one of each new Alteration effect type for the Sorcerer scenario
			
			- Validate Alteration Effects for some of the low-hanging fruits; and don't go overboard
			
			- FIX UP THE ASSET REFERENCE SERVICE
			
			- Add Default Implementation Type for IAlterationEffectTemplateViewModel.. Probably instantiate the null values in the 
			  Scenario Configuration Mapper when fixing references... OR where the source null values are instantiated (commented code)
			  in the mapper using reflection.. Not necessary though because any developer can figure out what's happening and there'safety
			  no crash in the UI for an unset alteration effect. It's just bothersome to work with.
			  
    - THOUGHT:  Using Protobuf to deal with serialization might be a good idea. Basically, it would be better to have a single 
				source for the model than two. I believe Protobuf can generate code based on its "source (custom) language". Also,
				I think it deals with serialization - and I'd like that to be handled in a single place.. If it was language
				agnostic serialization that would be IDEAL. 
				
				Protobuf treats object graphs like trees by default; but I think you can customize the "source code" for the 
				object graph to have shared instances. 
				
				If this isn't possible - it would be a fun exercise to try and build something like this from scratch; and to be able to
				handle some of the primary design issues for the Scenario Configuration:
				
					- Mapping:  Going from one namespace to the other seamlessly
					
					- Serialization: Being able to serialize the MODEL independent of the "target language" (either Model or ViewModel)
					
					- Versioning: Handling changes to the model without fear of loosing data
					
					- Code Generation:  Generating "target languages" - probably based on a text-based template:  one for the model namespace
										and one for the view-model namespace that took care of inheritance from DependencyObject, Interface 
										implementations, etc, etc...
										
					- Database Backup:  Going from the "source language" to a database schema seamlessly would be very nice.
										
				THESE WOULD BE GREAT THINGS TO HAVE.
				
	- TODO: Make Rogue.NET playable with only the mouse
	
	- TODO: Want probability parameter on the Equipment Attack Atleration.
	
	- TODO: Type-Specific tooltip for IAlterationEffect. This will help show all the wonderful / different effects of items. Also, can reuse
			the UI in other places:  Skill Tree, and Rogue Encyclopedia
			
	- TODO: Provide Brush-Copy service that provides list of all brushes in the scenario to copy from - with a preview image (add to brush editor)
	
	- TODO: Provide asset navigation from Construction -> Assets. Also, make the Construction re-load on click.
	
	- TODO: Immunity Alteration Effect - Makes you immune to a specific altered state.	
										
	- TODO: Skill / Reveal UI (clean up)
	
	- TODO: 
				- Haul Usage:  WHEN HAUL IS EXCEEDED - PLAYER MUST DROP SOMETHING TO PROCEED. This should be used when enemies drain strength from
							   player.
							   
				- Animations:  Validate parameters so they don't cause in-game error message
				
				- Modify Equipment:  Implement enemy alteration on player as EQUIPPED ONLY.
				
				- Gremlin (Fighter Scenario): Change teleport to "Blink" inside player visible range (it's super annoying :))
				
	- TODO: Hide the Scenario Seed and randomize it by default
			
	- TBD:  If the scenarios need to be randomized for items (the symbol color) - might consider refactoring the images:
	
			1) Use SVG vector graphics
			
			2) Find a default coloring that works with HUE shifts to create the various colors (or) build some kind of 
			   rotating color filter that can handle creating something like primary -> secondary -> tertiary colors from
			   maybe a set of mask colors that can be used to create the base SVG.
			   
			3) Using a color filter - apply to create symbol changes instead of the parameterized one that's there. That
			   would save a lot of time / parameter space.
			   
			4) Find a way to convert symbols into SVG's - should reduce the resource set by a factor of 10.
			
			5) Consider creating a subset of UTF-8 as a vector image set to show / size into cell containers. Problem is
			   that some symbols get cut off - so would want to resize to fit. (Probably could do this by measuring the
			   TextBlock first also)
			   
	- TODO:  Attack Attribute Refactoring:
	
				1) REMOVE SHARED ATTACK ATTRIBUTE COLLECTION FROM SCENARIO CONFIGURATION AND SCENARIO.
				
				2) Use sparse attack attributes; but create some centralized methods to apply them
				
				3) Simplify Alteration Effects by using SINGLE attack attributes for some; but breaking up the class into
				   several use cases:
				   
					- Attack Attribute:  (A, R, W)
					- Attack Attribute Positive Change:  (A, R, W) -> (+, +, -)
					- Attack Attribute Negative Change:  (A, R, W) -> (-, -, +)
					
				4) Provide services for supplying the full attack attribute list
				
	- TODO: Deal with proper nouns. Probably can do this using a flag on the enemy. "Use Proper Noun" (when addressing enemy)
	
	- TODO: HasAlteredState flag for each temporary
	
	- TODO: Enemy Light Radius - HAS BEEN MOVED TO CHARACTER BASED
			
			- NEXT:  Design behavior around Light Radius (Engage / Disengage) - (not necessarily around this parameter)
			
			- Then:  Enemy Targeting - Skill behavior around light radius
			
			- Then:  Line-of-sight per character - calculated on turn.
			
			- Then:  Enemy / Doodad as light source :)
			
			After that - decide how to do targeting:
			
				- Player "target what you can see?"
						 "miss if out of range?"
						 "miss probability?"
						 "miss probability per alteration effect?"
				
				- Enemy  "target what you can see?"
					     "engage if illuminated?"
						 "engage if you can HEAR?"
						 
			The idea is just to enhance the API - but to keep it INTUITIVE. So, if it makes sense to do
			then do it. Right now it's calculated all based on the Player visible range; but that can
			change if the light-of-sight calculation isn't too intensive.
			
			If it is - then just use the enemy light radius in calculations.
	
	- TODO: Refactor End-Of-Turn logic.
	
			- This generally needs to be systematized. It's all out of sorts - and there's no sequencing. It should
			  be pretty easy and straight forward to do.
			  
	- TODO: Refactor Front-end logic some to remove ambiguity about updating player v.s. enemy (just do characters)
			
			Also, have a single enumeration (or method) to run an update per character (unless processing gets too slow);
			but mostly to handle updating everything about a character without ambiguity.
			
			Example:  Apply an alteration. RogueUpdateEvent(AffectedCharacter.Id, Enum.SomeSpecificProperty [Flags])
					  Can handle the update. 
					  
					  The problem is that the symbols for the characters are handled when they move around. This needs
					  to be decoupled.
					  
					  If necessary - add a simple front-end controller to handle "Update for a character"
					  
					  IContentUpdateController
					  
						- UpdateSymbol(CharacterBase.Id)
						- UpdateEquipment(CharacterBase.Id)
						- UpdateAlterations(CharacterBase.Id)
						- Remove(CharacterBase.Id)
						- Add(Character)
						
					  Also, break up and componentize LevelCanvasViewModel - which basically is a collection of ScenarioImage
					  elements - to be drawn / updated somewhere else; and collected by the IContentUpdateController.
					  
	- TODO: Make sure to apply "Generate on step" to enemies
	
	- TODO: Make throwing generic - not pre-specified:
	
			1) Every item has a base throw effect - something like (Strength * [Throw Quality])
			   AND something to deal with accuracy - maybe (function(Strength, Agility, and maybe [Throw Accuracy]))
			   
			   Probably want a couple parameters for the item so that it makes sense.. Can't do much
			   damage throwing armor; but you could try...  (it won't help to be strong)
			   
			2) Player can try throwing any item; AND it's only consumed when it strikes the enemy 
			   (like DOS Rogue or Brogue)
			   
			3) If there's ever time to do the per-step-identify (Identify items in levels based on 
			   a) how long you have them (by type) and b) if you're using them, etc...) Then, this
			   could be a part of that. (IdentifyParameter class to specify how it all happens. One
			   per effect to identify)
			   
			4) For any special effects - they'd have to be added to the item. So, that could be done
			   on the base class so that the player could try throwing equipment. 
			   
			That's pretty much all; but the idea is to try different things instead of being guided
			by the throw effect that's already there on the consumable.
			
	- TODO: Skill Alteration UI: Fix up Block Type, Animation Opacity Binding (all alterations), Visibility for
			Aura Source parameters.
			
	- TODO: Fix overlapping characters - seeing a problem using "Blink" and create monster (near the player).
	
	- TODO: Restrict Equipment Attack Alteration to One / Two handed melee weapons
	
	- TODO: Create Drain [Parameter] Equipment Attack Atleration Effect. Basically, Drain HP; but make a different
			class to support it. Apply ONLY as an Equipment Attack Atleration.
			
	- TODO: Set Attack Attribute Collections EN-MAS for any new asset. FIX EXISTING ASSETS (Asset Reference Service)
			   
	- TODO: Consider systematizing part of the alteration effect pattern to consolidate some of the type inspection.
	
	- TODO: Finish alteration sub-panel by showing what aura effects do - and effects of enemy equipment auras.
	
	DECIDED TO CREATE A COMPONENT FOR STORING GRID-LEVEL INFORMATION ABOUT LINE-OF-SIGHT / LIGHT RADIUS / AURA RADII
	
		Assumptions:       Player Type (currently) is treated as a light SOURCE; "Light Radius" really means "Sight Radius" (TODO - Refactor).
						   Auras are independent of "Light Radius" and light SOURCES.
						
						   Any character (or object) COULD be marked as a "Light Source"; but that's not currently supported. It
						   would be nice to have light sources in the scenario.. Possibly even on the walls (like a flag on each
						   cell to be accounted for on this component).
						
		How to Calculate:  What's this for? This will calculate all characters' line-of-sight: locations; objects (enemies, doodads, items);
						   Light "radius" locations; and aura radius locations for all alterations. PER CHARACTER.
						   
						   The state should be stored here; but not serialized. 
	
		Input:  		   Any Character
		
		Calculations:      Line-of-sight, Light Radius, Aura Radius (per aura)
		
		Output:   		   Line-of-sight:        Locations
						   Light Radius:  		 Locations
						   Aura (many):          Locations, Colors
						   
		Future TBD: 	   The point of this component is to start to consolidate some of the grid-related scenario data that 
						   needs to be calculated and stored. 
						   
						   There's lots of ideas of what to do in the future if there's time. One would be to create more light 
						   sources - which is pretty straight forward given this design. Another could be cell coloring or opacity
						   based on many different character's auras, light source (maybe colors), etc.. Then, line-of-sight 
						   is probably more important - as it could change some of the possible actions of the characters.
						   
						   Example: Enemy is far away; but in a lit-up tile (another object's light radius). You could try and
									throw / fire something at the enemy; but have a small % of success. 
									
									More imporantly - you could see the enemy.
									
						   Another idea is to have patches of lit up tiles as part of the layout. This would be to simulate light
						   coming in through the ceiling. (varying per level)
						   
						   One final one - requiring more design - is TERRAIN :) :) :)  Water, Fire, Swamp, Steam, Anything Brouge
						   tried - but only if there's others helping because it's a lot to do.
						   
						   Light sources, auras, and line-of-sight would probably be enough for this guy.
						 
	- TODO: Draw a Diagram of the Backend Processing.
	
				- Start with the ScenarioService - drawing pointers for each method entry into the engines.
				
				- Show the flow of events onto the ScenarioService queues.
				
				- Show the updating of the UI from events.
				
			Need to know how the backend is updated - specifically:
			
				- Character stats
				
				- Layout (Topology and visibility and line-of-sight)
				
				- Character Visibility (Same component)
				
				- Item / Object Visibility (And Revealed / Explored status)
				
			So, need to understand the sequence of events surrounding specific actions to be able to be
			confindent systematizing the backend end-of-turn logic.
			
			IDEA:  Hide the Level object inside the IModelService (or something like that component) and
				   prevent firing of events to the queues where possible.
				   
				   It would be easier to think of if the update events were encapsulated into components;
				   and the major data containers were also encapsulated with those components - so updating
				   the front end and queuing up other events was much more intuitive.
				   
			NEEDS TODO:  It's getting a little too involved to keep queuing events for the back end. The
						 processing needs to be refactored to make it easier to manage the state (IModelService)
						 sequentially.
						 
						 IDEA:  SEQUENCE all character activities. This could be accomplished with some other
								simple queue architecture that allowed sequences (maybe per character) to be
								processed before continuing with other sequences.
								
								Example:  Player Reveal Item -> Animation, Consumable Item Remove, Revealed Content, 
									      UI Updates -> Enemy 1 Reaction (.., .., ..) -> Enemy 2 Reaction -> (.., .., ..)
										  
										  What this means is that the queues could provide a sequence for these 
										  actions. 
										  
										  BUT - there's a big problem with updating the state. Model updates have
										  to be injected where they're important.. maybe between characters. 
										  
										  Player -> Model update -> Enemy 1 -> Model Update -> ...
										  
										  There might be a better way; but trying to sequence all of these things
										  at the "End of Turn" really doesn't work right.
										  
										  I'm thinking it should be more like this:
										  
										  Player -> Player End of Turn -> Model update -> Check for Scenario Event (Player Died, etc..)
										   -> Enemy 1 -> Enemy 1 end of turn -> Model update -> Check for Scenario Event (Player Died, etc..)
						   
										  So, as long as the processing isn't too involved - it might be easier just
										  to check "everything" or "everything per character" (which includes bigger
										  events like player death, or level change, or maybe dialog events) between
										  queued reactions.
										  
										  Then, one final primary concern is when to update the UI. Animations should
										  take the highest priority; but UI updates I'd think should also be done 
										  between characters. And, the Update types probably should be thinned out and
										  just refactored.
										  
										  The LevelCanvasViewModel is also too crowded and needs refactoring. 
										  
										  The design favoring a front-end controller would be ideal for processing 
										  updates PER-CHARACTER. So, if this new queueing design is implemented - 
										  it might be a good idea to try and work with the front end to break up
										  some of that junk that's collected to update view models.
										  
	- IDEA:  Have an enemy behavior condition that "helps them when they're lagging behind the player". Maybe like 
			 the hippogrif in the socerer scenario casts "gather" when they're lagging behind. or teleport near player.
			 
			 Also, TELEPORT ADJACENT PLAYER would be a nice-to-have effect enum.